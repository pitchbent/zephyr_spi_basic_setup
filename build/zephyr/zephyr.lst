
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

60000000 <qspiflash_config>:
60000000:	46 43 46 42 00 04 01 56 00 00 00 00 01 03 03 00     FCFB...V........
	...
60000040:	10 00 00 00 01 04 07 00 00 00 00 00 00 00 00 00     ................
60000050:	00 00 80 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
60000080:	eb 04 18 0a 06 32 04 26 00 00 00 00 00 00 00 00     .....2.&........
60000090:	05 04 04 24 00 00 00 00 00 00 00 00 00 00 00 00     ...$............
	...
600000b0:	06 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
600000d0:	20 04 18 08 00 00 00 00 00 00 00 00 00 00 00 00      ...............
	...
60000100:	d8 04 18 08 00 00 00 00 00 00 00 00 00 00 00 00     ................
60000110:	02 04 18 08 04 20 00 00 00 00 00 00 00 00 00 00     ..... ..........
	...
60000130:	60 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00     `...............
	...
600001c0:	00 01 00 00 00 10 00 00 01 00 00 00 00 00 00 00     ................
600001d0:	00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

60001000 <image_vector_table>:
60001000:	d1 00 20 41 00 38 00 60 00 00 00 00 30 10 00 60     .. A.8.`....0..`
60001010:	20 10 00 60 00 10 00 60 00 00 00 00 00 00 00 00      ..`...`........

60001020 <boot_data>:
60001020:	00 00 00 60 00 00 80 00 00 00 00 00 ff ff ff ff     ...`............

60001030 <dcd_data>:
60001030:	d2 03 e0 41 cc 03 5c 04 40 0f c0 68 ff ff ff ff     ...A..\.@..h....
60001040:	40 0f c0 6c ff ff ff ff 40 0f c0 70 ff ff ff ff     @..l....@..p....
60001050:	40 0f c0 74 ff ff ff ff 40 0f c0 78 ff ff ff ff     @..t....@..x....
60001060:	40 0f c0 7c ff ff ff ff 40 0f c0 80 ff ff ff ff     @..|....@.......
60001070:	40 0d 80 30 00 00 20 01 40 0d 81 00 10 18 10 1b     @..0.. .@.......
60001080:	40 0f c0 14 00 0a 83 40 40 1f 80 14 00 00 00 00     @......@@.......
60001090:	40 1f 80 18 00 00 00 00 40 1f 80 1c 00 00 00 00     @.......@.......
600010a0:	40 1f 80 20 00 00 00 00 40 1f 80 24 00 00 00 00     @.. ....@..$....
600010b0:	40 1f 80 28 00 00 00 00 40 1f 80 2c 00 00 00 00     @..(....@..,....
600010c0:	40 1f 80 30 00 00 00 00 40 1f 80 34 00 00 00 00     @..0....@..4....
600010d0:	40 1f 80 38 00 00 00 00 40 1f 80 3c 00 00 00 00     @..8....@..<....
600010e0:	40 1f 80 40 00 00 00 00 40 1f 80 44 00 00 00 00     @..@....@..D....
600010f0:	40 1f 80 48 00 00 00 00 40 1f 80 4c 00 00 00 00     @..H....@..L....
60001100:	40 1f 80 50 00 00 00 00 40 1f 80 54 00 00 00 00     @..P....@..T....
60001110:	40 1f 80 58 00 00 00 00 40 1f 80 5c 00 00 00 00     @..X....@..\....
60001120:	40 1f 80 60 00 00 00 00 40 1f 80 64 00 00 00 00     @..`....@..d....
60001130:	40 1f 80 68 00 00 00 00 40 1f 80 6c 00 00 00 00     @..h....@..l....
60001140:	40 1f 80 70 00 00 00 00 40 1f 80 74 00 00 00 00     @..p....@..t....
60001150:	40 1f 80 78 00 00 00 00 40 1f 80 7c 00 00 00 00     @..x....@..|....
60001160:	40 1f 80 80 00 00 00 00 40 1f 80 84 00 00 00 10     @.......@.......
60001170:	40 1f 80 88 00 00 00 00 40 1f 80 8c 00 00 00 00     @.......@.......
60001180:	40 1f 80 90 00 00 00 00 40 1f 80 94 00 00 00 00     @.......@.......
60001190:	40 1f 80 98 00 00 00 00 40 1f 80 9c 00 00 00 00     @.......@.......
600011a0:	40 1f 80 a0 00 00 00 00 40 1f 80 a4 00 00 00 00     @.......@.......
600011b0:	40 1f 80 a8 00 00 00 00 40 1f 80 ac 00 00 00 00     @.......@.......
600011c0:	40 1f 80 b0 00 00 00 00 40 1f 81 88 00 00 00 e1     @.......@.......
600011d0:	40 1f 81 8c 00 00 00 e1 40 1f 81 90 00 00 00 e1     @.......@.......
600011e0:	40 1f 81 94 00 00 00 e1 40 1f 81 98 00 00 00 e1     @.......@.......
600011f0:	40 1f 81 9c 00 00 00 e1 40 1f 81 a0 00 00 00 e1     @.......@.......
60001200:	40 1f 81 a4 00 00 00 e1 40 1f 81 a8 00 00 00 e1     @.......@.......
60001210:	40 1f 81 ac 00 00 00 e1 40 1f 81 b0 00 00 00 e1     @.......@.......
60001220:	40 1f 81 b4 00 00 00 e1 40 1f 81 b8 00 00 00 e1     @.......@.......
60001230:	40 1f 81 bc 00 00 00 e1 40 1f 81 c0 00 00 00 e1     @.......@.......
60001240:	40 1f 81 c4 00 00 00 e1 40 1f 81 c8 00 00 00 e1     @.......@.......
60001250:	40 1f 81 cc 00 00 00 e1 40 1f 81 d0 00 00 00 e1     @.......@.......
60001260:	40 1f 81 d4 00 00 00 e1 40 1f 81 d8 00 00 00 e1     @.......@.......
60001270:	40 1f 81 dc 00 00 00 e1 40 1f 81 e0 00 00 00 e1     @.......@.......
60001280:	40 1f 81 e4 00 00 00 e1 40 1f 81 e8 00 00 00 e1     @.......@.......
60001290:	40 1f 81 ec 00 00 00 e1 40 1f 81 f0 00 00 00 e1     @.......@.......
600012a0:	40 1f 81 f4 00 00 00 e1 40 1f 81 f8 00 00 00 e1     @.......@.......
600012b0:	40 1f 81 fc 00 00 00 e1 40 1f 82 00 00 00 00 e1     @.......@.......
600012c0:	40 1f 82 04 00 00 00 e1 40 1f 82 08 00 00 00 e1     @.......@.......
600012d0:	40 1f 82 0c 00 00 00 e1 40 1f 82 10 00 00 00 e1     @.......@.......
600012e0:	40 1f 82 14 00 00 00 e1 40 1f 82 18 00 00 00 e1     @.......@.......
600012f0:	40 1f 82 1c 00 00 00 e1 40 1f 82 20 00 00 00 e1     @.......@.. ....
60001300:	40 1f 82 24 00 00 00 e1 40 2f 00 00 10 00 00 04     @..$....@/......
60001310:	40 2f 00 08 00 00 00 81 40 2f 00 0c 00 00 00 81     @/......@/......
60001320:	40 2f 00 10 80 00 00 1b 40 2f 00 14 82 00 00 1b     @/......@/......
60001330:	40 2f 00 18 84 00 00 1b 40 2f 00 04 00 00 79 88     @/......@/....y.
60001340:	40 2f 00 40 00 00 0f 07 40 2f 00 44 00 65 29 22     @/.@....@/.D.e)"
60001350:	40 2f 00 48 00 01 09 20 40 2f 00 4c 50 21 0a 08     @/.H... @/.LP!..
60001360:	40 2f 00 80 00 00 00 21 40 2f 00 84 00 88 88 88     @/.....!@/......
60001370:	40 2f 00 94 00 00 00 02 40 2f 00 98 00 00 00 00     @/......@/......
60001380:	40 2f 00 90 80 00 00 00 40 2f 00 9c a5 5a 00 0f     @/......@/...Z..
60001390:	cf 00 0c 1c 40 2f 00 3c 00 00 00 01 cc 00 14 04     ....@/.<........
600013a0:	40 2f 00 90 80 00 00 00 40 2f 00 9c a5 5a 00 0c     @/......@/...Z..
600013b0:	cf 00 0c 1c 40 2f 00 3c 00 00 00 01 cc 00 14 04     ....@/.<........
600013c0:	40 2f 00 90 80 00 00 00 40 2f 00 9c a5 5a 00 0c     @/......@/...Z..
600013d0:	cf 00 0c 1c 40 2f 00 3c 00 00 00 01 cc 00 1c 04     ....@/.<........
600013e0:	40 2f 00 a0 00 00 00 30 40 2f 00 90 80 00 00 00     @/.....0@/......
600013f0:	40 2f 00 9c a5 5a 00 0a cf 00 0c 1c 40 2f 00 3c     @/...Z......@/.<
60001400:	00 00 00 01 cc 00 0c 04 40 2f 00 4c 50 21 0a 09     ........@/.LP!..
	...

60003800 <_vector_table>:
60003800:	40 29 00 80 15 4f 00 60 0b ab 00 60 e9 4e 00 60     @)...O.`...`.N.`
60003810:	e9 4e 00 60 e9 4e 00 60 e9 4e 00 60 00 00 00 00     .N.`.N.`.N.`....
	...
6000382c:	35 49 00 60 e9 4e 00 60 00 00 00 00 dd 48 00 60     5I.`.N.`.....H.`
6000383c:	9d 67 00 60                                         .g.`

60003840 <_irq_vector_table>:
60003840:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003850:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003860:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003870:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003880:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003890:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600038a0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600038b0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600038c0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600038d0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600038e0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600038f0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003900:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003910:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003920:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003930:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003940:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003950:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003960:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003970:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003980:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003990:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600039a0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600039b0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600039c0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600039d0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600039e0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
600039f0:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003a00:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003a10:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003a20:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003a30:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003a40:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003a50:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003a60:	e1 49 00 60 e1 49 00 60 e1 49 00 60 e1 49 00 60     .I.`.I.`.I.`.I.`
60003a70:	e1 49 00 60 e1 49 00 60                             .I.`.I.`

Disassembly of section text:

60003a78 <__aeabi_uldivmod>:
60003a78:	b953      	cbnz	r3, 60003a90 <__aeabi_uldivmod+0x18>
60003a7a:	b94a      	cbnz	r2, 60003a90 <__aeabi_uldivmod+0x18>
60003a7c:	2900      	cmp	r1, #0
60003a7e:	bf08      	it	eq
60003a80:	2800      	cmpeq	r0, #0
60003a82:	bf1c      	itt	ne
60003a84:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
60003a88:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
60003a8c:	f000 b80c 	b.w	60003aa8 <__aeabi_idiv0>
60003a90:	f1ad 0c08 	sub.w	ip, sp, #8
60003a94:	e96d ce04 	strd	ip, lr, [sp, #-16]!
60003a98:	f000 f808 	bl	60003aac <__udivmoddi4>
60003a9c:	f8dd e004 	ldr.w	lr, [sp, #4]
60003aa0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
60003aa4:	b004      	add	sp, #16
60003aa6:	4770      	bx	lr

60003aa8 <__aeabi_idiv0>:
60003aa8:	4770      	bx	lr
60003aaa:	bf00      	nop

60003aac <__udivmoddi4>:
60003aac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
60003ab0:	4686      	mov	lr, r0
60003ab2:	468c      	mov	ip, r1
60003ab4:	4608      	mov	r0, r1
60003ab6:	9e08      	ldr	r6, [sp, #32]
60003ab8:	4615      	mov	r5, r2
60003aba:	4674      	mov	r4, lr
60003abc:	4619      	mov	r1, r3
60003abe:	2b00      	cmp	r3, #0
60003ac0:	f040 80c2 	bne.w	60003c48 <__udivmoddi4+0x19c>
60003ac4:	4285      	cmp	r5, r0
60003ac6:	fab2 f282 	clz	r2, r2
60003aca:	d945      	bls.n	60003b58 <__udivmoddi4+0xac>
60003acc:	b14a      	cbz	r2, 60003ae2 <__udivmoddi4+0x36>
60003ace:	f1c2 0320 	rsb	r3, r2, #32
60003ad2:	fa00 fc02 	lsl.w	ip, r0, r2
60003ad6:	fa2e f303 	lsr.w	r3, lr, r3
60003ada:	4095      	lsls	r5, r2
60003adc:	ea43 0c0c 	orr.w	ip, r3, ip
60003ae0:	4094      	lsls	r4, r2
60003ae2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
60003ae6:	b2a8      	uxth	r0, r5
60003ae8:	fbbc f8fe 	udiv	r8, ip, lr
60003aec:	0c23      	lsrs	r3, r4, #16
60003aee:	fb0e cc18 	mls	ip, lr, r8, ip
60003af2:	fb08 f900 	mul.w	r9, r8, r0
60003af6:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
60003afa:	4599      	cmp	r9, r3
60003afc:	d928      	bls.n	60003b50 <__udivmoddi4+0xa4>
60003afe:	18eb      	adds	r3, r5, r3
60003b00:	f108 37ff 	add.w	r7, r8, #4294967295	; 0xffffffff
60003b04:	d204      	bcs.n	60003b10 <__udivmoddi4+0x64>
60003b06:	4599      	cmp	r9, r3
60003b08:	d902      	bls.n	60003b10 <__udivmoddi4+0x64>
60003b0a:	f1a8 0702 	sub.w	r7, r8, #2
60003b0e:	442b      	add	r3, r5
60003b10:	eba3 0309 	sub.w	r3, r3, r9
60003b14:	b2a4      	uxth	r4, r4
60003b16:	fbb3 fcfe 	udiv	ip, r3, lr
60003b1a:	fb0e 331c 	mls	r3, lr, ip, r3
60003b1e:	fb0c f000 	mul.w	r0, ip, r0
60003b22:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
60003b26:	42a0      	cmp	r0, r4
60003b28:	d914      	bls.n	60003b54 <__udivmoddi4+0xa8>
60003b2a:	192c      	adds	r4, r5, r4
60003b2c:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
60003b30:	d204      	bcs.n	60003b3c <__udivmoddi4+0x90>
60003b32:	42a0      	cmp	r0, r4
60003b34:	d902      	bls.n	60003b3c <__udivmoddi4+0x90>
60003b36:	f1ac 0302 	sub.w	r3, ip, #2
60003b3a:	442c      	add	r4, r5
60003b3c:	1a24      	subs	r4, r4, r0
60003b3e:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
60003b42:	b11e      	cbz	r6, 60003b4c <__udivmoddi4+0xa0>
60003b44:	40d4      	lsrs	r4, r2
60003b46:	2300      	movs	r3, #0
60003b48:	6034      	str	r4, [r6, #0]
60003b4a:	6073      	str	r3, [r6, #4]
60003b4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
60003b50:	4647      	mov	r7, r8
60003b52:	e7dd      	b.n	60003b10 <__udivmoddi4+0x64>
60003b54:	4663      	mov	r3, ip
60003b56:	e7f1      	b.n	60003b3c <__udivmoddi4+0x90>
60003b58:	bb92      	cbnz	r2, 60003bc0 <__udivmoddi4+0x114>
60003b5a:	1b43      	subs	r3, r0, r5
60003b5c:	2101      	movs	r1, #1
60003b5e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
60003b62:	b2af      	uxth	r7, r5
60003b64:	fbb3 fcfe 	udiv	ip, r3, lr
60003b68:	0c20      	lsrs	r0, r4, #16
60003b6a:	fb0e 331c 	mls	r3, lr, ip, r3
60003b6e:	fb0c f807 	mul.w	r8, ip, r7
60003b72:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
60003b76:	4598      	cmp	r8, r3
60003b78:	d962      	bls.n	60003c40 <__udivmoddi4+0x194>
60003b7a:	18eb      	adds	r3, r5, r3
60003b7c:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
60003b80:	d204      	bcs.n	60003b8c <__udivmoddi4+0xe0>
60003b82:	4598      	cmp	r8, r3
60003b84:	d902      	bls.n	60003b8c <__udivmoddi4+0xe0>
60003b86:	f1ac 0002 	sub.w	r0, ip, #2
60003b8a:	442b      	add	r3, r5
60003b8c:	eba3 0308 	sub.w	r3, r3, r8
60003b90:	b2a4      	uxth	r4, r4
60003b92:	fbb3 fcfe 	udiv	ip, r3, lr
60003b96:	fb0e 331c 	mls	r3, lr, ip, r3
60003b9a:	fb0c f707 	mul.w	r7, ip, r7
60003b9e:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
60003ba2:	42a7      	cmp	r7, r4
60003ba4:	d94e      	bls.n	60003c44 <__udivmoddi4+0x198>
60003ba6:	192c      	adds	r4, r5, r4
60003ba8:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
60003bac:	d204      	bcs.n	60003bb8 <__udivmoddi4+0x10c>
60003bae:	42a7      	cmp	r7, r4
60003bb0:	d902      	bls.n	60003bb8 <__udivmoddi4+0x10c>
60003bb2:	f1ac 0302 	sub.w	r3, ip, #2
60003bb6:	442c      	add	r4, r5
60003bb8:	1be4      	subs	r4, r4, r7
60003bba:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
60003bbe:	e7c0      	b.n	60003b42 <__udivmoddi4+0x96>
60003bc0:	f1c2 0320 	rsb	r3, r2, #32
60003bc4:	fa20 f103 	lsr.w	r1, r0, r3
60003bc8:	4095      	lsls	r5, r2
60003bca:	4090      	lsls	r0, r2
60003bcc:	fa2e f303 	lsr.w	r3, lr, r3
60003bd0:	4303      	orrs	r3, r0
60003bd2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
60003bd6:	b2af      	uxth	r7, r5
60003bd8:	fbb1 fcfe 	udiv	ip, r1, lr
60003bdc:	fb0e 101c 	mls	r0, lr, ip, r1
60003be0:	0c19      	lsrs	r1, r3, #16
60003be2:	fb0c f807 	mul.w	r8, ip, r7
60003be6:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
60003bea:	4588      	cmp	r8, r1
60003bec:	fa04 f402 	lsl.w	r4, r4, r2
60003bf0:	d922      	bls.n	60003c38 <__udivmoddi4+0x18c>
60003bf2:	1869      	adds	r1, r5, r1
60003bf4:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
60003bf8:	d204      	bcs.n	60003c04 <__udivmoddi4+0x158>
60003bfa:	4588      	cmp	r8, r1
60003bfc:	d902      	bls.n	60003c04 <__udivmoddi4+0x158>
60003bfe:	f1ac 0002 	sub.w	r0, ip, #2
60003c02:	4429      	add	r1, r5
60003c04:	eba1 0108 	sub.w	r1, r1, r8
60003c08:	b29b      	uxth	r3, r3
60003c0a:	fbb1 fcfe 	udiv	ip, r1, lr
60003c0e:	fb0e 111c 	mls	r1, lr, ip, r1
60003c12:	fb0c f707 	mul.w	r7, ip, r7
60003c16:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
60003c1a:	429f      	cmp	r7, r3
60003c1c:	d90e      	bls.n	60003c3c <__udivmoddi4+0x190>
60003c1e:	18eb      	adds	r3, r5, r3
60003c20:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
60003c24:	d204      	bcs.n	60003c30 <__udivmoddi4+0x184>
60003c26:	429f      	cmp	r7, r3
60003c28:	d902      	bls.n	60003c30 <__udivmoddi4+0x184>
60003c2a:	f1ac 0102 	sub.w	r1, ip, #2
60003c2e:	442b      	add	r3, r5
60003c30:	1bdb      	subs	r3, r3, r7
60003c32:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
60003c36:	e792      	b.n	60003b5e <__udivmoddi4+0xb2>
60003c38:	4660      	mov	r0, ip
60003c3a:	e7e3      	b.n	60003c04 <__udivmoddi4+0x158>
60003c3c:	4661      	mov	r1, ip
60003c3e:	e7f7      	b.n	60003c30 <__udivmoddi4+0x184>
60003c40:	4660      	mov	r0, ip
60003c42:	e7a3      	b.n	60003b8c <__udivmoddi4+0xe0>
60003c44:	4663      	mov	r3, ip
60003c46:	e7b7      	b.n	60003bb8 <__udivmoddi4+0x10c>
60003c48:	4283      	cmp	r3, r0
60003c4a:	d906      	bls.n	60003c5a <__udivmoddi4+0x1ae>
60003c4c:	b916      	cbnz	r6, 60003c54 <__udivmoddi4+0x1a8>
60003c4e:	2100      	movs	r1, #0
60003c50:	4608      	mov	r0, r1
60003c52:	e77b      	b.n	60003b4c <__udivmoddi4+0xa0>
60003c54:	e9c6 e000 	strd	lr, r0, [r6]
60003c58:	e7f9      	b.n	60003c4e <__udivmoddi4+0x1a2>
60003c5a:	fab3 f783 	clz	r7, r3
60003c5e:	b98f      	cbnz	r7, 60003c84 <__udivmoddi4+0x1d8>
60003c60:	4283      	cmp	r3, r0
60003c62:	d301      	bcc.n	60003c68 <__udivmoddi4+0x1bc>
60003c64:	4572      	cmp	r2, lr
60003c66:	d808      	bhi.n	60003c7a <__udivmoddi4+0x1ce>
60003c68:	ebbe 0402 	subs.w	r4, lr, r2
60003c6c:	eb60 0303 	sbc.w	r3, r0, r3
60003c70:	2001      	movs	r0, #1
60003c72:	469c      	mov	ip, r3
60003c74:	b91e      	cbnz	r6, 60003c7e <__udivmoddi4+0x1d2>
60003c76:	2100      	movs	r1, #0
60003c78:	e768      	b.n	60003b4c <__udivmoddi4+0xa0>
60003c7a:	4638      	mov	r0, r7
60003c7c:	e7fa      	b.n	60003c74 <__udivmoddi4+0x1c8>
60003c7e:	e9c6 4c00 	strd	r4, ip, [r6]
60003c82:	e7f8      	b.n	60003c76 <__udivmoddi4+0x1ca>
60003c84:	f1c7 0c20 	rsb	ip, r7, #32
60003c88:	40bb      	lsls	r3, r7
60003c8a:	fa22 f40c 	lsr.w	r4, r2, ip
60003c8e:	431c      	orrs	r4, r3
60003c90:	fa2e f10c 	lsr.w	r1, lr, ip
60003c94:	fa20 f30c 	lsr.w	r3, r0, ip
60003c98:	40b8      	lsls	r0, r7
60003c9a:	4301      	orrs	r1, r0
60003c9c:	ea4f 4914 	mov.w	r9, r4, lsr #16
60003ca0:	fa0e f507 	lsl.w	r5, lr, r7
60003ca4:	fbb3 f8f9 	udiv	r8, r3, r9
60003ca8:	fa1f fe84 	uxth.w	lr, r4
60003cac:	fb09 3018 	mls	r0, r9, r8, r3
60003cb0:	0c0b      	lsrs	r3, r1, #16
60003cb2:	fb08 fa0e 	mul.w	sl, r8, lr
60003cb6:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
60003cba:	459a      	cmp	sl, r3
60003cbc:	fa02 f207 	lsl.w	r2, r2, r7
60003cc0:	d940      	bls.n	60003d44 <__udivmoddi4+0x298>
60003cc2:	18e3      	adds	r3, r4, r3
60003cc4:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
60003cc8:	d204      	bcs.n	60003cd4 <__udivmoddi4+0x228>
60003cca:	459a      	cmp	sl, r3
60003ccc:	d902      	bls.n	60003cd4 <__udivmoddi4+0x228>
60003cce:	f1a8 0002 	sub.w	r0, r8, #2
60003cd2:	4423      	add	r3, r4
60003cd4:	eba3 030a 	sub.w	r3, r3, sl
60003cd8:	b289      	uxth	r1, r1
60003cda:	fbb3 f8f9 	udiv	r8, r3, r9
60003cde:	fb09 3318 	mls	r3, r9, r8, r3
60003ce2:	fb08 fe0e 	mul.w	lr, r8, lr
60003ce6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
60003cea:	458e      	cmp	lr, r1
60003cec:	d92c      	bls.n	60003d48 <__udivmoddi4+0x29c>
60003cee:	1861      	adds	r1, r4, r1
60003cf0:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
60003cf4:	d204      	bcs.n	60003d00 <__udivmoddi4+0x254>
60003cf6:	458e      	cmp	lr, r1
60003cf8:	d902      	bls.n	60003d00 <__udivmoddi4+0x254>
60003cfa:	f1a8 0302 	sub.w	r3, r8, #2
60003cfe:	4421      	add	r1, r4
60003d00:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
60003d04:	fba0 9802 	umull	r9, r8, r0, r2
60003d08:	eba1 010e 	sub.w	r1, r1, lr
60003d0c:	4541      	cmp	r1, r8
60003d0e:	46ce      	mov	lr, r9
60003d10:	4643      	mov	r3, r8
60003d12:	d302      	bcc.n	60003d1a <__udivmoddi4+0x26e>
60003d14:	d106      	bne.n	60003d24 <__udivmoddi4+0x278>
60003d16:	454d      	cmp	r5, r9
60003d18:	d204      	bcs.n	60003d24 <__udivmoddi4+0x278>
60003d1a:	ebb9 0e02 	subs.w	lr, r9, r2
60003d1e:	eb68 0304 	sbc.w	r3, r8, r4
60003d22:	3801      	subs	r0, #1
60003d24:	2e00      	cmp	r6, #0
60003d26:	d0a6      	beq.n	60003c76 <__udivmoddi4+0x1ca>
60003d28:	ebb5 020e 	subs.w	r2, r5, lr
60003d2c:	eb61 0103 	sbc.w	r1, r1, r3
60003d30:	fa01 fc0c 	lsl.w	ip, r1, ip
60003d34:	fa22 f307 	lsr.w	r3, r2, r7
60003d38:	ea4c 0303 	orr.w	r3, ip, r3
60003d3c:	40f9      	lsrs	r1, r7
60003d3e:	e9c6 3100 	strd	r3, r1, [r6]
60003d42:	e798      	b.n	60003c76 <__udivmoddi4+0x1ca>
60003d44:	4640      	mov	r0, r8
60003d46:	e7c5      	b.n	60003cd4 <__udivmoddi4+0x228>
60003d48:	4643      	mov	r3, r8
60003d4a:	e7d9      	b.n	60003d00 <__udivmoddi4+0x254>
60003d4c:	0000      	movs	r0, r0
	...

60003d50 <LPSPI_MasterSetDelayTimes>:
 */
uint32_t LPSPI_MasterSetDelayTimes(LPSPI_Type *base,
                                   uint32_t delayTimeInNanoSec,
                                   lpspi_delay_type_t whichDelay,
                                   uint32_t srcClock_Hz)
{
60003d50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60003d54:	b085      	sub	sp, #20
60003d56:	4688      	mov	r8, r1
    uint32_t additionalScaler = 0;

    /*As the RM note, the LPSPI baud rate clock is itself divided by the PRESCALE setting, which can vary between
     * transfers.*/
    clockDividedPrescaler =
        srcClock_Hz / s_baudratePrescaler[(base->TCR & LPSPI_TCR_PRESCALE_MASK) >> LPSPI_TCR_PRESCALE_SHIFT];
60003d58:	4943      	ldr	r1, [pc, #268]	; (60003e68 <LPSPI_MasterSetDelayTimes+0x118>)
{
60003d5a:	9202      	str	r2, [sp, #8]
        srcClock_Hz / s_baudratePrescaler[(base->TCR & LPSPI_TCR_PRESCALE_MASK) >> LPSPI_TCR_PRESCALE_SHIFT];
60003d5c:	6e02      	ldr	r2, [r0, #96]	; 0x60
{
60003d5e:	9001      	str	r0, [sp, #4]
        srcClock_Hz / s_baudratePrescaler[(base->TCR & LPSPI_TCR_PRESCALE_MASK) >> LPSPI_TCR_PRESCALE_SHIFT];
60003d60:	f3c2 62c2 	ubfx	r2, r2, #27, #3
60003d64:	5c8a      	ldrb	r2, [r1, r2]
    clockDividedPrescaler =
60003d66:	fbb3 f6f2 	udiv	r6, r3, r2
    bestScaler = 0xFFU;

    /* Calculate the initial (min) delay and maximum possible delay based on the specific delay as
     * the delay divisors are slightly different based on which delay we are configuring.
     */
    if (whichDelay == kLPSPI_BetweenTransfer)
60003d6a:	9b02      	ldr	r3, [sp, #8]
         calculated values (uint64_t), we need to break up the calculation into several steps to ensure
         accurate calculated results
         */
        initialDelayNanoSec = 1000000000U;
        initialDelayNanoSec *= 2U;
        initialDelayNanoSec /= clockDividedPrescaler;
60003d6c:	4632      	mov	r2, r6
    if (whichDelay == kLPSPI_BetweenTransfer)
60003d6e:	2b03      	cmp	r3, #3
        initialDelayNanoSec /= clockDividedPrescaler;
60003d70:	f04f 0300 	mov.w	r3, #0
    if (whichDelay == kLPSPI_BetweenTransfer)
60003d74:	d13d      	bne.n	60003df2 <LPSPI_MasterSetDelayTimes+0xa2>
        /* Calculate the maximum delay */
        bestDelay = 1000000000U;
        bestDelay *= 257U; /* based on DBT+2, or 255 + 2 */
        bestDelay /= clockDividedPrescaler;

        additionalScaler = 1U;
60003d76:	2401      	movs	r4, #1
        initialDelayNanoSec /= clockDividedPrescaler;
60003d78:	a135      	add	r1, pc, #212	; (adr r1, 60003e50 <LPSPI_MasterSetDelayTimes+0x100>)
60003d7a:	e9d1 0100 	ldrd	r0, r1, [r1]
60003d7e:	f7ff fe7b 	bl	60003a78 <__aeabi_uldivmod>
        bestDelay /= clockDividedPrescaler;
60003d82:	4632      	mov	r2, r6
        initialDelayNanoSec /= clockDividedPrescaler;
60003d84:	4607      	mov	r7, r0
60003d86:	468a      	mov	sl, r1
        bestDelay /= clockDividedPrescaler;
60003d88:	2300      	movs	r3, #0
60003d8a:	a133      	add	r1, pc, #204	; (adr r1, 60003e58 <LPSPI_MasterSetDelayTimes+0x108>)
60003d8c:	e9d1 0100 	ldrd	r0, r1, [r1]
60003d90:	f7ff fe72 	bl	60003a78 <__aeabi_uldivmod>
60003d94:	4605      	mov	r5, r0

    /* If the initial, default delay is already greater than the desired delay, then
     * set the delay to their initial value (0) and return the delay. In other words,
     * there is no way to decrease the delay value further.
     */
    if (initialDelayNanoSec >= delayTimeInNanoSec)
60003d96:	4547      	cmp	r7, r8
60003d98:	f17a 0a00 	sbcs.w	sl, sl, #0
60003d9c:	d239      	bcs.n	60003e12 <LPSPI_MasterSetDelayTimes+0xc2>
    }

    /* If min_diff = 0, the exit for loop */
    for (scaler = 0U; scaler < 256U; scaler++)
    {
        if (min_diff == 0U)
60003d9e:	4b33      	ldr	r3, [pc, #204]	; (60003e6c <LPSPI_MasterSetDelayTimes+0x11c>)
60003da0:	3401      	adds	r4, #1
    min_diff = 0xFFFFFFFFU;
60003da2:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
    bestScaler = 0xFFU;
60003da6:	f04f 09ff 	mov.w	r9, #255	; 0xff
60003daa:	fba4 4a03 	umull	r4, sl, r4, r3
    for (scaler = 0U; scaler < 256U; scaler++)
60003dae:	2700      	movs	r7, #0
60003db0:	9303      	str	r3, [sp, #12]
        Due to large size of calculated values (uint64_t), we need to break up the
        calculation into several steps to ensure accurate calculated results
        */
        realDelay = 1000000000U;
        realDelay *= ((uint64_t)scaler + 1UL + (uint64_t)additionalScaler);
        realDelay /= clockDividedPrescaler;
60003db2:	4632      	mov	r2, r6
60003db4:	2300      	movs	r3, #0
60003db6:	4620      	mov	r0, r4
60003db8:	4651      	mov	r1, sl
60003dba:	f7ff fe5d 	bl	60003a78 <__aeabi_uldivmod>

        /* calculate the delay difference based on the conditional statement
         * that states that the calculated delay must not be less then the desired delay
         */
        if (realDelay >= delayTimeInNanoSec)
60003dbe:	4540      	cmp	r0, r8
        realDelay /= clockDividedPrescaler;
60003dc0:	4603      	mov	r3, r0
        if (realDelay >= delayTimeInNanoSec)
60003dc2:	f107 0201 	add.w	r2, r7, #1
60003dc6:	f171 0100 	sbcs.w	r1, r1, #0
60003dca:	d303      	bcc.n	60003dd4 <LPSPI_MasterSetDelayTimes+0x84>
        {
            diff = (uint32_t)(realDelay - (uint64_t)delayTimeInNanoSec);
60003dcc:	eba0 0008 	sub.w	r0, r0, r8
            if (min_diff > diff)
60003dd0:	4558      	cmp	r0, fp
60003dd2:	d32a      	bcc.n	60003e2a <LPSPI_MasterSetDelayTimes+0xda>
    for (scaler = 0U; scaler < 256U; scaler++)
60003dd4:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
60003dd8:	d024      	beq.n	60003e24 <LPSPI_MasterSetDelayTimes+0xd4>
        if (min_diff == 0U)
60003dda:	9b03      	ldr	r3, [sp, #12]
60003ddc:	4658      	mov	r0, fp
60003dde:	464f      	mov	r7, r9
60003de0:	18e4      	adds	r4, r4, r3
60003de2:	462b      	mov	r3, r5
60003de4:	f14a 0a00 	adc.w	sl, sl, #0
60003de8:	46b9      	mov	r9, r7
60003dea:	4683      	mov	fp, r0
60003dec:	4617      	mov	r7, r2
60003dee:	461d      	mov	r5, r3
60003df0:	e7df      	b.n	60003db2 <LPSPI_MasterSetDelayTimes+0x62>
        initialDelayNanoSec /= clockDividedPrescaler;
60003df2:	a11b      	add	r1, pc, #108	; (adr r1, 60003e60 <LPSPI_MasterSetDelayTimes+0x110>)
60003df4:	e9d1 0100 	ldrd	r0, r1, [r1]
60003df8:	f7ff fe3e 	bl	60003a78 <__aeabi_uldivmod>
        bestDelay /= clockDividedPrescaler;
60003dfc:	4632      	mov	r2, r6
        initialDelayNanoSec /= clockDividedPrescaler;
60003dfe:	4607      	mov	r7, r0
60003e00:	468a      	mov	sl, r1
        bestDelay /= clockDividedPrescaler;
60003e02:	2300      	movs	r3, #0
60003e04:	481a      	ldr	r0, [pc, #104]	; (60003e70 <LPSPI_MasterSetDelayTimes+0x120>)
60003e06:	213b      	movs	r1, #59	; 0x3b
        additionalScaler = 0U;
60003e08:	2400      	movs	r4, #0
        bestDelay /= clockDividedPrescaler;
60003e0a:	f7ff fe35 	bl	60003a78 <__aeabi_uldivmod>
60003e0e:	4605      	mov	r5, r0
        additionalScaler = 0U;
60003e10:	e7c1      	b.n	60003d96 <LPSPI_MasterSetDelayTimes+0x46>
        LPSPI_MasterSetDelayScaler(base, 0, whichDelay);
60003e12:	9801      	ldr	r0, [sp, #4]
60003e14:	2100      	movs	r1, #0
60003e16:	9a02      	ldr	r2, [sp, #8]
60003e18:	f004 fa78 	bl	6000830c <LPSPI_MasterSetDelayScaler>
        return (uint32_t)initialDelayNanoSec;
60003e1c:	4638      	mov	r0, r7
    /* write the best scaler value for the delay */
    LPSPI_MasterSetDelayScaler(base, bestScaler, whichDelay);

    /* return the actual calculated delay value (in ns) */
    return (uint32_t)bestDelay;
}
60003e1e:	b005      	add	sp, #20
60003e20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (scaler = 0U; scaler < 256U; scaler++)
60003e24:	464f      	mov	r7, r9
60003e26:	462b      	mov	r3, r5
60003e28:	e008      	b.n	60003e3c <LPSPI_MasterSetDelayTimes+0xec>
60003e2a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
60003e2e:	d005      	beq.n	60003e3c <LPSPI_MasterSetDelayTimes+0xec>
        if (min_diff == 0U)
60003e30:	9903      	ldr	r1, [sp, #12]
60003e32:	1864      	adds	r4, r4, r1
60003e34:	f14a 0a00 	adc.w	sl, sl, #0
60003e38:	2800      	cmp	r0, #0
60003e3a:	d1d5      	bne.n	60003de8 <LPSPI_MasterSetDelayTimes+0x98>
    LPSPI_MasterSetDelayScaler(base, bestScaler, whichDelay);
60003e3c:	9801      	ldr	r0, [sp, #4]
60003e3e:	4639      	mov	r1, r7
60003e40:	9a02      	ldr	r2, [sp, #8]
60003e42:	9303      	str	r3, [sp, #12]
60003e44:	f004 fa62 	bl	6000830c <LPSPI_MasterSetDelayScaler>
    return (uint32_t)bestDelay;
60003e48:	9b03      	ldr	r3, [sp, #12]
60003e4a:	4618      	mov	r0, r3
60003e4c:	e7e7      	b.n	60003e1e <LPSPI_MasterSetDelayTimes+0xce>
60003e4e:	bf00      	nop
60003e50:	77359400 	.word	0x77359400
60003e54:	00000000 	.word	0x00000000
60003e58:	d664ca00 	.word	0xd664ca00
60003e5c:	0000003b 	.word	0x0000003b
60003e60:	3b9aca00 	.word	0x3b9aca00
60003e64:	00000000 	.word	0x00000000
60003e68:	6000dda6 	.word	0x6000dda6
60003e6c:	3b9aca00 	.word	0x3b9aca00
60003e70:	9aca0000 	.word	0x9aca0000

60003e74 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
60003e74:	4b01      	ldr	r3, [pc, #4]	; (60003e7c <char_out+0x8>)
60003e76:	681b      	ldr	r3, [r3, #0]
60003e78:	4718      	bx	r3
60003e7a:	bf00      	nop
60003e7c:	80000800 	.word	0x80000800

60003e80 <__printk_hook_install>:
	_char_out = fn;
60003e80:	4b01      	ldr	r3, [pc, #4]	; (60003e88 <__printk_hook_install+0x8>)
60003e82:	6018      	str	r0, [r3, #0]
}
60003e84:	4770      	bx	lr
60003e86:	bf00      	nop
60003e88:	80000800 	.word	0x80000800

60003e8c <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
60003e8c:	b507      	push	{r0, r1, r2, lr}
60003e8e:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
60003e90:	2100      	movs	r1, #0
60003e92:	4602      	mov	r2, r0
60003e94:	4803      	ldr	r0, [pc, #12]	; (60003ea4 <vprintk+0x18>)
60003e96:	9100      	str	r1, [sp, #0]
60003e98:	f000 f806 	bl	60003ea8 <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
60003e9c:	b003      	add	sp, #12
60003e9e:	f85d fb04 	ldr.w	pc, [sp], #4
60003ea2:	bf00      	nop
60003ea4:	60003e75 	.word	0x60003e75

60003ea8 <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
60003ea8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60003eac:	4681      	mov	r9, r0
60003eae:	b095      	sub	sp, #84	; 0x54
60003eb0:	468b      	mov	fp, r1
60003eb2:	4617      	mov	r7, r2
60003eb4:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
60003eb6:	2500      	movs	r5, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
60003eb8:	7838      	ldrb	r0, [r7, #0]
60003eba:	b908      	cbnz	r0, 60003ec0 <z_cbvprintf_impl+0x18>
			OUTC(' ');
			--width;
		}
	}

	return count;
60003ebc:	4628      	mov	r0, r5
60003ebe:	e358      	b.n	60004572 <z_cbvprintf_impl+0x6ca>
			OUTC(*fp++);
60003ec0:	1c7b      	adds	r3, r7, #1
		if (*fp != '%') {
60003ec2:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
60003ec4:	9303      	str	r3, [sp, #12]
		if (*fp != '%') {
60003ec6:	d006      	beq.n	60003ed6 <z_cbvprintf_impl+0x2e>
			OUTC('%');
60003ec8:	4659      	mov	r1, fp
60003eca:	47c8      	blx	r9
60003ecc:	2800      	cmp	r0, #0
60003ece:	f2c0 8350 	blt.w	60004572 <z_cbvprintf_impl+0x6ca>
60003ed2:	3501      	adds	r5, #1
		if (bps == NULL) {
60003ed4:	e1fb      	b.n	600042ce <z_cbvprintf_impl+0x426>
		} state = {
60003ed6:	2218      	movs	r2, #24
60003ed8:	2100      	movs	r1, #0
60003eda:	a80e      	add	r0, sp, #56	; 0x38
60003edc:	f006 fe57 	bl	6000ab8e <memset>
	if (*sp == '%') {
60003ee0:	787b      	ldrb	r3, [r7, #1]
60003ee2:	2b25      	cmp	r3, #37	; 0x25
60003ee4:	d07d      	beq.n	60003fe2 <z_cbvprintf_impl+0x13a>
60003ee6:	2300      	movs	r3, #0
60003ee8:	1c78      	adds	r0, r7, #1
60003eea:	4698      	mov	r8, r3
60003eec:	469e      	mov	lr, r3
60003eee:	469c      	mov	ip, r3
60003ef0:	461e      	mov	r6, r3
60003ef2:	4601      	mov	r1, r0
		switch (*sp) {
60003ef4:	f810 2b01 	ldrb.w	r2, [r0], #1
60003ef8:	2a2b      	cmp	r2, #43	; 0x2b
60003efa:	f000 80a1 	beq.w	60004040 <z_cbvprintf_impl+0x198>
60003efe:	f200 8098 	bhi.w	60004032 <z_cbvprintf_impl+0x18a>
60003f02:	2a20      	cmp	r2, #32
60003f04:	f000 809f 	beq.w	60004046 <z_cbvprintf_impl+0x19e>
60003f08:	2a23      	cmp	r2, #35	; 0x23
60003f0a:	f000 809f 	beq.w	6000404c <z_cbvprintf_impl+0x1a4>
60003f0e:	b12b      	cbz	r3, 60003f1c <z_cbvprintf_impl+0x74>
60003f10:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
60003f14:	f043 0340 	orr.w	r3, r3, #64	; 0x40
60003f18:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
60003f1c:	f1b8 0f00 	cmp.w	r8, #0
60003f20:	d005      	beq.n	60003f2e <z_cbvprintf_impl+0x86>
60003f22:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
60003f26:	f043 0320 	orr.w	r3, r3, #32
60003f2a:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
60003f2e:	f1be 0f00 	cmp.w	lr, #0
60003f32:	d005      	beq.n	60003f40 <z_cbvprintf_impl+0x98>
60003f34:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
60003f38:	f043 0310 	orr.w	r3, r3, #16
60003f3c:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
60003f40:	f1bc 0f00 	cmp.w	ip, #0
60003f44:	d005      	beq.n	60003f52 <z_cbvprintf_impl+0xaa>
60003f46:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
60003f4a:	f043 0308 	orr.w	r3, r3, #8
60003f4e:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
60003f52:	b12e      	cbz	r6, 60003f60 <z_cbvprintf_impl+0xb8>
60003f54:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
60003f58:	f043 0304 	orr.w	r3, r3, #4
60003f5c:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (conv->flag_zero && conv->flag_dash) {
60003f60:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
60003f64:	f003 0044 	and.w	r0, r3, #68	; 0x44
60003f68:	2844      	cmp	r0, #68	; 0x44
60003f6a:	d103      	bne.n	60003f74 <z_cbvprintf_impl+0xcc>
		conv->flag_zero = false;
60003f6c:	f36f 1386 	bfc	r3, #6, #1
60003f70:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	conv->width_present = true;
60003f74:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
60003f78:	2a2a      	cmp	r2, #42	; 0x2a
	conv->width_present = true;
60003f7a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
60003f7e:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
60003f82:	d17f      	bne.n	60004084 <z_cbvprintf_impl+0x1dc>
		conv->width_star = true;
60003f84:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
60003f88:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
60003f8a:	f042 0201 	orr.w	r2, r2, #1
60003f8e:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	conv->prec_present = (*sp == '.');
60003f92:	781a      	ldrb	r2, [r3, #0]
60003f94:	2a2e      	cmp	r2, #46	; 0x2e
60003f96:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
60003f9a:	bf0c      	ite	eq
60003f9c:	2101      	moveq	r1, #1
60003f9e:	2100      	movne	r1, #0
60003fa0:	f361 0241 	bfi	r2, r1, #1, #1
60003fa4:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	if (!conv->prec_present) {
60003fa8:	d178      	bne.n	6000409c <z_cbvprintf_impl+0x1f4>
	if (*sp == '*') {
60003faa:	785a      	ldrb	r2, [r3, #1]
60003fac:	2a2a      	cmp	r2, #42	; 0x2a
60003fae:	d06e      	beq.n	6000408e <z_cbvprintf_impl+0x1e6>
	++sp;
60003fb0:	3301      	adds	r3, #1
	size_t val = 0;
60003fb2:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
60003fb4:	f04f 0c0a 	mov.w	ip, #10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
60003fb8:	4619      	mov	r1, r3
60003fba:	f811 0b01 	ldrb.w	r0, [r1], #1
60003fbe:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
60003fc2:	2e09      	cmp	r6, #9
60003fc4:	f240 8095 	bls.w	600040f2 <z_cbvprintf_impl+0x24a>
	conv->unsupported |= ((conv->prec_value < 0)
60003fc8:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
	conv->prec_value = prec;
60003fcc:	9212      	str	r2, [sp, #72]	; 0x48
	conv->unsupported |= ((conv->prec_value < 0)
60003fce:	f3c1 0040 	ubfx	r0, r1, #1, #1
60003fd2:	ea40 70d2 	orr.w	r0, r0, r2, lsr #31
60003fd6:	460a      	mov	r2, r1
60003fd8:	f360 0241 	bfi	r2, r0, #1, #1
60003fdc:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
60003fe0:	e05c      	b.n	6000409c <z_cbvprintf_impl+0x1f4>
		conv->specifier = *sp++;
60003fe2:	1cba      	adds	r2, r7, #2
60003fe4:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
60003fe8:	9203      	str	r2, [sp, #12]
		if (conv->width_star) {
60003fea:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
60003fee:	07da      	lsls	r2, r3, #31
60003ff0:	f140 812e 	bpl.w	60004250 <z_cbvprintf_impl+0x3a8>
			width = va_arg(ap, int);
60003ff4:	f854 8b04 	ldr.w	r8, [r4], #4
			if (width < 0) {
60003ff8:	f1b8 0f00 	cmp.w	r8, #0
60003ffc:	da07      	bge.n	6000400e <z_cbvprintf_impl+0x166>
				conv->flag_dash = true;
60003ffe:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				width = -width;
60004002:	f1c8 0800 	rsb	r8, r8, #0
				conv->flag_dash = true;
60004006:	f042 0204 	orr.w	r2, r2, #4
6000400a:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
		if (conv->prec_star) {
6000400e:	075e      	lsls	r6, r3, #29
60004010:	f140 8127 	bpl.w	60004262 <z_cbvprintf_impl+0x3ba>
			int arg = va_arg(ap, int);
60004014:	f854 ab04 	ldr.w	sl, [r4], #4
			if (arg < 0) {
60004018:	f1ba 0f00 	cmp.w	sl, #0
6000401c:	f280 8126 	bge.w	6000426c <z_cbvprintf_impl+0x3c4>
				conv->prec_present = false;
60004020:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
60004024:	f36f 0341 	bfc	r3, #1, #1
60004028:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
		int precision = -1;
6000402c:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
60004030:	e11c      	b.n	6000426c <z_cbvprintf_impl+0x3c4>
		switch (*sp) {
60004032:	2a2d      	cmp	r2, #45	; 0x2d
60004034:	d00d      	beq.n	60004052 <z_cbvprintf_impl+0x1aa>
60004036:	2a30      	cmp	r2, #48	; 0x30
60004038:	f47f af69 	bne.w	60003f0e <z_cbvprintf_impl+0x66>
6000403c:	2301      	movs	r3, #1
	} while (loop);
6000403e:	e758      	b.n	60003ef2 <z_cbvprintf_impl+0x4a>
		switch (*sp) {
60004040:	f04f 0c01 	mov.w	ip, #1
60004044:	e755      	b.n	60003ef2 <z_cbvprintf_impl+0x4a>
60004046:	f04f 0e01 	mov.w	lr, #1
6000404a:	e752      	b.n	60003ef2 <z_cbvprintf_impl+0x4a>
6000404c:	f04f 0801 	mov.w	r8, #1
60004050:	e74f      	b.n	60003ef2 <z_cbvprintf_impl+0x4a>
60004052:	2601      	movs	r6, #1
60004054:	e74d      	b.n	60003ef2 <z_cbvprintf_impl+0x4a>
		val = 10U * val + *sp++ - '0';
60004056:	fb0e 6202 	mla	r2, lr, r2, r6
6000405a:	4603      	mov	r3, r0
6000405c:	3a30      	subs	r2, #48	; 0x30
6000405e:	4618      	mov	r0, r3
60004060:	f810 6b01 	ldrb.w	r6, [r0], #1
60004064:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
60004068:	f1bc 0f09 	cmp.w	ip, #9
6000406c:	d9f3      	bls.n	60004056 <z_cbvprintf_impl+0x1ae>
	if (sp != wp) {
6000406e:	4299      	cmp	r1, r3
60004070:	d08f      	beq.n	60003f92 <z_cbvprintf_impl+0xea>
		conv->unsupported |= ((conv->width_value < 0)
60004072:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
		conv->width_value = width;
60004076:	9211      	str	r2, [sp, #68]	; 0x44
				      || (width != (size_t)conv->width_value));
60004078:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
6000407a:	f362 0141 	bfi	r1, r2, #1, #1
6000407e:	f88d 1040 	strb.w	r1, [sp, #64]	; 0x40
60004082:	e786      	b.n	60003f92 <z_cbvprintf_impl+0xea>
60004084:	460b      	mov	r3, r1
	size_t val = 0;
60004086:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
60004088:	f04f 0e0a 	mov.w	lr, #10
6000408c:	e7e7      	b.n	6000405e <z_cbvprintf_impl+0x1b6>
		conv->prec_star = true;
6000408e:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
60004092:	3302      	adds	r3, #2
		conv->prec_star = true;
60004094:	f042 0204 	orr.w	r2, r2, #4
60004098:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	switch (*sp) {
6000409c:	781a      	ldrb	r2, [r3, #0]
6000409e:	2a6c      	cmp	r2, #108	; 0x6c
600040a0:	d047      	beq.n	60004132 <z_cbvprintf_impl+0x28a>
600040a2:	d82b      	bhi.n	600040fc <z_cbvprintf_impl+0x254>
600040a4:	2a68      	cmp	r2, #104	; 0x68
600040a6:	d031      	beq.n	6000410c <z_cbvprintf_impl+0x264>
600040a8:	2a6a      	cmp	r2, #106	; 0x6a
600040aa:	d04b      	beq.n	60004144 <z_cbvprintf_impl+0x29c>
600040ac:	2a4c      	cmp	r2, #76	; 0x4c
600040ae:	d051      	beq.n	60004154 <z_cbvprintf_impl+0x2ac>
	conv->specifier = *sp++;
600040b0:	461a      	mov	r2, r3
600040b2:	f812 3b01 	ldrb.w	r3, [r2], #1
	switch (conv->specifier) {
600040b6:	2b78      	cmp	r3, #120	; 0x78
	conv->specifier = *sp++;
600040b8:	9203      	str	r2, [sp, #12]
600040ba:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->length_mod == LENGTH_UPPER_L) {
600040be:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
	switch (conv->specifier) {
600040c2:	f200 80be 	bhi.w	60004242 <z_cbvprintf_impl+0x39a>
600040c6:	2b6d      	cmp	r3, #109	; 0x6d
600040c8:	d851      	bhi.n	6000416e <z_cbvprintf_impl+0x2c6>
600040ca:	2b69      	cmp	r3, #105	; 0x69
600040cc:	f200 80b9 	bhi.w	60004242 <z_cbvprintf_impl+0x39a>
600040d0:	2b57      	cmp	r3, #87	; 0x57
600040d2:	d867      	bhi.n	600041a4 <z_cbvprintf_impl+0x2fc>
600040d4:	2b41      	cmp	r3, #65	; 0x41
600040d6:	d003      	beq.n	600040e0 <z_cbvprintf_impl+0x238>
600040d8:	3b45      	subs	r3, #69	; 0x45
600040da:	2b02      	cmp	r3, #2
600040dc:	f200 80b1 	bhi.w	60004242 <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_FP;
600040e0:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
600040e4:	2204      	movs	r2, #4
600040e6:	f362 0302 	bfi	r3, r2, #0, #3
600040ea:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
			unsupported = true;
600040ee:	2301      	movs	r3, #1
			break;
600040f0:	e073      	b.n	600041da <z_cbvprintf_impl+0x332>
		val = 10U * val + *sp++ - '0';
600040f2:	fb0c 0202 	mla	r2, ip, r2, r0
600040f6:	460b      	mov	r3, r1
600040f8:	3a30      	subs	r2, #48	; 0x30
600040fa:	e75d      	b.n	60003fb8 <z_cbvprintf_impl+0x110>
	switch (*sp) {
600040fc:	2a74      	cmp	r2, #116	; 0x74
600040fe:	d025      	beq.n	6000414c <z_cbvprintf_impl+0x2a4>
60004100:	2a7a      	cmp	r2, #122	; 0x7a
60004102:	d1d5      	bne.n	600040b0 <z_cbvprintf_impl+0x208>
		conv->length_mod = LENGTH_Z;
60004104:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
60004108:	2106      	movs	r1, #6
6000410a:	e00c      	b.n	60004126 <z_cbvprintf_impl+0x27e>
		if (*++sp == 'h') {
6000410c:	785a      	ldrb	r2, [r3, #1]
6000410e:	2a68      	cmp	r2, #104	; 0x68
60004110:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
60004114:	d106      	bne.n	60004124 <z_cbvprintf_impl+0x27c>
			conv->length_mod = LENGTH_HH;
60004116:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
60004118:	f361 02c6 	bfi	r2, r1, #3, #4
			++sp;
6000411c:	3302      	adds	r3, #2
			conv->length_mod = LENGTH_LL;
6000411e:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
			++sp;
60004122:	e7c5      	b.n	600040b0 <z_cbvprintf_impl+0x208>
			conv->length_mod = LENGTH_H;
60004124:	2102      	movs	r1, #2
60004126:	f361 02c6 	bfi	r2, r1, #3, #4
6000412a:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		if (*++sp == 'h') {
6000412e:	3301      	adds	r3, #1
60004130:	e7be      	b.n	600040b0 <z_cbvprintf_impl+0x208>
		if (*++sp == 'l') {
60004132:	785a      	ldrb	r2, [r3, #1]
60004134:	2a6c      	cmp	r2, #108	; 0x6c
60004136:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
6000413a:	d101      	bne.n	60004140 <z_cbvprintf_impl+0x298>
			conv->length_mod = LENGTH_LL;
6000413c:	2104      	movs	r1, #4
6000413e:	e7eb      	b.n	60004118 <z_cbvprintf_impl+0x270>
			conv->length_mod = LENGTH_L;
60004140:	2103      	movs	r1, #3
60004142:	e7f0      	b.n	60004126 <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_J;
60004144:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
60004148:	2105      	movs	r1, #5
6000414a:	e7ec      	b.n	60004126 <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_T;
6000414c:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
60004150:	2107      	movs	r1, #7
60004152:	e7e8      	b.n	60004126 <z_cbvprintf_impl+0x27e>
		conv->unsupported = true;
60004154:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
60004158:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
6000415c:	f022 0202 	bic.w	r2, r2, #2
60004160:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
60004164:	f042 0202 	orr.w	r2, r2, #2
60004168:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
		break;
6000416c:	e7df      	b.n	6000412e <z_cbvprintf_impl+0x286>
	switch (conv->specifier) {
6000416e:	3b6e      	subs	r3, #110	; 0x6e
60004170:	b2d9      	uxtb	r1, r3
60004172:	2301      	movs	r3, #1
60004174:	408b      	lsls	r3, r1
60004176:	f240 4182 	movw	r1, #1154	; 0x482
6000417a:	420b      	tst	r3, r1
6000417c:	d137      	bne.n	600041ee <z_cbvprintf_impl+0x346>
6000417e:	f013 0f24 	tst.w	r3, #36	; 0x24
60004182:	d151      	bne.n	60004228 <z_cbvprintf_impl+0x380>
60004184:	07d8      	lsls	r0, r3, #31
60004186:	d55c      	bpl.n	60004242 <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_PTR;
60004188:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
6000418c:	2103      	movs	r1, #3
6000418e:	f361 0302 	bfi	r3, r1, #0, #3
60004192:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
60004196:	f002 0378 	and.w	r3, r2, #120	; 0x78
6000419a:	f1a3 0140 	sub.w	r1, r3, #64	; 0x40
6000419e:	424b      	negs	r3, r1
600041a0:	414b      	adcs	r3, r1
600041a2:	e01a      	b.n	600041da <z_cbvprintf_impl+0x332>
	switch (conv->specifier) {
600041a4:	f1a3 0158 	sub.w	r1, r3, #88	; 0x58
600041a8:	2001      	movs	r0, #1
600041aa:	b2c9      	uxtb	r1, r1
600041ac:	fa00 f101 	lsl.w	r1, r0, r1
600041b0:	f411 4f62 	tst.w	r1, #57856	; 0xe200
600041b4:	d194      	bne.n	600040e0 <z_cbvprintf_impl+0x238>
600041b6:	f640 0601 	movw	r6, #2049	; 0x801
600041ba:	4231      	tst	r1, r6
600041bc:	d11d      	bne.n	600041fa <z_cbvprintf_impl+0x352>
600041be:	f411 3f04 	tst.w	r1, #135168	; 0x21000
600041c2:	d03e      	beq.n	60004242 <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_SINT;
600041c4:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
600041c8:	f360 0302 	bfi	r3, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
600041cc:	f002 0278 	and.w	r2, r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_SINT;
600041d0:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
600041d4:	2a40      	cmp	r2, #64	; 0x40
600041d6:	d034      	beq.n	60004242 <z_cbvprintf_impl+0x39a>
	bool unsupported = false;
600041d8:	2300      	movs	r3, #0
	conv->unsupported |= unsupported;
600041da:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
600041de:	f3c2 0140 	ubfx	r1, r2, #1, #1
600041e2:	430b      	orrs	r3, r1
600041e4:	f363 0241 	bfi	r2, r3, #1, #1
600041e8:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
600041ec:	e6fd      	b.n	60003fea <z_cbvprintf_impl+0x142>
		conv->specifier_cat = SPECIFIER_UINT;
600041ee:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
600041f2:	2102      	movs	r1, #2
600041f4:	f361 0302 	bfi	r3, r1, #0, #3
600041f8:	e7e8      	b.n	600041cc <z_cbvprintf_impl+0x324>
600041fa:	f89d 1042 	ldrb.w	r1, [sp, #66]	; 0x42
600041fe:	2002      	movs	r0, #2
		if (conv->length_mod == LENGTH_UPPER_L) {
60004200:	f002 0278 	and.w	r2, r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
60004204:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
60004208:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
6000420a:	f88d 1042 	strb.w	r1, [sp, #66]	; 0x42
			conv->invalid = true;
6000420e:	bf02      	ittt	eq
60004210:	f89d 1040 	ldrbeq.w	r1, [sp, #64]	; 0x40
60004214:	f041 0101 	orreq.w	r1, r1, #1
60004218:	f88d 1040 	strbeq.w	r1, [sp, #64]	; 0x40
		if (conv->specifier == 'c') {
6000421c:	2b63      	cmp	r3, #99	; 0x63
6000421e:	d1db      	bne.n	600041d8 <z_cbvprintf_impl+0x330>
			unsupported = (conv->length_mod != LENGTH_NONE);
60004220:	1e13      	subs	r3, r2, #0
60004222:	bf18      	it	ne
60004224:	2301      	movne	r3, #1
60004226:	e7d8      	b.n	600041da <z_cbvprintf_impl+0x332>
		conv->specifier_cat = SPECIFIER_PTR;
60004228:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
6000422c:	2103      	movs	r1, #3
		if (conv->length_mod != LENGTH_NONE) {
6000422e:	f012 0f78 	tst.w	r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
60004232:	f361 0302 	bfi	r3, r1, #0, #3
60004236:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
6000423a:	bf14      	ite	ne
6000423c:	2301      	movne	r3, #1
6000423e:	2300      	moveq	r3, #0
60004240:	e7cb      	b.n	600041da <z_cbvprintf_impl+0x332>
		conv->invalid = true;
60004242:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
60004246:	f043 0301 	orr.w	r3, r3, #1
6000424a:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
		break;
6000424e:	e7c3      	b.n	600041d8 <z_cbvprintf_impl+0x330>
		} else if (conv->width_present) {
60004250:	f99d 2040 	ldrsb.w	r2, [sp, #64]	; 0x40
60004254:	2a00      	cmp	r2, #0
			width = conv->width_value;
60004256:	bfb4      	ite	lt
60004258:	f8dd 8044 	ldrlt.w	r8, [sp, #68]	; 0x44
		int width = -1;
6000425c:	f04f 38ff 	movge.w	r8, #4294967295	; 0xffffffff
60004260:	e6d5      	b.n	6000400e <z_cbvprintf_impl+0x166>
		} else if (conv->prec_present) {
60004262:	0798      	lsls	r0, r3, #30
60004264:	f57f aee2 	bpl.w	6000402c <z_cbvprintf_impl+0x184>
			precision = conv->prec_value;
60004268:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
		conv->pad0_value = 0;
6000426c:	2300      	movs	r3, #0
			= (enum length_mod_enum)conv->length_mod;
6000426e:	f89d 1041 	ldrb.w	r1, [sp, #65]	; 0x41
		conv->pad0_pre_exp = 0;
60004272:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
			= (enum specifier_cat_enum)conv->specifier_cat;
60004276:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
			= (enum length_mod_enum)conv->length_mod;
6000427a:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		enum specifier_cat_enum specifier_cat
6000427e:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
60004282:	2b01      	cmp	r3, #1
60004284:	d133      	bne.n	600042ee <z_cbvprintf_impl+0x446>
			switch (length_mod) {
60004286:	1ecb      	subs	r3, r1, #3
60004288:	2b04      	cmp	r3, #4
6000428a:	d804      	bhi.n	60004296 <z_cbvprintf_impl+0x3ee>
6000428c:	e8df f003 	tbb	[pc, r3]
60004290:	21464621 	.word	0x21464621
60004294:	21          	.byte	0x21
60004295:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
60004296:	6823      	ldr	r3, [r4, #0]
			if (length_mod == LENGTH_HH) {
60004298:	2901      	cmp	r1, #1
				value->sint = va_arg(ap, int);
6000429a:	ea4f 72e3 	mov.w	r2, r3, asr #31
6000429e:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
600042a2:	d11c      	bne.n	600042de <z_cbvprintf_impl+0x436>
				value->sint = (signed char)value->sint;
600042a4:	f99d 3038 	ldrsb.w	r3, [sp, #56]	; 0x38
600042a8:	17da      	asrs	r2, r3, #31
600042aa:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
				value->sint = va_arg(ap, int);
600042ae:	3404      	adds	r4, #4
		if (conv->invalid || conv->unsupported) {
600042b0:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
600042b4:	f013 0603 	ands.w	r6, r3, #3
600042b8:	d050      	beq.n	6000435c <z_cbvprintf_impl+0x4b4>
			OUTS(sp, fp);
600042ba:	9b03      	ldr	r3, [sp, #12]
600042bc:	463a      	mov	r2, r7
600042be:	4659      	mov	r1, fp
600042c0:	4648      	mov	r0, r9
600042c2:	f006 fbdf 	bl	6000aa84 <outs>
600042c6:	2800      	cmp	r0, #0
600042c8:	f2c0 8153 	blt.w	60004572 <z_cbvprintf_impl+0x6ca>
600042cc:	4405      	add	r5, r0
			continue;
600042ce:	9f03      	ldr	r7, [sp, #12]
600042d0:	e5f2      	b.n	60003eb8 <z_cbvprintf_impl+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
600042d2:	f854 3b04 	ldr.w	r3, [r4], #4
600042d6:	17da      	asrs	r2, r3, #31
				value->uint = (unsigned char)value->uint;
600042d8:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
600042dc:	e7e8      	b.n	600042b0 <z_cbvprintf_impl+0x408>
			} else if (length_mod == LENGTH_H) {
600042de:	2902      	cmp	r1, #2
600042e0:	d1e5      	bne.n	600042ae <z_cbvprintf_impl+0x406>
				value->sint = (short)value->sint;
600042e2:	b21a      	sxth	r2, r3
600042e4:	f343 33c0 	sbfx	r3, r3, #15, #1
600042e8:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
600042ec:	e7df      	b.n	600042ae <z_cbvprintf_impl+0x406>
		} else if (specifier_cat == SPECIFIER_UINT) {
600042ee:	2b02      	cmp	r3, #2
600042f0:	d124      	bne.n	6000433c <z_cbvprintf_impl+0x494>
			switch (length_mod) {
600042f2:	1ecb      	subs	r3, r1, #3
600042f4:	2b04      	cmp	r3, #4
600042f6:	d804      	bhi.n	60004302 <z_cbvprintf_impl+0x45a>
600042f8:	e8df f003 	tbb	[pc, r3]
600042fc:	18101018 	.word	0x18101018
60004300:	18          	.byte	0x18
60004301:	00          	.byte	0x00
			if (length_mod == LENGTH_HH) {
60004302:	2901      	cmp	r1, #1
				value->uint = va_arg(ap, unsigned int);
60004304:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
60004308:	f04f 0200 	mov.w	r2, #0
6000430c:	d014      	beq.n	60004338 <z_cbvprintf_impl+0x490>
			} else if (length_mod == LENGTH_H) {
6000430e:	2902      	cmp	r1, #2
				value->uint = va_arg(ap, unsigned int);
60004310:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			} else if (length_mod == LENGTH_H) {
60004314:	d1cc      	bne.n	600042b0 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned short)value->uint;
60004316:	b29b      	uxth	r3, r3
			value->ptr = va_arg(ap, void *);
60004318:	930e      	str	r3, [sp, #56]	; 0x38
6000431a:	e7c9      	b.n	600042b0 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap,
6000431c:	3407      	adds	r4, #7
6000431e:	f024 0407 	bic.w	r4, r4, #7
				value->uint =
60004322:	e8f4 2302 	ldrd	r2, r3, [r4], #8
60004326:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
6000432a:	e7c1      	b.n	600042b0 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap, size_t);
6000432c:	f854 3b04 	ldr.w	r3, [r4], #4
60004330:	930e      	str	r3, [sp, #56]	; 0x38
60004332:	2300      	movs	r3, #0
60004334:	930f      	str	r3, [sp, #60]	; 0x3c
			} else if (length_mod == LENGTH_H) {
60004336:	e7bb      	b.n	600042b0 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned char)value->uint;
60004338:	b2db      	uxtb	r3, r3
6000433a:	e7cd      	b.n	600042d8 <z_cbvprintf_impl+0x430>
		} else if (specifier_cat == SPECIFIER_FP) {
6000433c:	2b04      	cmp	r3, #4
6000433e:	d108      	bne.n	60004352 <z_cbvprintf_impl+0x4aa>
					(sint_value_type)va_arg(ap, long long);
60004340:	3407      	adds	r4, #7
				value->ldbl = va_arg(ap, long double);
60004342:	f024 0407 	bic.w	r4, r4, #7
60004346:	e9d4 2300 	ldrd	r2, r3, [r4]
6000434a:	3408      	adds	r4, #8
6000434c:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
60004350:	e7ae      	b.n	600042b0 <z_cbvprintf_impl+0x408>
		} else if (specifier_cat == SPECIFIER_PTR) {
60004352:	2b03      	cmp	r3, #3
60004354:	d1ac      	bne.n	600042b0 <z_cbvprintf_impl+0x408>
			value->ptr = va_arg(ap, void *);
60004356:	f854 3b04 	ldr.w	r3, [r4], #4
6000435a:	e7dd      	b.n	60004318 <z_cbvprintf_impl+0x470>
		switch (conv->specifier) {
6000435c:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
60004360:	2878      	cmp	r0, #120	; 0x78
60004362:	d8b4      	bhi.n	600042ce <z_cbvprintf_impl+0x426>
60004364:	2862      	cmp	r0, #98	; 0x62
60004366:	d81c      	bhi.n	600043a2 <z_cbvprintf_impl+0x4fa>
60004368:	2825      	cmp	r0, #37	; 0x25
6000436a:	f43f adad 	beq.w	60003ec8 <z_cbvprintf_impl+0x20>
6000436e:	2858      	cmp	r0, #88	; 0x58
60004370:	d1ad      	bne.n	600042ce <z_cbvprintf_impl+0x426>
			bps = encode_uint(value->uint, conv, buf, bpe);
60004372:	f10d 0336 	add.w	r3, sp, #54	; 0x36
60004376:	aa10      	add	r2, sp, #64	; 0x40
60004378:	9300      	str	r3, [sp, #0]
6000437a:	ab08      	add	r3, sp, #32
6000437c:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
60004380:	f006 fb3a 	bl	6000a9f8 <encode_uint>
			if (precision >= 0) {
60004384:	f1ba 0f00 	cmp.w	sl, #0
			bps = encode_uint(value->uint, conv, buf, bpe);
60004388:	4607      	mov	r7, r0
			if (precision >= 0) {
6000438a:	f280 809a 	bge.w	600044c2 <z_cbvprintf_impl+0x61a>
		if (bps == NULL) {
6000438e:	2f00      	cmp	r7, #0
60004390:	d09d      	beq.n	600042ce <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
60004392:	f10d 0336 	add.w	r3, sp, #54	; 0x36
60004396:	1bd8      	subs	r0, r3, r7
		if (sign != 0) {
60004398:	2e00      	cmp	r6, #0
6000439a:	f000 80c1 	beq.w	60004520 <z_cbvprintf_impl+0x678>
			nj_len += 1U;
6000439e:	3001      	adds	r0, #1
600043a0:	e0be      	b.n	60004520 <z_cbvprintf_impl+0x678>
		switch (conv->specifier) {
600043a2:	3863      	subs	r0, #99	; 0x63
600043a4:	2815      	cmp	r0, #21
600043a6:	d892      	bhi.n	600042ce <z_cbvprintf_impl+0x426>
600043a8:	a201      	add	r2, pc, #4	; (adr r2, 600043b0 <z_cbvprintf_impl+0x508>)
600043aa:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
600043ae:	bf00      	nop
600043b0:	60004485 	.word	0x60004485
600043b4:	60004497 	.word	0x60004497
600043b8:	600042cf 	.word	0x600042cf
600043bc:	600042cf 	.word	0x600042cf
600043c0:	600042cf 	.word	0x600042cf
600043c4:	600042cf 	.word	0x600042cf
600043c8:	60004497 	.word	0x60004497
600043cc:	600042cf 	.word	0x600042cf
600043d0:	600042cf 	.word	0x600042cf
600043d4:	600042cf 	.word	0x600042cf
600043d8:	600042cf 	.word	0x600042cf
600043dc:	60004525 	.word	0x60004525
600043e0:	600044bd 	.word	0x600044bd
600043e4:	600044e3 	.word	0x600044e3
600043e8:	600042cf 	.word	0x600042cf
600043ec:	600042cf 	.word	0x600042cf
600043f0:	60004409 	.word	0x60004409
600043f4:	600042cf 	.word	0x600042cf
600043f8:	600044bd 	.word	0x600044bd
600043fc:	600042cf 	.word	0x600042cf
60004400:	600042cf 	.word	0x600042cf
60004404:	600044bd 	.word	0x600044bd
			if (precision >= 0) {
60004408:	f1ba 0f00 	cmp.w	sl, #0
			bps = (const char *)value->ptr;
6000440c:	9f0e      	ldr	r7, [sp, #56]	; 0x38
			if (precision >= 0) {
6000440e:	db35      	blt.n	6000447c <z_cbvprintf_impl+0x5d4>
				len = strnlen(bps, precision);
60004410:	4651      	mov	r1, sl
60004412:	4638      	mov	r0, r7
60004414:	f006 fb9b 	bl	6000ab4e <strnlen>
			bpe = bps + len;
60004418:	eb07 0a00 	add.w	sl, r7, r0
		if (bps == NULL) {
6000441c:	2f00      	cmp	r7, #0
6000441e:	f43f af56 	beq.w	600042ce <z_cbvprintf_impl+0x426>
		char sign = 0;
60004422:	2600      	movs	r6, #0
		if (conv->altform_0c) {
60004424:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
60004428:	f013 0210 	ands.w	r2, r3, #16
6000442c:	9205      	str	r2, [sp, #20]
6000442e:	f000 8093 	beq.w	60004558 <z_cbvprintf_impl+0x6b0>
			nj_len += 2U;
60004432:	3002      	adds	r0, #2
		if (conv->pad_fp) {
60004434:	065b      	lsls	r3, r3, #25
		nj_len += conv->pad0_value;
60004436:	9a11      	ldr	r2, [sp, #68]	; 0x44
			nj_len += conv->pad0_pre_exp;
60004438:	bf48      	it	mi
6000443a:	9b12      	ldrmi	r3, [sp, #72]	; 0x48
		nj_len += conv->pad0_value;
6000443c:	4410      	add	r0, r2
6000443e:	9204      	str	r2, [sp, #16]
			nj_len += conv->pad0_pre_exp;
60004440:	bf48      	it	mi
60004442:	18c0      	addmi	r0, r0, r3
		if (width > 0) {
60004444:	f1b8 0f00 	cmp.w	r8, #0
60004448:	f340 809f 	ble.w	6000458a <z_cbvprintf_impl+0x6e2>
			if (!conv->flag_dash) {
6000444c:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
			width -= (int)nj_len;
60004450:	eba8 0800 	sub.w	r8, r8, r0
			if (!conv->flag_dash) {
60004454:	f3c2 0380 	ubfx	r3, r2, #2, #1
60004458:	0750      	lsls	r0, r2, #29
6000445a:	9306      	str	r3, [sp, #24]
6000445c:	f100 8095 	bmi.w	6000458a <z_cbvprintf_impl+0x6e2>
				if (conv->flag_zero) {
60004460:	0651      	lsls	r1, r2, #25
60004462:	f140 8089 	bpl.w	60004578 <z_cbvprintf_impl+0x6d0>
					if (sign != 0) {
60004466:	b13e      	cbz	r6, 60004478 <z_cbvprintf_impl+0x5d0>
						OUTC(sign);
60004468:	4659      	mov	r1, fp
6000446a:	4630      	mov	r0, r6
6000446c:	47c8      	blx	r9
6000446e:	2800      	cmp	r0, #0
60004470:	db7f      	blt.n	60004572 <z_cbvprintf_impl+0x6ca>
60004472:	9b06      	ldr	r3, [sp, #24]
60004474:	3501      	adds	r5, #1
60004476:	461e      	mov	r6, r3
					pad = '0';
60004478:	2230      	movs	r2, #48	; 0x30
6000447a:	e07e      	b.n	6000457a <z_cbvprintf_impl+0x6d2>
				len = strlen(bps);
6000447c:	4638      	mov	r0, r7
6000447e:	f006 fb5f 	bl	6000ab40 <strlen>
60004482:	e7c9      	b.n	60004418 <z_cbvprintf_impl+0x570>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
60004484:	9b0e      	ldr	r3, [sp, #56]	; 0x38
		char sign = 0;
60004486:	2600      	movs	r6, #0
			bps = buf;
60004488:	af08      	add	r7, sp, #32
			bpe = buf + 1;
6000448a:	f10d 0a21 	add.w	sl, sp, #33	; 0x21
		size_t nj_len = (bpe - bps);
6000448e:	2001      	movs	r0, #1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
60004490:	f88d 3020 	strb.w	r3, [sp, #32]
		if (sign != 0) {
60004494:	e7c6      	b.n	60004424 <z_cbvprintf_impl+0x57c>
			if (conv->flag_plus) {
60004496:	0719      	lsls	r1, r3, #28
			} else if (conv->flag_space) {
60004498:	bf56      	itet	pl
6000449a:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
				sign = '+';
6000449e:	262b      	movmi	r6, #43	; 0x2b
			} else if (conv->flag_space) {
600044a0:	015e      	lslpl	r6, r3, #5
			sint = value->sint;
600044a2:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
			if (sint < 0) {
600044a6:	2b00      	cmp	r3, #0
600044a8:	f6bf af63 	bge.w	60004372 <z_cbvprintf_impl+0x4ca>
				value->uint = (uint_value_type)-sint;
600044ac:	4252      	negs	r2, r2
				sign = '-';
600044ae:	f04f 062d 	mov.w	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
600044b2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
600044b6:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
600044ba:	e75a      	b.n	60004372 <z_cbvprintf_impl+0x4ca>
		switch (conv->specifier) {
600044bc:	2600      	movs	r6, #0
600044be:	e758      	b.n	60004372 <z_cbvprintf_impl+0x4ca>
		char sign = 0;
600044c0:	2600      	movs	r6, #0
				size_t len = bpe - bps;
600044c2:	f10d 0336 	add.w	r3, sp, #54	; 0x36
				conv->flag_zero = false;
600044c6:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				size_t len = bpe - bps;
600044ca:	1bdb      	subs	r3, r3, r7
				conv->flag_zero = false;
600044cc:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
600044d0:	459a      	cmp	sl, r3
				conv->flag_zero = false;
600044d2:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				if (len < (size_t)precision) {
600044d6:	f67f af5a 	bls.w	6000438e <z_cbvprintf_impl+0x4e6>
					conv->pad0_value = precision - (int)len;
600044da:	ebaa 0303 	sub.w	r3, sl, r3
600044de:	9311      	str	r3, [sp, #68]	; 0x44
600044e0:	e755      	b.n	6000438e <z_cbvprintf_impl+0x4e6>
			if (value->ptr != NULL) {
600044e2:	980e      	ldr	r0, [sp, #56]	; 0x38
600044e4:	b390      	cbz	r0, 6000454c <z_cbvprintf_impl+0x6a4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
600044e6:	f10d 0336 	add.w	r3, sp, #54	; 0x36
600044ea:	aa10      	add	r2, sp, #64	; 0x40
600044ec:	2100      	movs	r1, #0
600044ee:	9300      	str	r3, [sp, #0]
600044f0:	ab08      	add	r3, sp, #32
600044f2:	f006 fa81 	bl	6000a9f8 <encode_uint>
				conv->altform_0c = true;
600044f6:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
600044fa:	f1ba 0f00 	cmp.w	sl, #0
				bps = encode_uint((uintptr_t)value->ptr, conv,
600044fe:	4607      	mov	r7, r0
				conv->altform_0c = true;
60004500:	f003 03ef 	and.w	r3, r3, #239	; 0xef
60004504:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
60004508:	f043 0310 	orr.w	r3, r3, #16
6000450c:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
60004510:	dad6      	bge.n	600044c0 <z_cbvprintf_impl+0x618>
		if (bps == NULL) {
60004512:	2800      	cmp	r0, #0
60004514:	f43f aedb 	beq.w	600042ce <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
60004518:	f10d 0336 	add.w	r3, sp, #54	; 0x36
		char sign = 0;
6000451c:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
6000451e:	1a18      	subs	r0, r3, r0
		if (sign != 0) {
60004520:	469a      	mov	sl, r3
60004522:	e77f      	b.n	60004424 <z_cbvprintf_impl+0x57c>
				store_count(conv, value->ptr, count);
60004524:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	switch ((enum length_mod_enum)conv->length_mod) {
60004526:	2907      	cmp	r1, #7
60004528:	f63f aed1 	bhi.w	600042ce <z_cbvprintf_impl+0x426>
6000452c:	e8df f001 	tbb	[pc, r1]
60004530:	0c06040c 	.word	0x0c06040c
60004534:	0c0c0808 	.word	0x0c0c0808
		*(signed char *)dp = (signed char)count;
60004538:	701d      	strb	r5, [r3, #0]
		if (bps == NULL) {
6000453a:	e6c8      	b.n	600042ce <z_cbvprintf_impl+0x426>
		*(short *)dp = (short)count;
6000453c:	801d      	strh	r5, [r3, #0]
		if (bps == NULL) {
6000453e:	e6c6      	b.n	600042ce <z_cbvprintf_impl+0x426>
		*(intmax_t *)dp = (intmax_t)count;
60004540:	17ea      	asrs	r2, r5, #31
60004542:	e9c3 5200 	strd	r5, r2, [r3]
		if (bps == NULL) {
60004546:	e6c2      	b.n	600042ce <z_cbvprintf_impl+0x426>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
60004548:	601d      	str	r5, [r3, #0]
		if (bps == NULL) {
6000454a:	e6c0      	b.n	600042ce <z_cbvprintf_impl+0x426>
6000454c:	4f2e      	ldr	r7, [pc, #184]	; (60004608 <z_cbvprintf_impl+0x760>)
		char sign = 0;
6000454e:	4606      	mov	r6, r0
		size_t nj_len = (bpe - bps);
60004550:	2005      	movs	r0, #5
			bpe = bps + 5;
60004552:	f107 0a05 	add.w	sl, r7, #5
60004556:	e765      	b.n	60004424 <z_cbvprintf_impl+0x57c>
		} else if (conv->altform_0) {
60004558:	071a      	lsls	r2, r3, #28
			nj_len += 1U;
6000455a:	bf48      	it	mi
6000455c:	3001      	addmi	r0, #1
6000455e:	e769      	b.n	60004434 <z_cbvprintf_impl+0x58c>
					OUTC(pad);
60004560:	4610      	mov	r0, r2
60004562:	9307      	str	r3, [sp, #28]
60004564:	9206      	str	r2, [sp, #24]
60004566:	4659      	mov	r1, fp
60004568:	47c8      	blx	r9
6000456a:	2800      	cmp	r0, #0
6000456c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
60004570:	da04      	bge.n	6000457c <z_cbvprintf_impl+0x6d4>
#undef OUTS
#undef OUTC
}
60004572:	b015      	add	sp, #84	; 0x54
60004574:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
60004578:	2220      	movs	r2, #32
					pad = '0';
6000457a:	4643      	mov	r3, r8
				while (width-- > 0) {
6000457c:	4619      	mov	r1, r3
6000457e:	3b01      	subs	r3, #1
60004580:	2900      	cmp	r1, #0
60004582:	dced      	bgt.n	60004560 <z_cbvprintf_impl+0x6b8>
60004584:	4445      	add	r5, r8
60004586:	4698      	mov	r8, r3
60004588:	1a6d      	subs	r5, r5, r1
		if (sign != 0) {
6000458a:	b12e      	cbz	r6, 60004598 <z_cbvprintf_impl+0x6f0>
			OUTC(sign);
6000458c:	4659      	mov	r1, fp
6000458e:	4630      	mov	r0, r6
60004590:	47c8      	blx	r9
60004592:	2800      	cmp	r0, #0
60004594:	dbed      	blt.n	60004572 <z_cbvprintf_impl+0x6ca>
60004596:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
60004598:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
6000459c:	06da      	lsls	r2, r3, #27
6000459e:	d401      	bmi.n	600045a4 <z_cbvprintf_impl+0x6fc>
600045a0:	071b      	lsls	r3, r3, #28
600045a2:	d505      	bpl.n	600045b0 <z_cbvprintf_impl+0x708>
				OUTC('0');
600045a4:	4659      	mov	r1, fp
600045a6:	2030      	movs	r0, #48	; 0x30
600045a8:	47c8      	blx	r9
600045aa:	2800      	cmp	r0, #0
600045ac:	dbe1      	blt.n	60004572 <z_cbvprintf_impl+0x6ca>
600045ae:	3501      	adds	r5, #1
			if (conv->altform_0c) {
600045b0:	9b05      	ldr	r3, [sp, #20]
600045b2:	b133      	cbz	r3, 600045c2 <z_cbvprintf_impl+0x71a>
				OUTC(conv->specifier);
600045b4:	4659      	mov	r1, fp
600045b6:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
600045ba:	47c8      	blx	r9
600045bc:	2800      	cmp	r0, #0
600045be:	dbd8      	blt.n	60004572 <z_cbvprintf_impl+0x6ca>
600045c0:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
600045c2:	9e04      	ldr	r6, [sp, #16]
600045c4:	442e      	add	r6, r5
600045c6:	e005      	b.n	600045d4 <z_cbvprintf_impl+0x72c>
				OUTC('0');
600045c8:	4659      	mov	r1, fp
600045ca:	2030      	movs	r0, #48	; 0x30
600045cc:	47c8      	blx	r9
600045ce:	2800      	cmp	r0, #0
600045d0:	dbcf      	blt.n	60004572 <z_cbvprintf_impl+0x6ca>
600045d2:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
600045d4:	1b73      	subs	r3, r6, r5
600045d6:	2b00      	cmp	r3, #0
600045d8:	dcf6      	bgt.n	600045c8 <z_cbvprintf_impl+0x720>
			OUTS(bps, bpe);
600045da:	4653      	mov	r3, sl
600045dc:	463a      	mov	r2, r7
600045de:	4659      	mov	r1, fp
600045e0:	4648      	mov	r0, r9
600045e2:	f006 fa4f 	bl	6000aa84 <outs>
600045e6:	2800      	cmp	r0, #0
600045e8:	dbc3      	blt.n	60004572 <z_cbvprintf_impl+0x6ca>
600045ea:	4405      	add	r5, r0
		while (width > 0) {
600045ec:	44a8      	add	r8, r5
600045ee:	eba8 0305 	sub.w	r3, r8, r5
600045f2:	2b00      	cmp	r3, #0
600045f4:	f77f ae6b 	ble.w	600042ce <z_cbvprintf_impl+0x426>
			OUTC(' ');
600045f8:	4659      	mov	r1, fp
600045fa:	2020      	movs	r0, #32
600045fc:	47c8      	blx	r9
600045fe:	2800      	cmp	r0, #0
60004600:	dbb7      	blt.n	60004572 <z_cbvprintf_impl+0x6ca>
60004602:	3501      	adds	r5, #1
			--width;
60004604:	e7f3      	b.n	600045ee <z_cbvprintf_impl+0x746>
60004606:	bf00      	nop
60004608:	6000c57f 	.word	0x6000c57f

6000460c <imxrt_init>:
 *
 * @return 0
 */

static int imxrt_init(const struct device *arg)
{
6000460c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
6000460e:	f04f 0310 	mov.w	r3, #16
60004612:	f3ef 8411 	mrs	r4, BASEPRI
60004616:	f383 8812 	msr	BASEPRI_MAX, r3
6000461a:	f3bf 8f6f 	isb	sy
	/* SystemInit enables code cache, disable it here */
	SCB_DisableICache();
#endif

	if (IS_ENABLED(CONFIG_IMXRT1XXX_DATA_CACHE)) {
		if ((SCB->CCR & SCB_CCR_DC_Msk) == 0) {
6000461e:	4a45      	ldr	r2, [pc, #276]	; (60004734 <imxrt_init+0x128>)
60004620:	6953      	ldr	r3, [r2, #20]
60004622:	03dd      	lsls	r5, r3, #15
60004624:	d427      	bmi.n	60004676 <imxrt_init+0x6a>
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
60004626:	6953      	ldr	r3, [r2, #20]
60004628:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
6000462c:	d123      	bne.n	60004676 <imxrt_init+0x6a>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
6000462e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
60004632:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
60004636:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
6000463a:	f643 75e0 	movw	r5, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
6000463e:	f3c3 00c9 	ubfx	r0, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
60004642:	f3c3 334e 	ubfx	r3, r3, #13, #15
60004646:	015b      	lsls	r3, r3, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
60004648:	ea03 0705 	and.w	r7, r3, r5
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
6000464c:	4601      	mov	r1, r0
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
6000464e:	ea47 7681 	orr.w	r6, r7, r1, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
60004652:	3901      	subs	r1, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
60004654:	f8c2 6260 	str.w	r6, [r2, #608]	; 0x260
      } while (ways-- != 0U);
60004658:	d2f9      	bcs.n	6000464e <imxrt_init+0x42>
    } while(sets-- != 0U);
6000465a:	3b20      	subs	r3, #32
6000465c:	f113 0f20 	cmn.w	r3, #32
60004660:	d1f2      	bne.n	60004648 <imxrt_init+0x3c>
60004662:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
60004666:	6953      	ldr	r3, [r2, #20]
60004668:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
6000466c:	6153      	str	r3, [r2, #20]
6000466e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60004672:	f3bf 8f6f 	isb	sy
 *
 * @param freq The XTAL input clock frequency in Hz.
 */
static inline void CLOCK_SetXtalFreq(uint32_t freq)
{
    g_xtalFreq = freq;
60004676:	4b30      	ldr	r3, [pc, #192]	; (60004738 <imxrt_init+0x12c>)
60004678:	4a30      	ldr	r2, [pc, #192]	; (6000473c <imxrt_init+0x130>)
6000467a:	601a      	str	r2, [r3, #0]
 *
 * @param freq The RTC XTAL input clock frequency in Hz.
 */
static inline void CLOCK_SetRtcXtalFreq(uint32_t freq)
{
    g_rtcXtalFreq = freq;
6000467c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
60004680:	4b2f      	ldr	r3, [pc, #188]	; (60004740 <imxrt_init+0x134>)
60004682:	601a      	str	r2, [r3, #0]
    CCM_TUPLE_REG(CCM, mux) = (CCM_TUPLE_REG(CCM, mux) & (~CCM_TUPLE_MASK(mux))) |
60004684:	4b2f      	ldr	r3, [pc, #188]	; (60004744 <imxrt_init+0x138>)
60004686:	699a      	ldr	r2, [r3, #24]
60004688:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
6000468c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
60004690:	619a      	str	r2, [r3, #24]
60004692:	695a      	ldr	r2, [r3, #20]
60004694:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
60004698:	615a      	str	r2, [r3, #20]
        while ((CCM->CDHIPR & (1UL << busyShift)) != 0UL)
6000469a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
6000469c:	0690      	lsls	r0, r2, #26
6000469e:	d4fc      	bmi.n	6000469a <imxrt_init+0x8e>
	DCDC->REG3 = (DCDC->REG3 & (~DCDC_REG3_TRG_MASK)) | DCDC_REG3_TRG(CONFIG_DCDC_VALUE);
600046a0:	4a29      	ldr	r2, [pc, #164]	; (60004748 <imxrt_init+0x13c>)
600046a2:	68d3      	ldr	r3, [r2, #12]
600046a4:	f023 031f 	bic.w	r3, r3, #31
600046a8:	f043 0312 	orr.w	r3, r3, #18
600046ac:	60d3      	str	r3, [r2, #12]
			(DCDC_REG0_STS_DC_OK_MASK & DCDC->REG0)) {
600046ae:	6813      	ldr	r3, [r2, #0]
	while (DCDC_REG0_STS_DC_OK_MASK !=
600046b0:	2b00      	cmp	r3, #0
600046b2:	dafc      	bge.n	600046ae <imxrt_init+0xa2>
	CLOCK_InitEnetPll(&ethPllConfig);
600046b4:	4825      	ldr	r0, [pc, #148]	; (6000474c <imxrt_init+0x140>)
600046b6:	f002 f9e3 	bl	60006a80 <CLOCK_InitEnetPll>
    CCM_TUPLE_REG(CCM, divider) = (CCM_TUPLE_REG(CCM, divider) & (~CCM_TUPLE_MASK(divider))) |
600046ba:	4b22      	ldr	r3, [pc, #136]	; (60004744 <imxrt_init+0x138>)
600046bc:	691a      	ldr	r2, [r3, #16]
600046be:	f022 0207 	bic.w	r2, r2, #7
600046c2:	611a      	str	r2, [r3, #16]
        while ((CCM->CDHIPR & (1UL << busyShift)) != 0UL)
600046c4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
600046c6:	03d1      	lsls	r1, r2, #15
600046c8:	d4fc      	bmi.n	600046c4 <imxrt_init+0xb8>
    CCM_TUPLE_REG(CCM, divider) = (CCM_TUPLE_REG(CCM, divider) & (~CCM_TUPLE_MASK(divider))) |
600046ca:	695a      	ldr	r2, [r3, #20]
600046cc:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
600046d0:	615a      	str	r2, [r3, #20]
        while ((CCM->CDHIPR & (1UL << busyShift)) != 0UL)
600046d2:	4b1c      	ldr	r3, [pc, #112]	; (60004744 <imxrt_init+0x138>)
600046d4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
600046d6:	0792      	lsls	r2, r2, #30
600046d8:	d4fc      	bmi.n	600046d4 <imxrt_init+0xc8>
    CCM_TUPLE_REG(CCM, divider) = (CCM_TUPLE_REG(CCM, divider) & (~CCM_TUPLE_MASK(divider))) |
600046da:	695a      	ldr	r2, [r3, #20]
600046dc:	f442 7240 	orr.w	r2, r2, #768	; 0x300
600046e0:	615a      	str	r2, [r3, #20]
    CCM_TUPLE_REG(CCM, mux) = (CCM_TUPLE_REG(CCM, mux) & (~CCM_TUPLE_MASK(mux))) |
600046e2:	699a      	ldr	r2, [r3, #24]
600046e4:	f442 2240 	orr.w	r2, r2, #786432	; 0xc0000
600046e8:	619a      	str	r2, [r3, #24]
600046ea:	695a      	ldr	r2, [r3, #20]
600046ec:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
600046f0:	615a      	str	r2, [r3, #20]
        while ((CCM->CDHIPR & (1UL << busyShift)) != 0UL)
600046f2:	4b14      	ldr	r3, [pc, #80]	; (60004744 <imxrt_init+0x138>)
600046f4:	6c98      	ldr	r0, [r3, #72]	; 0x48
600046f6:	f010 0020 	ands.w	r0, r0, #32
600046fa:	d1fb      	bne.n	600046f4 <imxrt_init+0xe8>
    CCM_TUPLE_REG(CCM, mux) = (CCM_TUPLE_REG(CCM, mux) & (~CCM_TUPLE_MASK(mux))) |
600046fc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
600046fe:	f022 0240 	bic.w	r2, r2, #64	; 0x40
60004702:	625a      	str	r2, [r3, #36]	; 0x24
    CCM_TUPLE_REG(CCM, divider) = (CCM_TUPLE_REG(CCM, divider) & (~CCM_TUPLE_MASK(divider))) |
60004704:	6a5a      	ldr	r2, [r3, #36]	; 0x24
60004706:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
6000470a:	625a      	str	r2, [r3, #36]	; 0x24
    CCM_TUPLE_REG(CCM, mux) = (CCM_TUPLE_REG(CCM, mux) & (~CCM_TUPLE_MASK(mux))) |
6000470c:	699a      	ldr	r2, [r3, #24]
6000470e:	f022 0230 	bic.w	r2, r2, #48	; 0x30
60004712:	f042 0210 	orr.w	r2, r2, #16
60004716:	619a      	str	r2, [r3, #24]
    CCM_TUPLE_REG(CCM, divider) = (CCM_TUPLE_REG(CCM, divider) & (~CCM_TUPLE_MASK(divider))) |
60004718:	699a      	ldr	r2, [r3, #24]
6000471a:	f042 52e0 	orr.w	r2, r2, #469762048	; 0x1c000000
6000471e:	619a      	str	r2, [r3, #24]
    CCM->CLPCR = (CCM->CLPCR & ~CCM_CLPCR_LPM_MASK) | CCM_CLPCR_LPM((uint32_t)mode);
60004720:	6d5a      	ldr	r2, [r3, #84]	; 0x54
60004722:	f022 0203 	bic.w	r2, r2, #3
60004726:	655a      	str	r2, [r3, #84]	; 0x54
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
60004728:	f384 8811 	msr	BASEPRI, r4
6000472c:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	/* restore interrupt state */
	irq_unlock(oldLevel);
	return 0;
}
60004730:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
60004732:	bf00      	nop
60004734:	e000ed00 	.word	0xe000ed00
60004738:	8000162c 	.word	0x8000162c
6000473c:	016e3600 	.word	0x016e3600
60004740:	80001628 	.word	0x80001628
60004744:	400fc000 	.word	0x400fc000
60004748:	40080000 	.word	0x40080000
6000474c:	6000c585 	.word	0x6000c585

60004750 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
60004750:	4901      	ldr	r1, [pc, #4]	; (60004758 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
60004752:	2210      	movs	r2, #16
	str	r2, [r1]
60004754:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
60004756:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
60004758:	e000ed10 	.word	0xe000ed10

6000475c <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
6000475c:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
6000475e:	4040      	eors	r0, r0
	msr	BASEPRI, r0
60004760:	f380 8811 	msr	BASEPRI, r0
	isb
60004764:	f3bf 8f6f 	isb	sy
	 * (i.e. if the caller sets _kernel.idle).
	 */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	/* Enter low power state */
	_sleep_if_allowed wfi
60004768:	f3bf 8f4f 	dsb	sy
6000476c:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
6000476e:	b662      	cpsie	i
	isb
60004770:	f3bf 8f6f 	isb	sy

	bx	lr
60004774:	4770      	bx	lr
60004776:	bf00      	nop

60004778 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
60004778:	b537      	push	{r0, r1, r2, r4, r5, lr}
6000477a:	4605      	mov	r5, r0

	if (esf != NULL) {
6000477c:	460c      	mov	r4, r1
6000477e:	b1c9      	cbz	r1, 600047b4 <z_arm_fatal_error+0x3c>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
60004780:	688b      	ldr	r3, [r1, #8]
60004782:	4810      	ldr	r0, [pc, #64]	; (600047c4 <z_arm_fatal_error+0x4c>)
60004784:	9300      	str	r3, [sp, #0]
60004786:	e9d1 2300 	ldrd	r2, r3, [r1]
6000478a:	2145      	movs	r1, #69	; 0x45
6000478c:	f006 f9a8 	bl	6000aae0 <z_log_minimal_printk>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
60004790:	6963      	ldr	r3, [r4, #20]
60004792:	2145      	movs	r1, #69	; 0x45
60004794:	480c      	ldr	r0, [pc, #48]	; (600047c8 <z_arm_fatal_error+0x50>)
60004796:	9300      	str	r3, [sp, #0]
60004798:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
6000479c:	f006 f9a0 	bl	6000aae0 <z_log_minimal_printk>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
600047a0:	69e2      	ldr	r2, [r4, #28]
600047a2:	2145      	movs	r1, #69	; 0x45
600047a4:	4809      	ldr	r0, [pc, #36]	; (600047cc <z_arm_fatal_error+0x54>)
600047a6:	f006 f99b 	bl	6000aae0 <z_log_minimal_printk>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
600047aa:	69a2      	ldr	r2, [r4, #24]
600047ac:	2145      	movs	r1, #69	; 0x45
600047ae:	4808      	ldr	r0, [pc, #32]	; (600047d0 <z_arm_fatal_error+0x58>)
600047b0:	f006 f996 	bl	6000aae0 <z_log_minimal_printk>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
600047b4:	4621      	mov	r1, r4
600047b6:	4628      	mov	r0, r5
}
600047b8:	b003      	add	sp, #12
600047ba:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	z_fatal_error(reason, esf);
600047be:	f004 b9ed 	b.w	60008b9c <z_fatal_error>
600047c2:	bf00      	nop
600047c4:	6000c58a 	.word	0x6000c58a
600047c8:	6000c5be 	.word	0x6000c5be
600047cc:	6000c5f2 	.word	0x6000c5f2
600047d0:	6000c606 	.word	0x6000c606

600047d4 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
600047d4:	b200      	sxth	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
600047d6:	2800      	cmp	r0, #0
600047d8:	db07      	blt.n	600047ea <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
600047da:	2301      	movs	r3, #1
600047dc:	0941      	lsrs	r1, r0, #5
600047de:	f000 001f 	and.w	r0, r0, #31
600047e2:	4a02      	ldr	r2, [pc, #8]	; (600047ec <arch_irq_enable+0x18>)
600047e4:	4083      	lsls	r3, r0
600047e6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
600047ea:	4770      	bx	lr
600047ec:	e000e100 	.word	0xe000e100

600047f0 <z_arm_irq_priority_set>:
 * The priority is verified if ASSERT_ON is enabled. The maximum number
 * of priority levels is a little complex, as there are some hardware
 * priority levels which are reserved.
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
600047f0:	b538      	push	{r3, r4, r5, lr}
			prio = _EXC_ZERO_LATENCY_IRQS_PRIO;
		} else {
			/* Use caller supplied prio level as-is */
		}
	} else {
		prio += _IRQ_PRIO_OFFSET;
600047f2:	1c4b      	adds	r3, r1, #1
{
600047f4:	4604      	mov	r4, r0
600047f6:	460d      	mov	r5, r1
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
600047f8:	2b0f      	cmp	r3, #15
600047fa:	d90f      	bls.n	6000481c <z_arm_irq_priority_set+0x2c>
600047fc:	235b      	movs	r3, #91	; 0x5b
600047fe:	4a10      	ldr	r2, [pc, #64]	; (60004840 <z_arm_irq_priority_set+0x50>)
60004800:	4910      	ldr	r1, [pc, #64]	; (60004844 <z_arm_irq_priority_set+0x54>)
60004802:	4811      	ldr	r0, [pc, #68]	; (60004848 <z_arm_irq_priority_set+0x58>)
60004804:	f006 f95c 	bl	6000aac0 <assert_print>
60004808:	4629      	mov	r1, r5
6000480a:	4810      	ldr	r0, [pc, #64]	; (6000484c <z_arm_irq_priority_set+0x5c>)
6000480c:	230f      	movs	r3, #15
6000480e:	4622      	mov	r2, r4
60004810:	f006 f956 	bl	6000aac0 <assert_print>
60004814:	215b      	movs	r1, #91	; 0x5b
60004816:	480a      	ldr	r0, [pc, #40]	; (60004840 <z_arm_irq_priority_set+0x50>)
60004818:	f006 f94b 	bl	6000aab2 <assert_post_action>
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
6000481c:	b200      	sxth	r0, r0
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
6000481e:	011b      	lsls	r3, r3, #4
  if ((int32_t)(IRQn) >= 0)
60004820:	2800      	cmp	r0, #0
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
60004822:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
60004824:	db06      	blt.n	60004834 <z_arm_irq_priority_set+0x44>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
60004826:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
6000482a:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
6000482e:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
}
60004832:	bd38      	pop	{r3, r4, r5, pc}
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
60004834:	f000 000f 	and.w	r0, r0, #15
60004838:	4a05      	ldr	r2, [pc, #20]	; (60004850 <z_arm_irq_priority_set+0x60>)
6000483a:	5413      	strb	r3, [r2, r0]
6000483c:	e7f9      	b.n	60004832 <z_arm_irq_priority_set+0x42>
6000483e:	bf00      	nop
60004840:	6000c639 	.word	0x6000c639
60004844:	6000c66f 	.word	0x6000c66f
60004848:	6000c68a 	.word	0x6000c68a
6000484c:	6000c6a7 	.word	0x6000c6a7
60004850:	e000ed14 	.word	0xe000ed14

60004854 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
60004854:	bf30      	wfi
    b z_SysNmiOnReset
60004856:	f7ff bffd 	b.w	60004854 <z_SysNmiOnReset>
6000485a:	bf00      	nop

6000485c <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
6000485c:	4a0f      	ldr	r2, [pc, #60]	; (6000489c <z_arm_prep_c+0x40>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
6000485e:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
60004860:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
60004864:	4b0e      	ldr	r3, [pc, #56]	; (600048a0 <z_arm_prep_c+0x44>)
60004866:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
60004868:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
6000486c:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
60004870:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
60004874:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
60004878:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
6000487c:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
60004880:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
60004884:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
60004888:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
6000488c:	f004 fa1e 	bl	60008ccc <z_bss_zero>
	z_data_copy();
60004890:	f005 fd9c 	bl	6000a3cc <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
60004894:	f000 fb32 	bl	60004efc <z_arm_interrupt_init>
	z_cstart();
60004898:	f004 fa6a 	bl	60008d70 <z_cstart>
6000489c:	60003800 	.word	0x60003800
600048a0:	e000ed00 	.word	0xe000ed00

600048a4 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
600048a4:	4a0a      	ldr	r2, [pc, #40]	; (600048d0 <arch_swap+0x2c>)
	_current->arch.swap_return_value = _k_neg_eagain;
600048a6:	490b      	ldr	r1, [pc, #44]	; (600048d4 <arch_swap+0x30>)
	_current->arch.basepri = key;
600048a8:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
600048aa:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
600048ac:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	_current->arch.swap_return_value = _k_neg_eagain;
600048b0:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
600048b4:	4908      	ldr	r1, [pc, #32]	; (600048d8 <arch_swap+0x34>)
600048b6:	684b      	ldr	r3, [r1, #4]
600048b8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
600048bc:	604b      	str	r3, [r1, #4]
600048be:	2300      	movs	r3, #0
600048c0:	f383 8811 	msr	BASEPRI, r3
600048c4:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
600048c8:	6893      	ldr	r3, [r2, #8]
}
600048ca:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
600048ce:	4770      	bx	lr
600048d0:	800016c8 	.word	0x800016c8
600048d4:	6000c4d8 	.word	0x6000c4d8
600048d8:	e000ed00 	.word	0xe000ed00

600048dc <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
600048dc:	4913      	ldr	r1, [pc, #76]	; (6000492c <z_arm_pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
600048de:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
600048e0:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
600048e4:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
600048e6:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
600048ea:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
600048ee:	2010      	movs	r0, #16
    msr BASEPRI_MAX, r0
600048f0:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
600048f4:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
600048f8:	4f0d      	ldr	r7, [pc, #52]	; (60004930 <z_arm_pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
600048fa:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
600048fe:	698a      	ldr	r2, [r1, #24]

    str r2, [r1, #_kernel_offset_to_current]
60004900:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
60004902:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
60004904:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
    movs r3, #0
60004908:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
6000490a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
6000490e:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
60004912:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
60004914:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
60004916:	f000 fb37 	bl	60004f88 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
6000491a:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
6000491e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
60004922:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
60004926:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
6000492a:	4770      	bx	lr
    ldr r1, =_kernel
6000492c:	800016c8 	.word	0x800016c8
    ldr v4, =_SCS_ICSR
60004930:	e000ed04 	.word	0xe000ed04

60004934 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
60004934:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
60004938:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
6000493a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
6000493e:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
60004942:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
60004944:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
60004948:	2902      	cmp	r1, #2
    beq _oops
6000494a:	d0ff      	beq.n	6000494c <_oops>

6000494c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
6000494c:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
6000494e:	f006 f8d4 	bl	6000aafa <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
60004952:	bd01      	pop	{r0, pc}

60004954 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
60004954:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
60004958:	3a20      	subs	r2, #32
	iframe->a2 = (uint32_t)p1;
6000495a:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
6000495c:	4908      	ldr	r1, [pc, #32]	; (60004980 <arch_new_thread+0x2c>)
	iframe->a2 = (uint32_t)p1;
6000495e:	6053      	str	r3, [r2, #4]
	iframe->a3 = (uint32_t)p2;
60004960:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
60004962:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
60004966:	6093      	str	r3, [r2, #8]
	iframe->a4 = (uint32_t)p3;
60004968:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
6000496a:	6191      	str	r1, [r2, #24]
	iframe->a4 = (uint32_t)p3;
6000496c:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
6000496e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
60004972:	61d3      	str	r3, [r2, #28]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
60004974:	2300      	movs	r3, #0
	thread->callee_saved.psp = (uint32_t)iframe;
60004976:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
60004978:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
6000497c:	4770      	bx	lr
6000497e:	bf00      	nop
60004980:	6000a9e5 	.word	0x6000a9e5

60004984 <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
60004984:	4a0a      	ldr	r2, [pc, #40]	; (600049b0 <z_check_thread_stack_fail+0x2c>)
{
60004986:	4603      	mov	r3, r0
	const struct k_thread *thread = _current;
60004988:	6890      	ldr	r0, [r2, #8]

	if (thread == NULL) {
6000498a:	b178      	cbz	r0, 600049ac <z_check_thread_stack_fail+0x28>
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
6000498c:	f113 0f16 	cmn.w	r3, #22
60004990:	f8d0 0084 	ldr.w	r0, [r0, #132]	; 0x84
60004994:	d005      	beq.n	600049a2 <z_check_thread_stack_fail+0x1e>
60004996:	f1a0 0240 	sub.w	r2, r0, #64	; 0x40
6000499a:	429a      	cmp	r2, r3
6000499c:	d805      	bhi.n	600049aa <z_check_thread_stack_fail+0x26>
6000499e:	4283      	cmp	r3, r0
600049a0:	d203      	bcs.n	600049aa <z_check_thread_stack_fail+0x26>
		return 0;
600049a2:	4281      	cmp	r1, r0
600049a4:	bf28      	it	cs
600049a6:	2000      	movcs	r0, #0
600049a8:	4770      	bx	lr
600049aa:	2000      	movs	r0, #0
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
}
600049ac:	4770      	bx	lr
600049ae:	bf00      	nop
600049b0:	800016c8 	.word	0x800016c8

600049b4 <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
600049b4:	b508      	push	{r3, lr}
	z_arm_prepare_switch_to_main();

	_current = main_thread;
600049b6:	4b09      	ldr	r3, [pc, #36]	; (600049dc <arch_switch_to_main_thread+0x28>)
{
600049b8:	460d      	mov	r5, r1
600049ba:	4614      	mov	r4, r2
	_current = main_thread;
600049bc:	6098      	str	r0, [r3, #8]
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
600049be:	f000 fae3 	bl	60004f88 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
600049c2:	4620      	mov	r0, r4
600049c4:	f385 8809 	msr	PSP, r5
600049c8:	2100      	movs	r1, #0
600049ca:	b663      	cpsie	if
600049cc:	f381 8811 	msr	BASEPRI, r1
600049d0:	f3bf 8f6f 	isb	sy
600049d4:	2200      	movs	r2, #0
600049d6:	2300      	movs	r3, #0
600049d8:	f006 f804 	bl	6000a9e4 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
600049dc:	800016c8 	.word	0x800016c8

600049e0 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
600049e0:	b501      	push	{r0, lr}
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
600049e2:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
600049e6:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
600049ea:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
600049ee:	4904      	ldr	r1, [pc, #16]	; (60004a00 <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
600049f0:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
600049f2:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
600049f4:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
600049f6:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
600049fa:	4902      	ldr	r1, [pc, #8]	; (60004a04 <_isr_wrapper+0x24>)
	bx r1
600049fc:	4708      	bx	r1
600049fe:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
60004a00:	6000b618 	.word	0x6000b618
	ldr r1, =z_arm_int_exit
60004a04:	60004a09 	.word	0x60004a09

60004a08 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
60004a08:	4b04      	ldr	r3, [pc, #16]	; (60004a1c <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
60004a0a:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
60004a0c:	6998      	ldr	r0, [r3, #24]
	cmp r0, r1
60004a0e:	4288      	cmp	r0, r1
	beq _EXIT_EXC
60004a10:	d003      	beq.n	60004a1a <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
60004a12:	4903      	ldr	r1, [pc, #12]	; (60004a20 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
60004a14:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
60004a18:	600a      	str	r2, [r1, #0]

60004a1a <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
60004a1a:	4770      	bx	lr
	ldr r3, =_kernel
60004a1c:	800016c8 	.word	0x800016c8
	ldr r1, =_SCS_ICSR
60004a20:	e000ed04 	.word	0xe000ed04

60004a24 <mem_manage_fault>:
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
			      bool *recoverable)
{
60004a24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
60004a28:	4d3f      	ldr	r5, [pc, #252]	; (60004b28 <mem_manage_fault+0x104>)
{
60004a2a:	4680      	mov	r8, r0
60004a2c:	4689      	mov	r9, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
60004a2e:	483f      	ldr	r0, [pc, #252]	; (60004b2c <mem_manage_fault+0x108>)
60004a30:	2145      	movs	r1, #69	; 0x45
{
60004a32:	4617      	mov	r7, r2
	PR_FAULT_INFO("***** MPU FAULT *****");
60004a34:	f006 f854 	bl	6000aae0 <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
60004a38:	6aab      	ldr	r3, [r5, #40]	; 0x28
60004a3a:	06da      	lsls	r2, r3, #27
60004a3c:	d526      	bpl.n	60004a8c <mem_manage_fault+0x68>
		reason = K_ERR_ARM_MEM_STACKING;
60004a3e:	2411      	movs	r4, #17
		PR_FAULT_INFO("  Stacking error (context area might be"
60004a40:	2145      	movs	r1, #69	; 0x45
60004a42:	483b      	ldr	r0, [pc, #236]	; (60004b30 <mem_manage_fault+0x10c>)
60004a44:	f006 f84c 	bl	6000aae0 <z_log_minimal_printk>
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
60004a48:	6aab      	ldr	r3, [r5, #40]	; 0x28
60004a4a:	071b      	lsls	r3, r3, #28
60004a4c:	d504      	bpl.n	60004a58 <mem_manage_fault+0x34>
		reason = K_ERR_ARM_MEM_UNSTACKING;
60004a4e:	2412      	movs	r4, #18
		PR_FAULT_INFO("  Unstacking error");
60004a50:	2145      	movs	r1, #69	; 0x45
60004a52:	4838      	ldr	r0, [pc, #224]	; (60004b34 <mem_manage_fault+0x110>)
60004a54:	f006 f844 	bl	6000aae0 <z_log_minimal_printk>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
60004a58:	4d33      	ldr	r5, [pc, #204]	; (60004b28 <mem_manage_fault+0x104>)
60004a5a:	6aab      	ldr	r3, [r5, #40]	; 0x28
60004a5c:	079e      	lsls	r6, r3, #30
60004a5e:	d517      	bpl.n	60004a90 <mem_manage_fault+0x6c>
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
		PR_FAULT_INFO("  Data Access Violation");
60004a60:	2145      	movs	r1, #69	; 0x45
60004a62:	4835      	ldr	r0, [pc, #212]	; (60004b38 <mem_manage_fault+0x114>)
60004a64:	f006 f83c 	bl	6000aae0 <z_log_minimal_printk>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		uint32_t temp = SCB->MMFAR;
60004a68:	6b6e      	ldr	r6, [r5, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
60004a6a:	6aab      	ldr	r3, [r5, #40]	; 0x28
60004a6c:	061c      	lsls	r4, r3, #24
60004a6e:	d545      	bpl.n	60004afc <mem_manage_fault+0xd8>
			mmfar = temp;
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
60004a70:	4632      	mov	r2, r6
60004a72:	2145      	movs	r1, #69	; 0x45
60004a74:	4831      	ldr	r0, [pc, #196]	; (60004b3c <mem_manage_fault+0x118>)
60004a76:	f006 f833 	bl	6000aae0 <z_log_minimal_printk>
			if (from_hard_fault != 0) {
60004a7a:	f1b9 0f00 	cmp.w	r9, #0
60004a7e:	d003      	beq.n	60004a88 <mem_manage_fault+0x64>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
60004a80:	6aab      	ldr	r3, [r5, #40]	; 0x28
60004a82:	f023 0380 	bic.w	r3, r3, #128	; 0x80
60004a86:	62ab      	str	r3, [r5, #40]	; 0x28
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
60004a88:	2413      	movs	r4, #19
60004a8a:	e003      	b.n	60004a94 <mem_manage_fault+0x70>
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
60004a8c:	2410      	movs	r4, #16
60004a8e:	e7db      	b.n	60004a48 <mem_manage_fault+0x24>
	uint32_t mmfar = -EINVAL;
60004a90:	f06f 0615 	mvn.w	r6, #21
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
60004a94:	4d24      	ldr	r5, [pc, #144]	; (60004b28 <mem_manage_fault+0x104>)
60004a96:	6aab      	ldr	r3, [r5, #40]	; 0x28
60004a98:	07d8      	lsls	r0, r3, #31
60004a9a:	d504      	bpl.n	60004aa6 <mem_manage_fault+0x82>
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
60004a9c:	2414      	movs	r4, #20
		PR_FAULT_INFO("  Instruction Access Violation");
60004a9e:	2145      	movs	r1, #69	; 0x45
60004aa0:	4827      	ldr	r0, [pc, #156]	; (60004b40 <mem_manage_fault+0x11c>)
60004aa2:	f006 f81d 	bl	6000aae0 <z_log_minimal_printk>
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
60004aa6:	6aab      	ldr	r3, [r5, #40]	; 0x28
60004aa8:	0699      	lsls	r1, r3, #26
60004aaa:	d504      	bpl.n	60004ab6 <mem_manage_fault+0x92>
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
60004aac:	2415      	movs	r4, #21
		PR_FAULT_INFO(
60004aae:	2145      	movs	r1, #69	; 0x45
60004ab0:	4824      	ldr	r0, [pc, #144]	; (60004b44 <mem_manage_fault+0x120>)
60004ab2:	f006 f815 	bl	6000aae0 <z_log_minimal_printk>
	 * crossed into an area beyond the thread stack.]
	 *
	 * Data Access Violation errors may or may not be caused by
	 * thread stack overflows.
	 */
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
60004ab6:	4d1c      	ldr	r5, [pc, #112]	; (60004b28 <mem_manage_fault+0x104>)
60004ab8:	6aab      	ldr	r3, [r5, #40]	; 0x28
60004aba:	06da      	lsls	r2, r3, #27
60004abc:	d402      	bmi.n	60004ac4 <mem_manage_fault+0xa0>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
60004abe:	6aab      	ldr	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
60004ac0:	079b      	lsls	r3, r3, #30
60004ac2:	d50a      	bpl.n	60004ada <mem_manage_fault+0xb6>
		 * not accompanied by a data access violation error (i.e.
		 * when stack overflows due to the exception entry frame
		 * stacking): z_check_thread_stack_fail() shall be able to
		 * handle the case of 'mmfar' holding the -EINVAL value.
		 */
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
60004ac4:	686b      	ldr	r3, [r5, #4]
60004ac6:	0518      	lsls	r0, r3, #20
60004ac8:	d507      	bpl.n	60004ada <mem_manage_fault+0xb6>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
60004aca:	4641      	mov	r1, r8
60004acc:	4630      	mov	r0, r6
60004ace:	f7ff ff59 	bl	60004984 <z_check_thread_stack_fail>
				((uint32_t) &esf[0]));

			if (min_stack_ptr) {
60004ad2:	b1b0      	cbz	r0, 60004b02 <mem_manage_fault+0xde>
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
60004ad4:	f380 8809 	msr	PSP, r0
				 * fatal error and a thread that corrupted its
				 * stack needs to be aborted.
				 */
				__set_PSP(min_stack_ptr);

				reason = K_ERR_STACK_CHK_FAIL;
60004ad8:	2402      	movs	r4, #2
	 * lazy stacking Memory Manage fault. At the time of writing, this
	 * can happen when printing.  If that's true, we should clear the
	 * pending flag in addition to the clearing the reason for the fault
	 */
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
60004ada:	4b13      	ldr	r3, [pc, #76]	; (60004b28 <mem_manage_fault+0x104>)
60004adc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
60004ade:	0692      	lsls	r2, r2, #26
60004ae0:	d503      	bpl.n	60004aea <mem_manage_fault+0xc6>
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
60004ae2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
60004ae4:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
60004ae8:	625a      	str	r2, [r3, #36]	; 0x24
	}
#endif /* CONFIG_ARMV7_M_ARMV8_M_FP */

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
60004aea:	6a9a      	ldr	r2, [r3, #40]	; 0x28

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf, true);

	return reason;
}
60004aec:	4620      	mov	r0, r4
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
60004aee:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
60004af2:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
60004af4:	2300      	movs	r3, #0
60004af6:	703b      	strb	r3, [r7, #0]
}
60004af8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	uint32_t mmfar = -EINVAL;
60004afc:	f06f 0615 	mvn.w	r6, #21
60004b00:	e7c2      	b.n	60004a88 <mem_manage_fault+0x64>
				__ASSERT(!(SCB->CFSR & SCB_CFSR_MSTKERR_Msk),
60004b02:	6aab      	ldr	r3, [r5, #40]	; 0x28
60004b04:	06d9      	lsls	r1, r3, #27
60004b06:	d5e8      	bpl.n	60004ada <mem_manage_fault+0xb6>
60004b08:	490f      	ldr	r1, [pc, #60]	; (60004b48 <mem_manage_fault+0x124>)
60004b0a:	f240 135b 	movw	r3, #347	; 0x15b
60004b0e:	4a0f      	ldr	r2, [pc, #60]	; (60004b4c <mem_manage_fault+0x128>)
60004b10:	480f      	ldr	r0, [pc, #60]	; (60004b50 <mem_manage_fault+0x12c>)
60004b12:	f005 ffd5 	bl	6000aac0 <assert_print>
60004b16:	480f      	ldr	r0, [pc, #60]	; (60004b54 <mem_manage_fault+0x130>)
60004b18:	f005 ffd2 	bl	6000aac0 <assert_print>
60004b1c:	f240 115b 	movw	r1, #347	; 0x15b
60004b20:	480a      	ldr	r0, [pc, #40]	; (60004b4c <mem_manage_fault+0x128>)
60004b22:	f005 ffc6 	bl	6000aab2 <assert_post_action>
60004b26:	bf00      	nop
60004b28:	e000ed00 	.word	0xe000ed00
60004b2c:	6000c6e7 	.word	0x6000c6e7
60004b30:	6000c702 	.word	0x6000c702
60004b34:	6000c73a 	.word	0x6000c73a
60004b38:	6000c752 	.word	0x6000c752
60004b3c:	6000c76f 	.word	0x6000c76f
60004b40:	6000c78a 	.word	0x6000c78a
60004b44:	6000c7ae 	.word	0x6000c7ae
60004b48:	6000c81c 	.word	0x6000c81c
60004b4c:	6000c7e2 	.word	0x6000c7e2
60004b50:	6000c68a 	.word	0x6000c68a
60004b54:	6000c866 	.word	0x6000c866

60004b58 <usage_fault.constprop.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
60004b58:	b510      	push	{r4, lr}
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
60004b5a:	4c20      	ldr	r4, [pc, #128]	; (60004bdc <usage_fault.constprop.0+0x84>)
	PR_FAULT_INFO("***** USAGE FAULT *****");
60004b5c:	2145      	movs	r1, #69	; 0x45
60004b5e:	4820      	ldr	r0, [pc, #128]	; (60004be0 <usage_fault.constprop.0+0x88>)
60004b60:	f005 ffbe 	bl	6000aae0 <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
60004b64:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004b66:	0199      	lsls	r1, r3, #6
60004b68:	d536      	bpl.n	60004bd8 <usage_fault.constprop.0+0x80>
		reason = K_ERR_ARM_USAGE_DIV_0;
		PR_FAULT_INFO("  Division by zero");
60004b6a:	481e      	ldr	r0, [pc, #120]	; (60004be4 <usage_fault.constprop.0+0x8c>)
60004b6c:	2145      	movs	r1, #69	; 0x45
60004b6e:	f005 ffb7 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_DIV_0;
60004b72:	201e      	movs	r0, #30
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
60004b74:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004b76:	01da      	lsls	r2, r3, #7
60004b78:	d504      	bpl.n	60004b84 <usage_fault.constprop.0+0x2c>
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
		PR_FAULT_INFO("  Unaligned memory access");
60004b7a:	481b      	ldr	r0, [pc, #108]	; (60004be8 <usage_fault.constprop.0+0x90>)
60004b7c:	2145      	movs	r1, #69	; 0x45
60004b7e:	f005 ffaf 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
60004b82:	201f      	movs	r0, #31
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
60004b84:	4c15      	ldr	r4, [pc, #84]	; (60004bdc <usage_fault.constprop.0+0x84>)
60004b86:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004b88:	031b      	lsls	r3, r3, #12
60004b8a:	d504      	bpl.n	60004b96 <usage_fault.constprop.0+0x3e>
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
		PR_FAULT_INFO("  No coprocessor instructions");
60004b8c:	4817      	ldr	r0, [pc, #92]	; (60004bec <usage_fault.constprop.0+0x94>)
60004b8e:	2145      	movs	r1, #69	; 0x45
60004b90:	f005 ffa6 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
60004b94:	2021      	movs	r0, #33	; 0x21
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
60004b96:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004b98:	0359      	lsls	r1, r3, #13
60004b9a:	d504      	bpl.n	60004ba6 <usage_fault.constprop.0+0x4e>
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
60004b9c:	4814      	ldr	r0, [pc, #80]	; (60004bf0 <usage_fault.constprop.0+0x98>)
60004b9e:	2145      	movs	r1, #69	; 0x45
60004ba0:	f005 ff9e 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
60004ba4:	2022      	movs	r0, #34	; 0x22
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
60004ba6:	4c0d      	ldr	r4, [pc, #52]	; (60004bdc <usage_fault.constprop.0+0x84>)
60004ba8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004baa:	039a      	lsls	r2, r3, #14
60004bac:	d504      	bpl.n	60004bb8 <usage_fault.constprop.0+0x60>
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
		PR_FAULT_INFO("  Illegal use of the EPSR");
60004bae:	4811      	ldr	r0, [pc, #68]	; (60004bf4 <usage_fault.constprop.0+0x9c>)
60004bb0:	2145      	movs	r1, #69	; 0x45
60004bb2:	f005 ff95 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
60004bb6:	2023      	movs	r0, #35	; 0x23
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
60004bb8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004bba:	03db      	lsls	r3, r3, #15
60004bbc:	d504      	bpl.n	60004bc8 <usage_fault.constprop.0+0x70>
		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
60004bbe:	480e      	ldr	r0, [pc, #56]	; (60004bf8 <usage_fault.constprop.0+0xa0>)
60004bc0:	2145      	movs	r1, #69	; 0x45
60004bc2:	f005 ff8d 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
60004bc6:	2024      	movs	r0, #36	; 0x24
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
60004bc8:	4a04      	ldr	r2, [pc, #16]	; (60004bdc <usage_fault.constprop.0+0x84>)
60004bca:	6a93      	ldr	r3, [r2, #40]	; 0x28
60004bcc:	ea6f 4303 	mvn.w	r3, r3, lsl #16
60004bd0:	ea6f 4313 	mvn.w	r3, r3, lsr #16
60004bd4:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
60004bd6:	bd10      	pop	{r4, pc}
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
60004bd8:	201d      	movs	r0, #29
60004bda:	e7cb      	b.n	60004b74 <usage_fault.constprop.0+0x1c>
60004bdc:	e000ed00 	.word	0xe000ed00
60004be0:	6000c889 	.word	0x6000c889
60004be4:	6000c8a6 	.word	0x6000c8a6
60004be8:	6000c8be 	.word	0x6000c8be
60004bec:	6000c8dd 	.word	0x6000c8dd
60004bf0:	6000c900 	.word	0x6000c900
60004bf4:	6000c92a 	.word	0x6000c92a
60004bf8:	6000c949 	.word	0x6000c949

60004bfc <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
60004bfc:	b570      	push	{r4, r5, r6, lr}
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
60004bfe:	4c28      	ldr	r4, [pc, #160]	; (60004ca0 <bus_fault.constprop.0+0xa4>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
60004c00:	4606      	mov	r6, r0
60004c02:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
60004c04:	4827      	ldr	r0, [pc, #156]	; (60004ca4 <bus_fault.constprop.0+0xa8>)
60004c06:	2145      	movs	r1, #69	; 0x45
60004c08:	f005 ff6a 	bl	6000aae0 <z_log_minimal_printk>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
60004c0c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004c0e:	04d9      	lsls	r1, r3, #19
60004c10:	d53b      	bpl.n	60004c8a <bus_fault.constprop.0+0x8e>
		PR_FAULT_INFO("  Stacking error");
60004c12:	4825      	ldr	r0, [pc, #148]	; (60004ca8 <bus_fault.constprop.0+0xac>)
60004c14:	2145      	movs	r1, #69	; 0x45
60004c16:	f005 ff63 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_BUS_STACKING;
60004c1a:	2017      	movs	r0, #23
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
60004c1c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004c1e:	051a      	lsls	r2, r3, #20
60004c20:	d504      	bpl.n	60004c2c <bus_fault.constprop.0+0x30>
		PR_FAULT_INFO("  Unstacking error");
60004c22:	4822      	ldr	r0, [pc, #136]	; (60004cac <bus_fault.constprop.0+0xb0>)
60004c24:	2145      	movs	r1, #69	; 0x45
60004c26:	f005 ff5b 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_BUS_UNSTACKING;
60004c2a:	2018      	movs	r0, #24
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
60004c2c:	4c1c      	ldr	r4, [pc, #112]	; (60004ca0 <bus_fault.constprop.0+0xa4>)
60004c2e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004c30:	059b      	lsls	r3, r3, #22
60004c32:	d511      	bpl.n	60004c58 <bus_fault.constprop.0+0x5c>
		PR_FAULT_INFO("  Precise data bus error");
60004c34:	481e      	ldr	r0, [pc, #120]	; (60004cb0 <bus_fault.constprop.0+0xb4>)
60004c36:	2145      	movs	r1, #69	; 0x45
60004c38:	f005 ff52 	bl	6000aae0 <z_log_minimal_printk>
		STORE_xFAR(bfar, SCB->BFAR);
60004c3c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
60004c3e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004c40:	0418      	lsls	r0, r3, #16
60004c42:	d508      	bpl.n	60004c56 <bus_fault.constprop.0+0x5a>
			PR_EXC("  BFAR Address: 0x%x", bfar);
60004c44:	2145      	movs	r1, #69	; 0x45
60004c46:	481b      	ldr	r0, [pc, #108]	; (60004cb4 <bus_fault.constprop.0+0xb8>)
60004c48:	f005 ff4a 	bl	6000aae0 <z_log_minimal_printk>
			if (from_hard_fault != 0) {
60004c4c:	b11e      	cbz	r6, 60004c56 <bus_fault.constprop.0+0x5a>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
60004c4e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004c50:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
60004c54:	62a3      	str	r3, [r4, #40]	; 0x28
		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
60004c56:	2019      	movs	r0, #25
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
60004c58:	4c11      	ldr	r4, [pc, #68]	; (60004ca0 <bus_fault.constprop.0+0xa4>)
60004c5a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004c5c:	0559      	lsls	r1, r3, #21
60004c5e:	d504      	bpl.n	60004c6a <bus_fault.constprop.0+0x6e>
		PR_FAULT_INFO("  Imprecise data bus error");
60004c60:	4815      	ldr	r0, [pc, #84]	; (60004cb8 <bus_fault.constprop.0+0xbc>)
60004c62:	2145      	movs	r1, #69	; 0x45
60004c64:	f005 ff3c 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
60004c68:	201a      	movs	r0, #26
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
60004c6a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004c6c:	05da      	lsls	r2, r3, #23
60004c6e:	d50e      	bpl.n	60004c8e <bus_fault.constprop.0+0x92>
		PR_FAULT_INFO("  Instruction bus error");
60004c70:	4812      	ldr	r0, [pc, #72]	; (60004cbc <bus_fault.constprop.0+0xc0>)
60004c72:	2145      	movs	r1, #69	; 0x45
60004c74:	f005 ff34 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
60004c78:	201b      	movs	r0, #27
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
60004c7a:	4a09      	ldr	r2, [pc, #36]	; (60004ca0 <bus_fault.constprop.0+0xa4>)
60004c7c:	6a93      	ldr	r3, [r2, #40]	; 0x28
60004c7e:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
60004c82:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
60004c84:	2300      	movs	r3, #0
60004c86:	702b      	strb	r3, [r5, #0]
}
60004c88:	bd70      	pop	{r4, r5, r6, pc}
	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
60004c8a:	2016      	movs	r0, #22
60004c8c:	e7c6      	b.n	60004c1c <bus_fault.constprop.0+0x20>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
60004c8e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004c90:	049b      	lsls	r3, r3, #18
60004c92:	d5f2      	bpl.n	60004c7a <bus_fault.constprop.0+0x7e>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
60004c94:	480a      	ldr	r0, [pc, #40]	; (60004cc0 <bus_fault.constprop.0+0xc4>)
60004c96:	2145      	movs	r1, #69	; 0x45
60004c98:	f005 ff22 	bl	6000aae0 <z_log_minimal_printk>
		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
60004c9c:	201c      	movs	r0, #28
60004c9e:	e7ec      	b.n	60004c7a <bus_fault.constprop.0+0x7e>
60004ca0:	e000ed00 	.word	0xe000ed00
60004ca4:	6000c979 	.word	0x6000c979
60004ca8:	6000c994 	.word	0x6000c994
60004cac:	6000c73a 	.word	0x6000c73a
60004cb0:	6000c9aa 	.word	0x6000c9aa
60004cb4:	6000c9c8 	.word	0x6000c9c8
60004cb8:	6000c9e2 	.word	0x6000c9e2
60004cbc:	6000ca02 	.word	0x6000ca02
60004cc0:	6000c7ae 	.word	0x6000c7ae

60004cc4 <z_arm_fault>:
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
60004cc4:	4b72      	ldr	r3, [pc, #456]	; (60004e90 <z_arm_fault+0x1cc>)
{
60004cc6:	b570      	push	{r4, r5, r6, lr}
60004cc8:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
60004cca:	6858      	ldr	r0, [r3, #4]
{
60004ccc:	b08a      	sub	sp, #40	; 0x28
60004cce:	2600      	movs	r6, #0
60004cd0:	f3c0 0308 	ubfx	r3, r0, #0, #9
60004cd4:	f386 8811 	msr	BASEPRI, r6
60004cd8:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
60004cdc:	f002 447f 	and.w	r4, r2, #4278190080	; 0xff000000
60004ce0:	f1b4 4f7f 	cmp.w	r4, #4278190080	; 0xff000000
60004ce4:	d107      	bne.n	60004cf6 <z_arm_fault+0x32>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
60004ce6:	f002 040c 	and.w	r4, r2, #12
60004cea:	2c08      	cmp	r4, #8
60004cec:	d112      	bne.n	60004d14 <z_arm_fault+0x50>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
60004cee:	2145      	movs	r1, #69	; 0x45
60004cf0:	4868      	ldr	r0, [pc, #416]	; (60004e94 <z_arm_fault+0x1d0>)
60004cf2:	f005 fef5 	bl	6000aae0 <z_log_minimal_printk>

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
60004cf6:	4968      	ldr	r1, [pc, #416]	; (60004e98 <z_arm_fault+0x1d4>)
60004cf8:	f240 433e 	movw	r3, #1086	; 0x43e
60004cfc:	4a67      	ldr	r2, [pc, #412]	; (60004e9c <z_arm_fault+0x1d8>)
60004cfe:	4868      	ldr	r0, [pc, #416]	; (60004ea0 <z_arm_fault+0x1dc>)
60004d00:	f005 fede 	bl	6000aac0 <assert_print>
60004d04:	4867      	ldr	r0, [pc, #412]	; (60004ea4 <z_arm_fault+0x1e0>)
60004d06:	f005 fedb 	bl	6000aac0 <assert_print>
60004d0a:	f240 413e 	movw	r1, #1086	; 0x43e
			__ASSERT(0,
60004d0e:	4863      	ldr	r0, [pc, #396]	; (60004e9c <z_arm_fault+0x1d8>)
60004d10:	f005 fecf 	bl	6000aab2 <assert_post_action>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
60004d14:	0714      	lsls	r4, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
60004d16:	bf4c      	ite	mi
60004d18:	460d      	movmi	r5, r1
			*nested_exc = true;
60004d1a:	2601      	movpl	r6, #1
	__ASSERT(esf != NULL,
60004d1c:	2d00      	cmp	r5, #0
60004d1e:	d0ea      	beq.n	60004cf6 <z_arm_fault+0x32>
	*recoverable = false;
60004d20:	2400      	movs	r4, #0
	switch (fault) {
60004d22:	1eda      	subs	r2, r3, #3
	*recoverable = false;
60004d24:	f88d 4007 	strb.w	r4, [sp, #7]
	switch (fault) {
60004d28:	2a09      	cmp	r2, #9
60004d2a:	f200 809e 	bhi.w	60004e6a <z_arm_fault+0x1a6>
60004d2e:	e8df f002 	tbb	[pc, r2]
60004d32:	9105      	.short	0x9105
60004d34:	9c9c7495 	.word	0x9c9c7495
60004d38:	999c9c9c 	.word	0x999c9c9c
	PR_FAULT_INFO("***** HARD FAULT *****");
60004d3c:	2145      	movs	r1, #69	; 0x45
60004d3e:	485a      	ldr	r0, [pc, #360]	; (60004ea8 <z_arm_fault+0x1e4>)
60004d40:	f005 fece 	bl	6000aae0 <z_log_minimal_printk>
	*recoverable = false;
60004d44:	f88d 4007 	strb.w	r4, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
60004d48:	4c51      	ldr	r4, [pc, #324]	; (60004e90 <z_arm_fault+0x1cc>)
60004d4a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
60004d4c:	079a      	lsls	r2, r3, #30
60004d4e:	d505      	bpl.n	60004d5c <z_arm_fault+0x98>
		PR_EXC("  Bus fault on vector table read");
60004d50:	2145      	movs	r1, #69	; 0x45
60004d52:	4856      	ldr	r0, [pc, #344]	; (60004eac <z_arm_fault+0x1e8>)
	PR_FAULT_INFO(
60004d54:	f005 fec4 	bl	6000aae0 <z_log_minimal_printk>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
60004d58:	2400      	movs	r4, #0
60004d5a:	e029      	b.n	60004db0 <z_arm_fault+0xec>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
60004d5c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
60004d5e:	2b00      	cmp	r3, #0
60004d60:	da02      	bge.n	60004d68 <z_arm_fault+0xa4>
		PR_EXC("  Debug event");
60004d62:	2145      	movs	r1, #69	; 0x45
60004d64:	4852      	ldr	r0, [pc, #328]	; (60004eb0 <z_arm_fault+0x1ec>)
60004d66:	e7f5      	b.n	60004d54 <z_arm_fault+0x90>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
60004d68:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
60004d6a:	005b      	lsls	r3, r3, #1
60004d6c:	d565      	bpl.n	60004e3a <z_arm_fault+0x176>
		PR_EXC("  Fault escalation (see below)");
60004d6e:	2145      	movs	r1, #69	; 0x45
60004d70:	4850      	ldr	r0, [pc, #320]	; (60004eb4 <z_arm_fault+0x1f0>)
60004d72:	f005 feb5 	bl	6000aae0 <z_log_minimal_printk>
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
60004d76:	6963      	ldr	r3, [r4, #20]
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
60004d78:	69aa      	ldr	r2, [r5, #24]
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
60004d7a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
60004d7e:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
60004d80:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60004d84:	f3bf 8f6f 	isb	sy
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
60004d88:	6963      	ldr	r3, [r4, #20]
	uint16_t fault_insn = *(ret_addr - 1);
60004d8a:	f832 2c02 	ldrh.w	r2, [r2, #-2]
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
60004d8e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
60004d92:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
60004d94:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60004d98:	f3bf 8f6f 	isb	sy
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
60004d9c:	f64d 7302 	movw	r3, #57090	; 0xdf02
60004da0:	429a      	cmp	r2, r3
60004da2:	d121      	bne.n	60004de8 <z_arm_fault+0x124>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
60004da4:	682a      	ldr	r2, [r5, #0]
60004da6:	2145      	movs	r1, #69	; 0x45
60004da8:	4843      	ldr	r0, [pc, #268]	; (60004eb8 <z_arm_fault+0x1f4>)
60004daa:	f005 fe99 	bl	6000aae0 <z_log_minimal_printk>
			reason = esf->basic.r0;
60004dae:	682c      	ldr	r4, [r5, #0]
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
60004db0:	f89d 3007 	ldrb.w	r3, [sp, #7]
60004db4:	b9b3      	cbnz	r3, 60004de4 <z_arm_fault+0x120>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
60004db6:	2220      	movs	r2, #32
60004db8:	4629      	mov	r1, r5
60004dba:	a802      	add	r0, sp, #8
60004dbc:	f005 fedc 	bl	6000ab78 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
60004dc0:	9b09      	ldr	r3, [sp, #36]	; 0x24
60004dc2:	2e00      	cmp	r6, #0
60004dc4:	d05e      	beq.n	60004e84 <z_arm_fault+0x1c0>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
60004dc6:	f3c3 0208 	ubfx	r2, r3, #0, #9
60004dca:	b922      	cbnz	r2, 60004dd6 <z_arm_fault+0x112>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
60004dcc:	ea6f 2353 	mvn.w	r3, r3, lsr #9
60004dd0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
60004dd4:	9309      	str	r3, [sp, #36]	; 0x24
	}

	if (IS_ENABLED(CONFIG_SIMPLIFIED_EXCEPTION_CODES) && (reason >= K_ERR_ARCH_START)) {
		reason = K_ERR_CPU_EXCEPTION;
60004dd6:	2c10      	cmp	r4, #16
	}

	z_arm_fatal_error(reason, &esf_copy);
60004dd8:	a902      	add	r1, sp, #8
60004dda:	bf34      	ite	cc
60004ddc:	4620      	movcc	r0, r4
60004dde:	2000      	movcs	r0, #0
60004de0:	f7ff fcca 	bl	60004778 <z_arm_fatal_error>
}
60004de4:	b00a      	add	sp, #40	; 0x28
60004de6:	bd70      	pop	{r4, r5, r6, pc}
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
60004de8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004dea:	b2db      	uxtb	r3, r3
60004dec:	b13b      	cbz	r3, 60004dfe <z_arm_fault+0x13a>
			reason = mem_manage_fault(esf, 1, recoverable);
60004dee:	f10d 0207 	add.w	r2, sp, #7
60004df2:	2101      	movs	r1, #1
		reason = mem_manage_fault(esf, 0, recoverable);
60004df4:	4628      	mov	r0, r5
60004df6:	f7ff fe15 	bl	60004a24 <mem_manage_fault>
60004dfa:	4604      	mov	r4, r0
		break;
60004dfc:	e7d8      	b.n	60004db0 <z_arm_fault+0xec>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
60004dfe:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004e00:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
60004e04:	d005      	beq.n	60004e12 <z_arm_fault+0x14e>
			reason = bus_fault(esf, 1, recoverable);
60004e06:	f10d 0107 	add.w	r1, sp, #7
60004e0a:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
60004e0c:	f7ff fef6 	bl	60004bfc <bus_fault.constprop.0>
60004e10:	e7f3      	b.n	60004dfa <z_arm_fault+0x136>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
60004e12:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60004e14:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
60004e18:	d302      	bcc.n	60004e20 <z_arm_fault+0x15c>
		reason = usage_fault(esf);
60004e1a:	f7ff fe9d 	bl	60004b58 <usage_fault.constprop.0>
60004e1e:	e7ec      	b.n	60004dfa <z_arm_fault+0x136>
			__ASSERT(0,
60004e20:	4926      	ldr	r1, [pc, #152]	; (60004ebc <z_arm_fault+0x1f8>)
60004e22:	f44f 7344 	mov.w	r3, #784	; 0x310
60004e26:	4a1d      	ldr	r2, [pc, #116]	; (60004e9c <z_arm_fault+0x1d8>)
60004e28:	481d      	ldr	r0, [pc, #116]	; (60004ea0 <z_arm_fault+0x1dc>)
60004e2a:	f005 fe49 	bl	6000aac0 <assert_print>
60004e2e:	4824      	ldr	r0, [pc, #144]	; (60004ec0 <z_arm_fault+0x1fc>)
60004e30:	f005 fe46 	bl	6000aac0 <assert_print>
60004e34:	f44f 7144 	mov.w	r1, #784	; 0x310
60004e38:	e769      	b.n	60004d0e <z_arm_fault+0x4a>
		__ASSERT(0,
60004e3a:	4920      	ldr	r1, [pc, #128]	; (60004ebc <z_arm_fault+0x1f8>)
60004e3c:	f44f 7345 	mov.w	r3, #788	; 0x314
60004e40:	4a16      	ldr	r2, [pc, #88]	; (60004e9c <z_arm_fault+0x1d8>)
60004e42:	4817      	ldr	r0, [pc, #92]	; (60004ea0 <z_arm_fault+0x1dc>)
60004e44:	f005 fe3c 	bl	6000aac0 <assert_print>
60004e48:	481e      	ldr	r0, [pc, #120]	; (60004ec4 <z_arm_fault+0x200>)
60004e4a:	f005 fe39 	bl	6000aac0 <assert_print>
60004e4e:	f44f 7145 	mov.w	r1, #788	; 0x314
60004e52:	e75c      	b.n	60004d0e <z_arm_fault+0x4a>
		reason = mem_manage_fault(esf, 0, recoverable);
60004e54:	f10d 0207 	add.w	r2, sp, #7
60004e58:	2100      	movs	r1, #0
60004e5a:	e7cb      	b.n	60004df4 <z_arm_fault+0x130>
		reason = bus_fault(esf, 0, recoverable);
60004e5c:	f10d 0107 	add.w	r1, sp, #7
60004e60:	2000      	movs	r0, #0
60004e62:	e7d3      	b.n	60004e0c <z_arm_fault+0x148>
	PR_FAULT_INFO(
60004e64:	2145      	movs	r1, #69	; 0x45
60004e66:	4818      	ldr	r0, [pc, #96]	; (60004ec8 <z_arm_fault+0x204>)
60004e68:	e774      	b.n	60004d54 <z_arm_fault+0x90>
	PR_FAULT_INFO("***** %s %d) *****",
60004e6a:	f410 7ff8 	tst.w	r0, #496	; 0x1f0
60004e6e:	4917      	ldr	r1, [pc, #92]	; (60004ecc <z_arm_fault+0x208>)
60004e70:	4a17      	ldr	r2, [pc, #92]	; (60004ed0 <z_arm_fault+0x20c>)
60004e72:	f1a3 0310 	sub.w	r3, r3, #16
60004e76:	bf08      	it	eq
60004e78:	460a      	moveq	r2, r1
60004e7a:	4816      	ldr	r0, [pc, #88]	; (60004ed4 <z_arm_fault+0x210>)
60004e7c:	2145      	movs	r1, #69	; 0x45
60004e7e:	f005 fe2f 	bl	6000aae0 <z_log_minimal_printk>
}
60004e82:	e769      	b.n	60004d58 <z_arm_fault+0x94>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
60004e84:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
60004e88:	f023 0301 	bic.w	r3, r3, #1
60004e8c:	e7a2      	b.n	60004dd4 <z_arm_fault+0x110>
60004e8e:	bf00      	nop
60004e90:	e000ed00 	.word	0xe000ed00
60004e94:	6000ca4d 	.word	0x6000ca4d
60004e98:	6000ca7d 	.word	0x6000ca7d
60004e9c:	6000c7e2 	.word	0x6000c7e2
60004ea0:	6000c68a 	.word	0x6000c68a
60004ea4:	6000ca90 	.word	0x6000ca90
60004ea8:	6000cace 	.word	0x6000cace
60004eac:	6000caea 	.word	0x6000caea
60004eb0:	6000cb10 	.word	0x6000cb10
60004eb4:	6000cb23 	.word	0x6000cb23
60004eb8:	6000cb47 	.word	0x6000cb47
60004ebc:	6000d5b3 	.word	0x6000d5b3
60004ec0:	6000cb68 	.word	0x6000cb68
60004ec4:	6000cb8c 	.word	0x6000cb8c
60004ec8:	6000cbbc 	.word	0x6000cbbc
60004ecc:	6000ca1f 	.word	0x6000ca1f
60004ed0:	6000ca34 	.word	0x6000ca34
60004ed4:	6000cbe5 	.word	0x6000cbe5

60004ed8 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
60004ed8:	4a02      	ldr	r2, [pc, #8]	; (60004ee4 <z_arm_fault_init+0xc>)
60004eda:	6953      	ldr	r3, [r2, #20]
60004edc:	f043 0310 	orr.w	r3, r3, #16
60004ee0:	6153      	str	r3, [r2, #20]
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
60004ee2:	4770      	bx	lr
60004ee4:	e000ed00 	.word	0xe000ed00

60004ee8 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
60004ee8:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
60004eec:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
60004ef0:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
60004ef2:	4672      	mov	r2, lr
	bl z_arm_fault
60004ef4:	f7ff fee6 	bl	60004cc4 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
60004ef8:	bd01      	pop	{r0, pc}
60004efa:	bf00      	nop

60004efc <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
60004efc:	2300      	movs	r3, #0
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
60004efe:	4804      	ldr	r0, [pc, #16]	; (60004f10 <z_arm_interrupt_init+0x14>)
60004f00:	2110      	movs	r1, #16
60004f02:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
60004f04:	3301      	adds	r3, #1
60004f06:	2b8e      	cmp	r3, #142	; 0x8e
60004f08:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
60004f0c:	d1f9      	bne.n	60004f02 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
60004f0e:	4770      	bx	lr
60004f10:	e000e100 	.word	0xe000e100

60004f14 <__start>:
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
60004f14:	f005 fde2 	bl	6000aadc <z_arm_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
60004f18:	2010      	movs	r0, #16
    msr BASEPRI, r0
60004f1a:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
60004f1e:	4808      	ldr	r0, [pc, #32]	; (60004f40 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
60004f20:	f44f 6104 	mov.w	r1, #2112	; 0x840
    adds r0, r0, r1
60004f24:	1840      	adds	r0, r0, r1
    msr PSP, r0
60004f26:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
60004f2a:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
60004f2e:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
60004f30:	4308      	orrs	r0, r1
    msr CONTROL, r0
60004f32:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
60004f36:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
60004f3a:	f7ff fc8f 	bl	6000485c <z_arm_prep_c>
60004f3e:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
60004f40:	80001b80 	.word	0x80001b80

60004f44 <z_impl_k_thread_abort>:
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
60004f44:	4b08      	ldr	r3, [pc, #32]	; (60004f68 <z_impl_k_thread_abort+0x24>)
60004f46:	689b      	ldr	r3, [r3, #8]
60004f48:	4283      	cmp	r3, r0
60004f4a:	d10b      	bne.n	60004f64 <z_impl_k_thread_abort+0x20>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
60004f4c:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
60004f50:	b143      	cbz	r3, 60004f64 <z_impl_k_thread_abort+0x20>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
60004f52:	4b06      	ldr	r3, [pc, #24]	; (60004f6c <z_impl_k_thread_abort+0x28>)
60004f54:	685a      	ldr	r2, [r3, #4]
60004f56:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
60004f5a:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
60004f5c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
60004f5e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
60004f62:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
60004f64:	f005 b8c8 	b.w	6000a0f8 <z_thread_abort>
60004f68:	800016c8 	.word	0x800016c8
60004f6c:	e000ed00 	.word	0xe000ed00

60004f70 <z_arm_configure_static_mpu_regions>:
	 * into account the unused SRAM area, as well.
	 */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_static_mpu_regions(static_regions,
60004f70:	4b02      	ldr	r3, [pc, #8]	; (60004f7c <z_arm_configure_static_mpu_regions+0xc>)
60004f72:	2102      	movs	r1, #2
60004f74:	4a02      	ldr	r2, [pc, #8]	; (60004f80 <z_arm_configure_static_mpu_regions+0x10>)
60004f76:	4803      	ldr	r0, [pc, #12]	; (60004f84 <z_arm_configure_static_mpu_regions+0x14>)
60004f78:	f000 b87e 	b.w	60005078 <arm_core_mpu_configure_static_mpu_regions>
60004f7c:	82000000 	.word	0x82000000
60004f80:	80000000 	.word	0x80000000
60004f84:	6000bb04 	.word	0x6000bb04

60004f88 <z_arm_configure_dynamic_mpu_regions>:
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
60004f88:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
	dynamic_regions[region_num].size = guard_size;
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
60004f8c:	2140      	movs	r1, #64	; 0x40
	dynamic_regions[region_num].start = guard_start;
60004f8e:	4b05      	ldr	r3, [pc, #20]	; (60004fa4 <z_arm_configure_dynamic_mpu_regions+0x1c>)
		guard_start = thread->stack_info.start - guard_size;
60004f90:	3a40      	subs	r2, #64	; 0x40

	/* Configure the dynamic MPU regions */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
60004f92:	4618      	mov	r0, r3
	dynamic_regions[region_num].start = guard_start;
60004f94:	601a      	str	r2, [r3, #0]
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
60004f96:	4a04      	ldr	r2, [pc, #16]	; (60004fa8 <z_arm_configure_dynamic_mpu_regions+0x20>)
60004f98:	e9c3 1201 	strd	r1, r2, [r3, #4]
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
60004f9c:	2101      	movs	r1, #1
60004f9e:	f000 b891 	b.w	600050c4 <arm_core_mpu_configure_dynamic_mpu_regions>
60004fa2:	bf00      	nop
60004fa4:	80000b38 	.word	0x80000b38
60004fa8:	150b0000 	.word	0x150b0000

60004fac <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
60004fac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
60004fae:	2500      	movs	r5, #0
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
60004fb0:	4e23      	ldr	r6, [pc, #140]	; (60005040 <mpu_configure_regions+0x94>)
60004fb2:	428d      	cmp	r5, r1
60004fb4:	da0f      	bge.n	60004fd6 <mpu_configure_regions+0x2a>
		if (regions[i].size == 0U) {
60004fb6:	6844      	ldr	r4, [r0, #4]
60004fb8:	2c00      	cmp	r4, #0
60004fba:	d03e      	beq.n	6000503a <mpu_configure_regions+0x8e>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
60004fbc:	b19b      	cbz	r3, 60004fe6 <mpu_configure_regions+0x3a>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1U)) == 0U)
60004fbe:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
60004fc2:	ea14 0f0c 	tst.w	r4, ip
60004fc6:	d008      	beq.n	60004fda <mpu_configure_regions+0x2e>
				(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
60004fc8:	462a      	mov	r2, r5
60004fca:	2145      	movs	r1, #69	; 0x45
60004fcc:	481d      	ldr	r0, [pc, #116]	; (60005044 <mpu_configure_regions+0x98>)
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
60004fce:	f005 fd87 	bl	6000aae0 <z_log_minimal_printk>
			return -EINVAL;
60004fd2:	f06f 0215 	mvn.w	r2, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
60004fd6:	4610      	mov	r0, r2
60004fd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		&&
60004fda:	2c1f      	cmp	r4, #31
60004fdc:	d9f4      	bls.n	60004fc8 <mpu_configure_regions+0x1c>
		((part->start & (part->size - 1U)) == 0U);
60004fde:	6807      	ldr	r7, [r0, #0]
		&&
60004fe0:	ea1c 0f07 	tst.w	ip, r7
60004fe4:	d1f0      	bne.n	60004fc8 <mpu_configure_regions+0x1c>
 * to that power-of-two value.
 */
static inline uint32_t size_to_mpu_rasr_size(uint32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
60004fe6:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, &regions[i]);
60004fe8:	fa5f fe82 	uxtb.w	lr, r2
	region_conf.base = new_region->start;
60004fec:	6807      	ldr	r7, [r0, #0]
#if defined(CONFIG_CPU_AARCH32_CORTEX_R)
	(void) size;

	p_attr->rasr = attr->rasr_attr;
#else
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
60004fee:	f8d0 c008 	ldr.w	ip, [r0, #8]
	if (size <= 32U) {
60004ff2:	d910      	bls.n	60005016 <mpu_configure_regions+0x6a>
	if (size > (1UL << 31)) {
60004ff4:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
60004ff8:	d80f      	bhi.n	6000501a <mpu_configure_regions+0x6e>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
60004ffa:	3c01      	subs	r4, #1
60004ffc:	fab4 f484 	clz	r4, r4
60005000:	f1c4 041f 	rsb	r4, r4, #31
60005004:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1U)) {
60005006:	f1be 0f0f 	cmp.w	lr, #15
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
6000500a:	ea4c 0c04 	orr.w	ip, ip, r4
6000500e:	d906      	bls.n	6000501e <mpu_configure_regions+0x72>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
60005010:	2145      	movs	r1, #69	; 0x45
60005012:	480d      	ldr	r0, [pc, #52]	; (60005048 <mpu_configure_regions+0x9c>)
60005014:	e7db      	b.n	60004fce <mpu_configure_regions+0x22>
		return REGION_32B;
60005016:	2408      	movs	r4, #8
60005018:	e7f5      	b.n	60005006 <mpu_configure_regions+0x5a>
		return REGION_4G;
6000501a:	243e      	movs	r4, #62	; 0x3e
6000501c:	e7f3      	b.n	60005006 <mpu_configure_regions+0x5a>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
6000501e:	f027 041f 	bic.w	r4, r7, #31
60005022:	f8c6 2098 	str.w	r2, [r6, #152]	; 0x98
				| MPU_RBAR_VALID_Msk | index;
60005026:	4314      	orrs	r4, r2
		reg_index++;
60005028:	3201      	adds	r2, #1
6000502a:	f044 0410 	orr.w	r4, r4, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
6000502e:	f8c6 409c 	str.w	r4, [r6, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
60005032:	f04c 0401 	orr.w	r4, ip, #1
60005036:	f8c6 40a0 	str.w	r4, [r6, #160]	; 0xa0
	for (i = 0; i < regions_num; i++) {
6000503a:	3501      	adds	r5, #1
6000503c:	300c      	adds	r0, #12
6000503e:	e7b8      	b.n	60004fb2 <mpu_configure_regions+0x6>
60005040:	e000ed00 	.word	0xe000ed00
60005044:	6000cc01 	.word	0x6000cc01
60005048:	6000cc29 	.word	0x6000cc29

6000504c <arm_core_mpu_enable>:
	 * background region for privileged software access if desired.
	 */
#if defined(CONFIG_MPU_DISABLE_BACKGROUND_MAP)
	MPU->CTRL = MPU_CTRL_ENABLE_Msk;
#else
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
6000504c:	4b04      	ldr	r3, [pc, #16]	; (60005060 <arm_core_mpu_enable+0x14>)
6000504e:	2205      	movs	r2, #5
60005050:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
60005054:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60005058:	f3bf 8f6f 	isb	sy
#endif

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
6000505c:	4770      	bx	lr
6000505e:	bf00      	nop
60005060:	e000ed00 	.word	0xe000ed00

60005064 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
60005064:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
60005068:	4b02      	ldr	r3, [pc, #8]	; (60005074 <arm_core_mpu_disable+0x10>)
6000506a:	2200      	movs	r2, #0
6000506c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
60005070:	4770      	bx	lr
60005072:	bf00      	nop
60005074:	e000ed00 	.word	0xe000ed00

60005078 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	*static_regions, const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
60005078:	b538      	push	{r3, r4, r5, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
6000507a:	4d0d      	ldr	r5, [pc, #52]	; (600050b0 <arm_core_mpu_configure_static_mpu_regions+0x38>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
6000507c:	2301      	movs	r3, #1
6000507e:	460c      	mov	r4, r1
60005080:	782a      	ldrb	r2, [r5, #0]
60005082:	f7ff ff93 	bl	60004fac <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
60005086:	7028      	strb	r0, [r5, #0]
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
60005088:	3016      	adds	r0, #22
6000508a:	d10f      	bne.n	600050ac <arm_core_mpu_configure_static_mpu_regions+0x34>
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
6000508c:	f44f 738d 	mov.w	r3, #282	; 0x11a
60005090:	4a08      	ldr	r2, [pc, #32]	; (600050b4 <arm_core_mpu_configure_static_mpu_regions+0x3c>)
60005092:	4909      	ldr	r1, [pc, #36]	; (600050b8 <arm_core_mpu_configure_static_mpu_regions+0x40>)
60005094:	4809      	ldr	r0, [pc, #36]	; (600050bc <arm_core_mpu_configure_static_mpu_regions+0x44>)
60005096:	f005 fd13 	bl	6000aac0 <assert_print>
6000509a:	4621      	mov	r1, r4
6000509c:	4808      	ldr	r0, [pc, #32]	; (600050c0 <arm_core_mpu_configure_static_mpu_regions+0x48>)
6000509e:	f005 fd0f 	bl	6000aac0 <assert_print>
600050a2:	f44f 718d 	mov.w	r1, #282	; 0x11a
600050a6:	4803      	ldr	r0, [pc, #12]	; (600050b4 <arm_core_mpu_configure_static_mpu_regions+0x3c>)
600050a8:	f005 fd03 	bl	6000aab2 <assert_post_action>
			regions_num);
	}
}
600050ac:	bd38      	pop	{r3, r4, r5, pc}
600050ae:	bf00      	nop
600050b0:	80001708 	.word	0x80001708
600050b4:	6000cc54 	.word	0x6000cc54
600050b8:	6000d5b3 	.word	0x6000d5b3
600050bc:	6000c68a 	.word	0x6000c68a
600050c0:	6000cc8b 	.word	0x6000cc8b

600050c4 <arm_core_mpu_configure_dynamic_mpu_regions>:

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
600050c4:	4a12      	ldr	r2, [pc, #72]	; (60005110 <arm_core_mpu_configure_dynamic_mpu_regions+0x4c>)
600050c6:	2300      	movs	r3, #0
/**
 * @brief configure dynamic MPU regions.
 */
void arm_core_mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	*dynamic_regions, uint8_t regions_num)
{
600050c8:	b510      	push	{r4, lr}
600050ca:	7812      	ldrb	r2, [r2, #0]
600050cc:	460c      	mov	r4, r1
600050ce:	f7ff ff6d 	bl	60004fac <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
600050d2:	f110 0f16 	cmn.w	r0, #22
600050d6:	d004      	beq.n	600050e2 <arm_core_mpu_configure_dynamic_mpu_regions+0x1e>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
600050d8:	4b0e      	ldr	r3, [pc, #56]	; (60005114 <arm_core_mpu_configure_dynamic_mpu_regions+0x50>)
  MPU->RASR = 0U;
600050da:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
600050dc:	280f      	cmp	r0, #15
600050de:	dd10      	ble.n	60005102 <arm_core_mpu_configure_dynamic_mpu_regions+0x3e>
		== -EINVAL) {

		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
			regions_num);
	}
}
600050e0:	bd10      	pop	{r4, pc}
		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
600050e2:	f240 1339 	movw	r3, #313	; 0x139
600050e6:	4a0c      	ldr	r2, [pc, #48]	; (60005118 <arm_core_mpu_configure_dynamic_mpu_regions+0x54>)
600050e8:	490c      	ldr	r1, [pc, #48]	; (6000511c <arm_core_mpu_configure_dynamic_mpu_regions+0x58>)
600050ea:	480d      	ldr	r0, [pc, #52]	; (60005120 <arm_core_mpu_configure_dynamic_mpu_regions+0x5c>)
600050ec:	f005 fce8 	bl	6000aac0 <assert_print>
600050f0:	4621      	mov	r1, r4
600050f2:	480c      	ldr	r0, [pc, #48]	; (60005124 <arm_core_mpu_configure_dynamic_mpu_regions+0x60>)
600050f4:	f005 fce4 	bl	6000aac0 <assert_print>
600050f8:	f240 1139 	movw	r1, #313	; 0x139
600050fc:	4806      	ldr	r0, [pc, #24]	; (60005118 <arm_core_mpu_configure_dynamic_mpu_regions+0x54>)
600050fe:	f005 fcd8 	bl	6000aab2 <assert_post_action>
  MPU->RNR = rnr;
60005102:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
60005106:	3001      	adds	r0, #1
  MPU->RASR = 0U;
60005108:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
6000510c:	e7e6      	b.n	600050dc <arm_core_mpu_configure_dynamic_mpu_regions+0x18>
6000510e:	bf00      	nop
60005110:	80001708 	.word	0x80001708
60005114:	e000ed00 	.word	0xe000ed00
60005118:	6000cc54 	.word	0x6000cc54
6000511c:	6000d5b3 	.word	0x6000d5b3
60005120:	6000c68a 	.word	0x6000c68a
60005124:	6000ccb7 	.word	0x6000ccb7

60005128 <z_arm_mpu_init>:
 */
int z_arm_mpu_init(void)
{
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
60005128:	4837      	ldr	r0, [pc, #220]	; (60005208 <z_arm_mpu_init+0xe0>)
{
6000512a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (mpu_config.num_regions > get_num_regions()) {
6000512c:	6804      	ldr	r4, [r0, #0]
6000512e:	2c10      	cmp	r4, #16
60005130:	d910      	bls.n	60005154 <z_arm_mpu_init+0x2c>
		 * what is supported by hardware. As this operation
		 * is executed during system (pre-kernel) initialization,
		 * we want to ensure we can detect an attempt to
		 * perform invalid configuration.
		 */
		__ASSERT(0,
60005132:	f240 1351 	movw	r3, #337	; 0x151
60005136:	4a35      	ldr	r2, [pc, #212]	; (6000520c <z_arm_mpu_init+0xe4>)
60005138:	4935      	ldr	r1, [pc, #212]	; (60005210 <z_arm_mpu_init+0xe8>)
6000513a:	4836      	ldr	r0, [pc, #216]	; (60005214 <z_arm_mpu_init+0xec>)
6000513c:	f005 fcc0 	bl	6000aac0 <assert_print>
60005140:	4621      	mov	r1, r4
60005142:	2210      	movs	r2, #16
60005144:	4834      	ldr	r0, [pc, #208]	; (60005218 <z_arm_mpu_init+0xf0>)
60005146:	f005 fcbb 	bl	6000aac0 <assert_print>
6000514a:	f240 1151 	movw	r1, #337	; 0x151
	defined(CONFIG_CPU_CORTEX_M4)
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos == 8,
		"Invalid number of MPU regions\n");
#elif defined(NUM_MPU_REGIONS)
	__ASSERT(
6000514e:	482f      	ldr	r0, [pc, #188]	; (6000520c <z_arm_mpu_init+0xe4>)
60005150:	f005 fcaf 	bl	6000aab2 <assert_post_action>
	arm_core_mpu_disable();
60005154:	f7ff ff86 	bl	60005064 <arm_core_mpu_disable>
	if (SCB->CCR & SCB_CCR_DC_Msk) {
60005158:	4a30      	ldr	r2, [pc, #192]	; (6000521c <z_arm_mpu_init+0xf4>)
6000515a:	6953      	ldr	r3, [r2, #20]
6000515c:	03db      	lsls	r3, r3, #15
6000515e:	d51e      	bpl.n	6000519e <z_arm_mpu_init+0x76>
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
60005160:	2300      	movs	r3, #0
60005162:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
60005166:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
6000516a:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
                                            /* clean & invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
6000516e:	f643 75e0 	movw	r5, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
60005172:	f3c3 04c9 	ubfx	r4, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
60005176:	f3c3 334e 	ubfx	r3, r3, #13, #15
6000517a:	015b      	lsls	r3, r3, #5
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
6000517c:	ea03 0705 	and.w	r7, r3, r5
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
60005180:	4621      	mov	r1, r4
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
60005182:	ea47 7681 	orr.w	r6, r7, r1, lsl #30
                       ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
60005186:	3901      	subs	r1, #1
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
60005188:	f8c2 6274 	str.w	r6, [r2, #628]	; 0x274
      } while (ways-- != 0U);
6000518c:	d2f9      	bcs.n	60005182 <z_arm_mpu_init+0x5a>
    } while(sets-- != 0U);
6000518e:	3b20      	subs	r3, #32
60005190:	f113 0f20 	cmn.w	r3, #32
60005194:	d1f2      	bne.n	6000517c <z_arm_mpu_init+0x54>
60005196:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
6000519a:	f3bf 8f6f 	isb	sy
6000519e:	e9d0 4000 	ldrd	r4, r0, [r0]
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
600051a2:	2200      	movs	r2, #0
600051a4:	491d      	ldr	r1, [pc, #116]	; (6000521c <z_arm_mpu_init+0xf4>)
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
600051a6:	42a2      	cmp	r2, r4
600051a8:	f100 000c 	add.w	r0, r0, #12
600051ac:	d116      	bne.n	600051dc <z_arm_mpu_init+0xb4>
	static_regions_num = mpu_config.num_regions;
600051ae:	4b1c      	ldr	r3, [pc, #112]	; (60005220 <z_arm_mpu_init+0xf8>)
600051b0:	701a      	strb	r2, [r3, #0]
	arm_core_mpu_enable();
600051b2:	f7ff ff4b 	bl	6000504c <arm_core_mpu_enable>
	__ASSERT(
600051b6:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
600051ba:	f3c3 2307 	ubfx	r3, r3, #8, #8
600051be:	2b10      	cmp	r3, #16
600051c0:	d01f      	beq.n	60005202 <z_arm_mpu_init+0xda>
600051c2:	4918      	ldr	r1, [pc, #96]	; (60005224 <z_arm_mpu_init+0xfc>)
600051c4:	f240 13bb 	movw	r3, #443	; 0x1bb
600051c8:	4a10      	ldr	r2, [pc, #64]	; (6000520c <z_arm_mpu_init+0xe4>)
600051ca:	4812      	ldr	r0, [pc, #72]	; (60005214 <z_arm_mpu_init+0xec>)
600051cc:	f005 fc78 	bl	6000aac0 <assert_print>
600051d0:	4815      	ldr	r0, [pc, #84]	; (60005228 <z_arm_mpu_init+0x100>)
600051d2:	f005 fc75 	bl	6000aac0 <assert_print>
600051d6:	f240 11bb 	movw	r1, #443	; 0x1bb
600051da:	e7b8      	b.n	6000514e <z_arm_mpu_init+0x26>
600051dc:	f8c1 2098 	str.w	r2, [r1, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
600051e0:	f850 3c0c 	ldr.w	r3, [r0, #-12]
600051e4:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
600051e8:	4313      	orrs	r3, r2
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
600051ea:	3201      	adds	r2, #1
600051ec:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
600051f0:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
600051f4:	f850 3c04 	ldr.w	r3, [r0, #-4]
600051f8:	f043 0301 	orr.w	r3, r3, #1
600051fc:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
60005200:	e7d1      	b.n	600051a6 <z_arm_mpu_init+0x7e>
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
}
60005202:	2000      	movs	r0, #0
60005204:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
60005206:	bf00      	nop
60005208:	6000bb1c 	.word	0x6000bb1c
6000520c:	6000cc54 	.word	0x6000cc54
60005210:	6000d5b3 	.word	0x6000d5b3
60005214:	6000c68a 	.word	0x6000c68a
60005218:	6000cce4 	.word	0x6000cce4
6000521c:	e000ed00 	.word	0xe000ed00
60005220:	80001708 	.word	0x80001708
60005224:	6000cd18 	.word	0x6000cd18
60005228:	6000cd69 	.word	0x6000cd69

6000522c <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
6000522c:	4b01      	ldr	r3, [pc, #4]	; (60005234 <__stdout_hook_install+0x8>)
6000522e:	6018      	str	r0, [r3, #0]
}
60005230:	4770      	bx	lr
60005232:	bf00      	nop
60005234:	80000804 	.word	0x80000804

60005238 <ztest_find_test_suite>:
}

#endif /* !KERNEL */

static struct ztest_suite_node *ztest_find_test_suite(const char *name)
{
60005238:	b570      	push	{r4, r5, r6, lr}
6000523a:	4605      	mov	r5, r0
	struct ztest_suite_node *node;

	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
6000523c:	4c07      	ldr	r4, [pc, #28]	; (6000525c <ztest_find_test_suite+0x24>)
6000523e:	4e08      	ldr	r6, [pc, #32]	; (60005260 <ztest_find_test_suite+0x28>)
60005240:	42b4      	cmp	r4, r6
60005242:	d302      	bcc.n	6000524a <ztest_find_test_suite+0x12>
		if (strcmp(name, node->name) == 0) {
			return node;
		}
	}

	return NULL;
60005244:	2400      	movs	r4, #0
}
60005246:	4620      	mov	r0, r4
60005248:	bd70      	pop	{r4, r5, r6, pc}
		if (strcmp(name, node->name) == 0) {
6000524a:	6821      	ldr	r1, [r4, #0]
6000524c:	4628      	mov	r0, r5
6000524e:	f005 fc87 	bl	6000ab60 <strcmp>
60005252:	2800      	cmp	r0, #0
60005254:	d0f7      	beq.n	60005246 <ztest_find_test_suite+0xe>
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
60005256:	341c      	adds	r4, #28
60005258:	e7f2      	b.n	60005240 <ztest_find_test_suite+0x8>
6000525a:	bf00      	nop
6000525c:	6000bacc 	.word	0x6000bacc
60005260:	6000bacc 	.word	0x6000bacc

60005264 <test_cb>:
{
60005264:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	test_result = ZTEST_RESULT_PENDING;
60005268:	f8df 8044 	ldr.w	r8, [pc, #68]	; 600052b0 <test_cb+0x4c>
6000526c:	2300      	movs	r3, #0
{
6000526e:	4607      	mov	r7, r0
60005270:	460d      	mov	r5, r1
60005272:	4614      	mov	r4, r2
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
60005274:	4e0f      	ldr	r6, [pc, #60]	; (600052b4 <test_cb+0x50>)
	     rule < _ztest_test_rule_list_end; ++rule) {
60005276:	f8df 9040 	ldr.w	r9, [pc, #64]	; 600052b8 <test_cb+0x54>
	test_result = ZTEST_RESULT_PENDING;
6000527a:	f888 3000 	strb.w	r3, [r8]
	     rule < _ztest_test_rule_list_end; ++rule) {
6000527e:	454e      	cmp	r6, r9
60005280:	d30e      	bcc.n	600052a0 <test_cb+0x3c>
	if (suite->before) {
60005282:	68bb      	ldr	r3, [r7, #8]
60005284:	b10b      	cbz	r3, 6000528a <test_cb+0x26>
		suite->before(/*data=*/c);
60005286:	4620      	mov	r0, r4
60005288:	4798      	blx	r3
	phase = TEST_PHASE_TEST;
6000528a:	4a0c      	ldr	r2, [pc, #48]	; (600052bc <test_cb+0x58>)
6000528c:	2102      	movs	r1, #2
6000528e:	68ab      	ldr	r3, [r5, #8]
	test->test(data);
60005290:	4620      	mov	r0, r4
	phase = TEST_PHASE_TEST;
60005292:	7011      	strb	r1, [r2, #0]
	test->test(data);
60005294:	4798      	blx	r3
	test_result = ZTEST_RESULT_PASS;
60005296:	2301      	movs	r3, #1
60005298:	f888 3000 	strb.w	r3, [r8]
}
6000529c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (is_before && rule->before_each) {
600052a0:	6833      	ldr	r3, [r6, #0]
600052a2:	b113      	cbz	r3, 600052aa <test_cb+0x46>
			rule->before_each(test, data);
600052a4:	4621      	mov	r1, r4
600052a6:	4628      	mov	r0, r5
600052a8:	4798      	blx	r3
	     rule < _ztest_test_rule_list_end; ++rule) {
600052aa:	3608      	adds	r6, #8
600052ac:	e7e7      	b.n	6000527e <test_cb+0x1a>
600052ae:	bf00      	nop
600052b0:	8000170a 	.word	0x8000170a
600052b4:	6000bacc 	.word	0x6000bacc
600052b8:	6000bacc 	.word	0x6000bacc
600052bc:	80000938 	.word	0x80000938

600052c0 <z_ztest_get_next_test>:

struct ztest_unit_test *z_ztest_get_next_test(const char *suite, struct ztest_unit_test *prev)
{
600052c0:	b570      	push	{r4, r5, r6, lr}
600052c2:	4605      	mov	r5, r0
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
600052c4:	b139      	cbz	r1, 600052d6 <z_ztest_get_next_test+0x16>
600052c6:	f101 0414 	add.w	r4, r1, #20

	for (; test < _ztest_unit_test_list_end; ++test) {
600052ca:	4e08      	ldr	r6, [pc, #32]	; (600052ec <z_ztest_get_next_test+0x2c>)
600052cc:	42b4      	cmp	r4, r6
600052ce:	d304      	bcc.n	600052da <z_ztest_get_next_test+0x1a>
		if (strcmp(suite, test->test_suite_name) == 0) {
			return test;
		}
	}
	return NULL;
600052d0:	2400      	movs	r4, #0
}
600052d2:	4620      	mov	r0, r4
600052d4:	bd70      	pop	{r4, r5, r6, pc}
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
600052d6:	4c06      	ldr	r4, [pc, #24]	; (600052f0 <z_ztest_get_next_test+0x30>)
600052d8:	e7f7      	b.n	600052ca <z_ztest_get_next_test+0xa>
		if (strcmp(suite, test->test_suite_name) == 0) {
600052da:	6821      	ldr	r1, [r4, #0]
600052dc:	4628      	mov	r0, r5
600052de:	f005 fc3f 	bl	6000ab60 <strcmp>
600052e2:	2800      	cmp	r0, #0
600052e4:	d0f5      	beq.n	600052d2 <z_ztest_get_next_test+0x12>
	for (; test < _ztest_unit_test_list_end; ++test) {
600052e6:	3414      	adds	r4, #20
600052e8:	e7f0      	b.n	600052cc <z_ztest_get_next_test+0xc>
600052ea:	bf00      	nop
600052ec:	6000bacc 	.word	0x6000bacc
600052f0:	6000bacc 	.word	0x6000bacc

600052f4 <z_ztest_run_test_suite_ptr>:
	}
}
#endif /* CONFIG_ZTEST_SHUFFLE */

static int z_ztest_run_test_suite_ptr(struct ztest_suite_node *suite)
{
600052f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	if (test_status < 0) {
		return test_status;
	}

	if (suite == NULL) {
600052f8:	4606      	mov	r6, r0
{
600052fa:	b089      	sub	sp, #36	; 0x24
	if (suite == NULL) {
600052fc:	b940      	cbnz	r0, 60005310 <z_ztest_run_test_suite_ptr+0x1c>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
600052fe:	4b94      	ldr	r3, [pc, #592]	; (60005550 <z_ztest_run_test_suite_ptr+0x25c>)
60005300:	2202      	movs	r2, #2
		return -1;
60005302:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
60005306:	701a      	strb	r2, [r3, #0]
	if (suite->teardown != NULL) {
		suite->teardown(data);
	}

	return fail;
}
60005308:	4640      	mov	r0, r8
6000530a:	b009      	add	sp, #36	; 0x24
6000530c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	TC_SUITE_START(suite->name);
60005310:	6801      	ldr	r1, [r0, #0]
60005312:	4890      	ldr	r0, [pc, #576]	; (60005554 <z_ztest_run_test_suite_ptr+0x260>)
60005314:	f005 fb59 	bl	6000a9ca <printk>
60005318:	488f      	ldr	r0, [pc, #572]	; (60005558 <z_ztest_run_test_suite_ptr+0x264>)
6000531a:	f005 fb56 	bl	6000a9ca <printk>
	current_test_failed_assumption = false;
6000531e:	2300      	movs	r3, #0
60005320:	4a8e      	ldr	r2, [pc, #568]	; (6000555c <z_ztest_run_test_suite_ptr+0x268>)
	phase = TEST_PHASE_SETUP;
60005322:	f8df 923c 	ldr.w	r9, [pc, #572]	; 60005560 <z_ztest_run_test_suite_ptr+0x26c>
	current_test_failed_assumption = false;
60005326:	7013      	strb	r3, [r2, #0]
	if (test_result != ZTEST_RESULT_SUITE_FAIL && suite->setup != NULL) {
60005328:	6877      	ldr	r7, [r6, #4]
	test_result = ZTEST_RESULT_PENDING;
6000532a:	4a8e      	ldr	r2, [pc, #568]	; (60005564 <z_ztest_run_test_suite_ptr+0x270>)
	phase = TEST_PHASE_SETUP;
6000532c:	f889 3000 	strb.w	r3, [r9]
	test_result = ZTEST_RESULT_PENDING;
60005330:	7013      	strb	r3, [r2, #0]
	if (test_result != ZTEST_RESULT_SUITE_FAIL && suite->setup != NULL) {
60005332:	b10f      	cbz	r7, 60005338 <z_ztest_run_test_suite_ptr+0x44>
		data = suite->setup();
60005334:	47b8      	blx	r7
60005336:	4607      	mov	r7, r0
		fail = 0;
60005338:	f04f 0800 	mov.w	r8, #0
static uint32_t tc_start_time;
static uint32_t tc_spend_time;

static inline void get_start_time_cyc(void)
{
	tc_start_time = k_cycle_get_32();
6000533c:	f8df a228 	ldr.w	sl, [pc, #552]	; 60005568 <z_ztest_run_test_suite_ptr+0x274>
	struct ztest_unit_test *test = NULL;
60005340:	4644      	mov	r4, r8
		while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
60005342:	4621      	mov	r1, r4
60005344:	6830      	ldr	r0, [r6, #0]
60005346:	f7ff ffbb 	bl	600052c0 <z_ztest_get_next_test>
6000534a:	4604      	mov	r4, r0
6000534c:	b978      	cbnz	r0, 6000536e <z_ztest_run_test_suite_ptr+0x7a>
		if (test_status == ZTEST_STATUS_OK && fail != 0) {
6000534e:	4b80      	ldr	r3, [pc, #512]	; (60005550 <z_ztest_run_test_suite_ptr+0x25c>)
60005350:	781a      	ldrb	r2, [r3, #0]
60005352:	2a00      	cmp	r2, #0
60005354:	f040 80e1 	bne.w	6000551a <z_ztest_run_test_suite_ptr+0x226>
60005358:	f1b8 0f00 	cmp.w	r8, #0
6000535c:	f000 80e1 	beq.w	60005522 <z_ztest_run_test_suite_ptr+0x22e>
			test_status = ZTEST_STATUS_HAS_FAILURE;
60005360:	2201      	movs	r2, #1
60005362:	701a      	strb	r2, [r3, #0]
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
60005364:	6831      	ldr	r1, [r6, #0]
60005366:	4881      	ldr	r0, [pc, #516]	; (6000556c <z_ztest_run_test_suite_ptr+0x278>)
60005368:	f005 fb2f 	bl	6000a9ca <printk>
6000536c:	e0df      	b.n	6000552e <z_ztest_run_test_suite_ptr+0x23a>
			if (ztest_api.should_test_run(suite->name, test->name)) {
6000536e:	4b80      	ldr	r3, [pc, #512]	; (60005570 <z_ztest_run_test_suite_ptr+0x27c>)
60005370:	6861      	ldr	r1, [r4, #4]
60005372:	689b      	ldr	r3, [r3, #8]
60005374:	6830      	ldr	r0, [r6, #0]
60005376:	4798      	blx	r3
60005378:	2800      	cmp	r0, #0
6000537a:	f000 80c9 	beq.w	60005510 <z_ztest_run_test_suite_ptr+0x21c>
				test->stats->run_count++;
6000537e:	6922      	ldr	r2, [r4, #16]
	TC_START(test->name);
60005380:	487c      	ldr	r0, [pc, #496]	; (60005574 <z_ztest_run_test_suite_ptr+0x280>)
				test->stats->run_count++;
60005382:	6813      	ldr	r3, [r2, #0]
60005384:	3301      	adds	r3, #1
60005386:	6013      	str	r3, [r2, #0]
	TC_START(test->name);
60005388:	6861      	ldr	r1, [r4, #4]
6000538a:	f005 fb1e 	bl	6000a9ca <printk>
	phase = TEST_PHASE_BEFORE;
6000538e:	2301      	movs	r3, #1
60005390:	f889 3000 	strb.w	r3, [r9]
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
60005394:	f001 fb1a 	bl	600069cc <sys_clock_cycle_get_32>
				test->thread_options | K_INHERIT_PERMS, K_FOREVER);
60005398:	68e3      	ldr	r3, [r4, #12]
6000539a:	f8ca 0000 	str.w	r0, [sl]
6000539e:	f043 0308 	orr.w	r3, r3, #8
		};
		return (k_tid_t) arch_syscall_invoke6(parm0.x, parm1.x, parm2.x, parm3.x, parm4.x, (uintptr_t) &more, K_SYSCALL_K_THREAD_CREATE);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
600053a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
600053a6:	9304      	str	r3, [sp, #16]
600053a8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
600053ac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
600053b0:	f44f 6280 	mov.w	r2, #1024	; 0x400
600053b4:	e9cd 0106 	strd	r0, r1, [sp, #24]
600053b8:	e9cd 7302 	strd	r7, r3, [sp, #8]
600053bc:	496e      	ldr	r1, [pc, #440]	; (60005578 <z_ztest_run_test_suite_ptr+0x284>)
600053be:	4b6f      	ldr	r3, [pc, #444]	; (6000557c <z_ztest_run_test_suite_ptr+0x288>)
600053c0:	486f      	ldr	r0, [pc, #444]	; (60005580 <z_ztest_run_test_suite_ptr+0x28c>)
600053c2:	e9cd 6400 	strd	r6, r4, [sp]
600053c6:	f003 fdb7 	bl	60008f38 <z_impl_k_thread_create>
		if (test->name != NULL) {
600053ca:	6861      	ldr	r1, [r4, #4]
600053cc:	b111      	cbz	r1, 600053d4 <z_ztest_run_test_suite_ptr+0xe0>
		union { uintptr_t x; const char * val; } parm1 = { .val = str };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
600053ce:	486c      	ldr	r0, [pc, #432]	; (60005580 <z_ztest_run_test_suite_ptr+0x28c>)
600053d0:	f003 fd36 	bl	60008e40 <z_impl_k_thread_name_set>
		if (test_result != ZTEST_RESULT_SUITE_SKIP &&
600053d4:	4b63      	ldr	r3, [pc, #396]	; (60005564 <z_ztest_run_test_suite_ptr+0x270>)
600053d6:	781b      	ldrb	r3, [r3, #0]
600053d8:	3b04      	subs	r3, #4
600053da:	2b01      	cmp	r3, #1
600053dc:	d909      	bls.n	600053f2 <z_ztest_run_test_suite_ptr+0xfe>
	z_impl_k_thread_start(thread);
600053de:	4868      	ldr	r0, [pc, #416]	; (60005580 <z_ztest_run_test_suite_ptr+0x28c>)
600053e0:	f006 f86a 	bl	6000b4b8 <z_impl_k_thread_start>
	return z_impl_k_thread_join(thread, timeout);
600053e4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
600053e8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
600053ec:	4864      	ldr	r0, [pc, #400]	; (60005580 <z_ztest_run_test_suite_ptr+0x28c>)
600053ee:	f004 ff4b 	bl	6000a288 <z_impl_k_thread_join>
	phase = TEST_PHASE_AFTER;
600053f2:	2303      	movs	r3, #3
600053f4:	f889 3000 	strb.w	r3, [r9]
	if (suite->after != NULL) {
600053f8:	68f3      	ldr	r3, [r6, #12]
600053fa:	b10b      	cbz	r3, 60005400 <z_ztest_run_test_suite_ptr+0x10c>
		suite->after(data);
600053fc:	4638      	mov	r0, r7
600053fe:	4798      	blx	r3
	void *data = NULL;
60005400:	4d60      	ldr	r5, [pc, #384]	; (60005584 <z_ztest_run_test_suite_ptr+0x290>)
	     rule < _ztest_test_rule_list_end; ++rule) {
60005402:	f8df b184 	ldr.w	fp, [pc, #388]	; 60005588 <z_ztest_run_test_suite_ptr+0x294>
60005406:	e005      	b.n	60005414 <z_ztest_run_test_suite_ptr+0x120>
		} else if (!is_before && rule->after_each) {
60005408:	686b      	ldr	r3, [r5, #4]
6000540a:	b113      	cbz	r3, 60005412 <z_ztest_run_test_suite_ptr+0x11e>
			rule->after_each(test, data);
6000540c:	4639      	mov	r1, r7
6000540e:	4620      	mov	r0, r4
60005410:	4798      	blx	r3
	     rule < _ztest_test_rule_list_end; ++rule) {
60005412:	3508      	adds	r5, #8
60005414:	455d      	cmp	r5, fp
60005416:	d3f7      	bcc.n	60005408 <z_ztest_run_test_suite_ptr+0x114>
60005418:	f001 fad8 	bl	600069cc <sys_clock_cycle_get_32>
}

static inline void get_test_duration_ms(void)
{
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
6000541c:	f8da 3000 	ldr.w	r3, [sl]
60005420:	1ac3      	subs	r3, r0, r3
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
60005422:	485a      	ldr	r0, [pc, #360]	; (6000558c <z_ztest_run_test_suite_ptr+0x298>)
60005424:	1818      	adds	r0, r3, r0
60005426:	bf2c      	ite	cs
60005428:	2101      	movcs	r1, #1
6000542a:	2100      	movcc	r1, #0
		if (result32 && (t < BIT64(32))) {
6000542c:	2900      	cmp	r1, #0
6000542e:	d146      	bne.n	600054be <z_ztest_run_test_suite_ptr+0x1ca>
			return ((uint32_t)t) / (from_hz / to_hz);
60005430:	f503 20f4 	add.w	r0, r3, #499712	; 0x7a000
60005434:	4b56      	ldr	r3, [pc, #344]	; (60005590 <z_ztest_run_test_suite_ptr+0x29c>)
60005436:	f200 101f 	addw	r0, r0, #287	; 0x11f
6000543a:	fbb0 f0f3 	udiv	r0, r0, r3

	tc_spend_time = k_cyc_to_ms_ceil32(spend_cycle);
6000543e:	4b55      	ldr	r3, [pc, #340]	; (60005594 <z_ztest_run_test_suite_ptr+0x2a0>)
60005440:	6018      	str	r0, [r3, #0]
	if (tc_spend_time > test->stats->duration_worst_ms) {
60005442:	6923      	ldr	r3, [r4, #16]
60005444:	691a      	ldr	r2, [r3, #16]
60005446:	4282      	cmp	r2, r0
		test->stats->duration_worst_ms = tc_spend_time;
60005448:	bf38      	it	cc
6000544a:	6118      	strcc	r0, [r3, #16]
	phase = TEST_PHASE_FRAMEWORK;
6000544c:	2305      	movs	r3, #5
6000544e:	f889 3000 	strb.w	r3, [r9]
	if (test_result == ZTEST_RESULT_FAIL || test_result == ZTEST_RESULT_SUITE_FAIL ||
60005452:	4b44      	ldr	r3, [pc, #272]	; (60005564 <z_ztest_run_test_suite_ptr+0x270>)
60005454:	781d      	ldrb	r5, [r3, #0]
60005456:	4b50      	ldr	r3, [pc, #320]	; (60005598 <z_ztest_run_test_suite_ptr+0x2a4>)
60005458:	2d02      	cmp	r5, #2
6000545a:	d004      	beq.n	60005466 <z_ztest_run_test_suite_ptr+0x172>
6000545c:	2d05      	cmp	r5, #5
6000545e:	d002      	beq.n	60005466 <z_ztest_run_test_suite_ptr+0x172>
60005460:	781a      	ldrb	r2, [r3, #0]
60005462:	2a00      	cmp	r2, #0
60005464:	d030      	beq.n	600054c8 <z_ztest_run_test_suite_ptr+0x1d4>
		failed_expectation = false;
60005466:	2200      	movs	r2, #0
		ret = TC_FAIL;
60005468:	2501      	movs	r5, #1
		failed_expectation = false;
6000546a:	701a      	strb	r2, [r3, #0]
	for (struct ztest_expected_result_entry *expectation =
6000546c:	f8df b12c 	ldr.w	fp, [pc, #300]	; 6000559c <z_ztest_run_test_suite_ptr+0x2a8>
	z_impl_k_thread_abort(thread);
60005470:	4843      	ldr	r0, [pc, #268]	; (60005580 <z_ztest_run_test_suite_ptr+0x28c>)
60005472:	f7ff fd67 	bl	60004f44 <z_impl_k_thread_abort>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
60005476:	4b4a      	ldr	r3, [pc, #296]	; (600055a0 <z_ztest_run_test_suite_ptr+0x2ac>)
		if (strcmp(expectation->test_name, test->name) == 0 &&
60005478:	6861      	ldr	r1, [r4, #4]
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
6000547a:	459b      	cmp	fp, r3
6000547c:	d32b      	bcc.n	600054d6 <z_ztest_run_test_suite_ptr+0x1e2>
	Z_TC_END_RESULT(ret, test->name);
6000547e:	4b45      	ldr	r3, [pc, #276]	; (60005594 <z_ztest_run_test_suite_ptr+0x2a0>)
60005480:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
60005484:	4847      	ldr	r0, [pc, #284]	; (600055a4 <z_ztest_run_test_suite_ptr+0x2b0>)
60005486:	681a      	ldr	r2, [r3, #0]
60005488:	fbb2 f3f1 	udiv	r3, r2, r1
6000548c:	fb01 2213 	mls	r2, r1, r3, r2
60005490:	4945      	ldr	r1, [pc, #276]	; (600055a8 <z_ztest_run_test_suite_ptr+0x2b4>)
60005492:	9200      	str	r2, [sp, #0]
60005494:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
60005498:	6862      	ldr	r2, [r4, #4]
6000549a:	f005 fa96 	bl	6000a9ca <printk>
6000549e:	482e      	ldr	r0, [pc, #184]	; (60005558 <z_ztest_run_test_suite_ptr+0x264>)
600054a0:	f005 fa93 	bl	6000a9ca <printk>
	if (ret == TC_SKIP && current_test_failed_assumption) {
600054a4:	2d02      	cmp	r5, #2
600054a6:	6923      	ldr	r3, [r4, #16]
600054a8:	d12e      	bne.n	60005508 <z_ztest_run_test_suite_ptr+0x214>
600054aa:	4a2c      	ldr	r2, [pc, #176]	; (6000555c <z_ztest_run_test_suite_ptr+0x268>)
600054ac:	7812      	ldrb	r2, [r2, #0]
600054ae:	b112      	cbz	r2, 600054b6 <z_ztest_run_test_suite_ptr+0x1c2>
		test_status = 1;
600054b0:	4a27      	ldr	r2, [pc, #156]	; (60005550 <z_ztest_run_test_suite_ptr+0x25c>)
600054b2:	2101      	movs	r1, #1
600054b4:	7011      	strb	r1, [r2, #0]
					test->stats->skip_count++;
600054b6:	685a      	ldr	r2, [r3, #4]
600054b8:	3201      	adds	r2, #1
600054ba:	605a      	str	r2, [r3, #4]
				if (tc_result == TC_FAIL) {
600054bc:	e028      	b.n	60005510 <z_ztest_run_test_suite_ptr+0x21c>
		} else {
			return t / ((uint64_t)from_hz / to_hz);
600054be:	4a34      	ldr	r2, [pc, #208]	; (60005590 <z_ztest_run_test_suite_ptr+0x29c>)
600054c0:	2300      	movs	r3, #0
600054c2:	f7fe fad9 	bl	60003a78 <__aeabi_uldivmod>
600054c6:	e7ba      	b.n	6000543e <z_ztest_run_test_suite_ptr+0x14a>
	} else if (test_result == ZTEST_RESULT_SKIP || test_result == ZTEST_RESULT_SUITE_SKIP) {
600054c8:	3d03      	subs	r5, #3
600054ca:	2d01      	cmp	r5, #1
600054cc:	bf8c      	ite	hi
600054ce:	2500      	movhi	r5, #0
600054d0:	2501      	movls	r5, #1
600054d2:	006d      	lsls	r5, r5, #1
600054d4:	e7ca      	b.n	6000546c <z_ztest_run_test_suite_ptr+0x178>
		if (strcmp(expectation->test_name, test->name) == 0 &&
600054d6:	f8db 0004 	ldr.w	r0, [fp, #4]
600054da:	f005 fb41 	bl	6000ab60 <strcmp>
600054de:	b960      	cbnz	r0, 600054fa <z_ztest_run_test_suite_ptr+0x206>
		    strcmp(expectation->test_suite_name, test->test_suite_name) == 0) {
600054e0:	6821      	ldr	r1, [r4, #0]
600054e2:	f8db 0000 	ldr.w	r0, [fp]
600054e6:	f005 fb3b 	bl	6000ab60 <strcmp>
		if (strcmp(expectation->test_name, test->name) == 0 &&
600054ea:	b930      	cbnz	r0, 600054fa <z_ztest_run_test_suite_ptr+0x206>
			expected_result = expectation->expected_result;
600054ec:	f89b 3008 	ldrb.w	r3, [fp, #8]
	if (expected_result == ZTEST_EXPECTED_RESULT_FAIL) {
600054f0:	b133      	cbz	r3, 60005500 <z_ztest_run_test_suite_ptr+0x20c>
	if (expected_result == ZTEST_EXPECTED_RESULT_SKIP) {
600054f2:	2b01      	cmp	r3, #1
600054f4:	d1c3      	bne.n	6000547e <z_ztest_run_test_suite_ptr+0x18a>
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
600054f6:	3d02      	subs	r5, #2
600054f8:	e003      	b.n	60005502 <z_ztest_run_test_suite_ptr+0x20e>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
600054fa:	f10b 0b0c 	add.w	fp, fp, #12
600054fe:	e7ba      	b.n	60005476 <z_ztest_run_test_suite_ptr+0x182>
		return (ret == TC_FAIL) ? TC_PASS : TC_FAIL;
60005500:	3d01      	subs	r5, #1
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
60005502:	bf18      	it	ne
60005504:	2501      	movne	r5, #1
	switch (result) {
60005506:	e7ba      	b.n	6000547e <z_ztest_run_test_suite_ptr+0x18a>
				if (tc_result == TC_PASS) {
60005508:	b9dd      	cbnz	r5, 60005542 <z_ztest_run_test_suite_ptr+0x24e>
					test->stats->pass_count++;
6000550a:	68da      	ldr	r2, [r3, #12]
6000550c:	3201      	adds	r2, #1
6000550e:	60da      	str	r2, [r3, #12]
			if ((fail && FAIL_FAST) || test_status == ZTEST_STATUS_CRITICAL_ERROR) {
60005510:	4b0f      	ldr	r3, [pc, #60]	; (60005550 <z_ztest_run_test_suite_ptr+0x25c>)
60005512:	781b      	ldrb	r3, [r3, #0]
60005514:	2b02      	cmp	r3, #2
60005516:	f47f af14 	bne.w	60005342 <z_ztest_run_test_suite_ptr+0x4e>
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
6000551a:	f1b8 0f00 	cmp.w	r8, #0
6000551e:	f47f af21 	bne.w	60005364 <z_ztest_run_test_suite_ptr+0x70>
60005522:	f04f 0800 	mov.w	r8, #0
60005526:	6831      	ldr	r1, [r6, #0]
60005528:	4820      	ldr	r0, [pc, #128]	; (600055ac <z_ztest_run_test_suite_ptr+0x2b8>)
6000552a:	f005 fa4e 	bl	6000a9ca <printk>
	phase = TEST_PHASE_TEARDOWN;
6000552e:	2304      	movs	r3, #4
60005530:	f889 3000 	strb.w	r3, [r9]
	if (suite->teardown != NULL) {
60005534:	6933      	ldr	r3, [r6, #16]
60005536:	2b00      	cmp	r3, #0
60005538:	f43f aee6 	beq.w	60005308 <z_ztest_run_test_suite_ptr+0x14>
		suite->teardown(data);
6000553c:	4638      	mov	r0, r7
6000553e:	4798      	blx	r3
60005540:	e6e2      	b.n	60005308 <z_ztest_run_test_suite_ptr+0x14>
					test->stats->fail_count++;
60005542:	689a      	ldr	r2, [r3, #8]
					fail++;
60005544:	f108 0801 	add.w	r8, r8, #1
					test->stats->fail_count++;
60005548:	3201      	adds	r2, #1
6000554a:	609a      	str	r2, [r3, #8]
					fail++;
6000554c:	e7e0      	b.n	60005510 <z_ztest_run_test_suite_ptr+0x21c>
6000554e:	bf00      	nop
60005550:	8000170b 	.word	0x8000170b
60005554:	6000cd99 	.word	0x6000cd99
60005558:	6000cdaf 	.word	0x6000cdaf
6000555c:	80001709 	.word	0x80001709
60005560:	80000938 	.word	0x80000938
60005564:	8000170a 	.word	0x8000170a
60005568:	80000b48 	.word	0x80000b48
6000556c:	6000ce35 	.word	0x6000ce35
60005570:	6000bb48 	.word	0x6000bb48
60005574:	6000cdf4 	.word	0x6000cdf4
60005578:	80001740 	.word	0x80001740
6000557c:	60005265 	.word	0x60005265
60005580:	80000950 	.word	0x80000950
60005584:	6000bacc 	.word	0x6000bacc
60005588:	6000bacc 	.word	0x6000bacc
6000558c:	0007a11f 	.word	0x0007a11f
60005590:	0007a120 	.word	0x0007a120
60005594:	80000b44 	.word	0x80000b44
60005598:	8000170c 	.word	0x8000170c
6000559c:	6000bacc 	.word	0x6000bacc
600055a0:	6000bacc 	.word	0x6000bacc
600055a4:	6000ce00 	.word	0x6000ce00
600055a8:	6000bb3c 	.word	0x6000bb3c
600055ac:	6000ce1d 	.word	0x6000ce1d

600055b0 <z_impl_ztest_run_test_suites>:

	return count;
}

int z_impl_ztest_run_test_suites(const void *state)
{
600055b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int count = 0;

	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
600055b4:	4f26      	ldr	r7, [pc, #152]	; (60005650 <z_impl_ztest_run_test_suites+0xa0>)
{
600055b6:	4606      	mov	r6, r0
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
600055b8:	783b      	ldrb	r3, [r7, #0]
600055ba:	2b02      	cmp	r3, #2
600055bc:	d046      	beq.n	6000564c <z_impl_ztest_run_test_suites+0x9c>
	int count = 0;
600055be:	2500      	movs	r5, #0
		    (test_status == ZTEST_STATUS_HAS_FAILURE && FAIL_FAST)) {
			break;
		}
	}
#else
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
600055c0:	4c24      	ldr	r4, [pc, #144]	; (60005654 <z_impl_ztest_run_test_suites+0xa4>)
	     ptr < _ztest_suite_node_list_end; ++ptr) {
600055c2:	f8df 8094 	ldr.w	r8, [pc, #148]	; 60005658 <z_impl_ztest_run_test_suites+0xa8>
		if (ztest_api.should_suite_run(state, ptr)) {
600055c6:	f8df 9094 	ldr.w	r9, [pc, #148]	; 6000565c <z_impl_ztest_run_test_suites+0xac>
	int count = 0;
600055ca:	46ab      	mov	fp, r5
	     ptr < _ztest_suite_node_list_end; ++ptr) {
600055cc:	4544      	cmp	r4, r8
600055ce:	d302      	bcc.n	600055d6 <z_impl_ztest_run_test_suites+0x26>
		}
	}
#endif

	return count;
}
600055d0:	4628      	mov	r0, r5
600055d2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (ztest_api.should_suite_run(state, ptr)) {
600055d6:	f8d9 3004 	ldr.w	r3, [r9, #4]
600055da:	4621      	mov	r1, r4
600055dc:	4630      	mov	r0, r6
	struct ztest_suite_stats *stats = ptr->stats;
600055de:	f8d4 a018 	ldr.w	sl, [r4, #24]
		if (ztest_api.should_suite_run(state, ptr)) {
600055e2:	4798      	blx	r3
600055e4:	b360      	cbz	r0, 60005640 <z_impl_ztest_run_test_suites+0x90>
	struct ztest_unit_test *test = NULL;
600055e6:	2100      	movs	r1, #0
600055e8:	e00e      	b.n	60005608 <z_impl_ztest_run_test_suites+0x58>
		test->stats->run_count = 0;
600055ea:	690b      	ldr	r3, [r1, #16]
600055ec:	f8c3 b000 	str.w	fp, [r3]
		test->stats->skip_count = 0;
600055f0:	690b      	ldr	r3, [r1, #16]
600055f2:	f8c3 b004 	str.w	fp, [r3, #4]
		test->stats->fail_count = 0;
600055f6:	690b      	ldr	r3, [r1, #16]
600055f8:	f8c3 b008 	str.w	fp, [r3, #8]
		test->stats->pass_count = 0;
600055fc:	690b      	ldr	r3, [r1, #16]
600055fe:	f8c3 b00c 	str.w	fp, [r3, #12]
		test->stats->duration_worst_ms = 0;
60005602:	690b      	ldr	r3, [r1, #16]
60005604:	f8c3 b010 	str.w	fp, [r3, #16]
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
60005608:	6820      	ldr	r0, [r4, #0]
6000560a:	f7ff fe59 	bl	600052c0 <z_ztest_get_next_test>
6000560e:	4601      	mov	r1, r0
60005610:	2800      	cmp	r0, #0
60005612:	d1ea      	bne.n	600055ea <z_impl_ztest_run_test_suites+0x3a>
			int fail = z_ztest_run_test_suite_ptr(ptr);
60005614:	4620      	mov	r0, r4
60005616:	f7ff fe6d 	bl	600052f4 <z_ztest_run_test_suite_ptr>
			stats->run_count++;
6000561a:	f8da 3000 	ldr.w	r3, [sl]
6000561e:	3301      	adds	r3, #1
60005620:	f8ca 3000 	str.w	r3, [sl]
			stats->fail_count += (fail != 0) ? 1 : 0;
60005624:	f8da 3008 	ldr.w	r3, [sl, #8]
60005628:	2800      	cmp	r0, #0
6000562a:	bf18      	it	ne
6000562c:	3301      	addne	r3, #1
			count++;
6000562e:	2001      	movs	r0, #1
			stats->fail_count += (fail != 0) ? 1 : 0;
60005630:	f8ca 3008 	str.w	r3, [sl, #8]
		if (test_status == ZTEST_STATUS_CRITICAL_ERROR ||
60005634:	783b      	ldrb	r3, [r7, #0]
		count += __ztest_run_test_suite(ptr, state);
60005636:	4405      	add	r5, r0
		if (test_status == ZTEST_STATUS_CRITICAL_ERROR ||
60005638:	2b02      	cmp	r3, #2
6000563a:	d0c9      	beq.n	600055d0 <z_impl_ztest_run_test_suites+0x20>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
6000563c:	341c      	adds	r4, #28
6000563e:	e7c5      	b.n	600055cc <z_impl_ztest_run_test_suites+0x1c>
			stats->skip_count++;
60005640:	f8da 3004 	ldr.w	r3, [sl, #4]
60005644:	3301      	adds	r3, #1
60005646:	f8ca 3004 	str.w	r3, [sl, #4]
6000564a:	e7f3      	b.n	60005634 <z_impl_ztest_run_test_suites+0x84>
		return count;
6000564c:	2500      	movs	r5, #0
6000564e:	e7bf      	b.n	600055d0 <z_impl_ztest_run_test_suites+0x20>
60005650:	8000170b 	.word	0x8000170b
60005654:	6000bacc 	.word	0x6000bacc
60005658:	6000bacc 	.word	0x6000bacc
6000565c:	6000bb48 	.word	0x6000bb48

60005660 <ztest_verify_all_test_suites_ran>:

void ztest_verify_all_test_suites_ran(void)
{
60005660:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool all_tests_run = true;
	struct ztest_suite_node *suite;
	struct ztest_unit_test *test;

	if (IS_ENABLED(CONFIG_ZTEST_VERIFY_RUN_ALL)) {
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
60005664:	4c21      	ldr	r4, [pc, #132]	; (600056ec <ztest_verify_all_test_suites_ran+0x8c>)
	bool all_tests_run = true;
60005666:	2701      	movs	r7, #1
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
60005668:	4e21      	ldr	r6, [pc, #132]	; (600056f0 <ztest_verify_all_test_suites_ran+0x90>)
		     ++suite) {
			if (suite->stats->run_count < 1) {
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
6000566a:	f8df 8088 	ldr.w	r8, [pc, #136]	; 600056f4 <ztest_verify_all_test_suites_ran+0x94>
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
6000566e:	42b4      	cmp	r4, r6
60005670:	d312      	bcc.n	60005698 <ztest_verify_all_test_suites_ran+0x38>
				all_tests_run = false;
			}
		}

		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
60005672:	4c21      	ldr	r4, [pc, #132]	; (600056f8 <ztest_verify_all_test_suites_ran+0x98>)
60005674:	4e21      	ldr	r6, [pc, #132]	; (600056fc <ztest_verify_all_test_suites_ran+0x9c>)
			suite = ztest_find_test_suite(test->test_suite_name);
			if (suite == NULL) {
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
60005676:	f8df 8088 	ldr.w	r8, [pc, #136]	; 60005700 <ztest_verify_all_test_suites_ran+0xa0>
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
6000567a:	42b4      	cmp	r4, r6
6000567c:	d316      	bcc.n	600056ac <ztest_verify_all_test_suites_ran+0x4c>
				      test->name, test->test_suite_name);
				all_tests_run = false;
			}
		}

		if (!all_tests_run) {
6000567e:	b917      	cbnz	r7, 60005686 <ztest_verify_all_test_suites_ran+0x26>
			test_status = ZTEST_STATUS_HAS_FAILURE;
60005680:	4b20      	ldr	r3, [pc, #128]	; (60005704 <ztest_verify_all_test_suites_ran+0xa4>)
60005682:	2201      	movs	r2, #1
60005684:	701a      	strb	r2, [r3, #0]
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
60005686:	4c1c      	ldr	r4, [pc, #112]	; (600056f8 <ztest_verify_all_test_suites_ran+0x98>)

	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
		    test->stats->run_count) {
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
			test_status = 1;
60005688:	f04f 0801 	mov.w	r8, #1
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
6000568c:	4d1e      	ldr	r5, [pc, #120]	; (60005708 <ztest_verify_all_test_suites_ran+0xa8>)
			test_status = 1;
6000568e:	4f1d      	ldr	r7, [pc, #116]	; (60005704 <ztest_verify_all_test_suites_ran+0xa4>)
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
60005690:	42b4      	cmp	r4, r6
60005692:	d318      	bcc.n	600056c6 <ztest_verify_all_test_suites_ran+0x66>
		}
	}
}
60005694:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (suite->stats->run_count < 1) {
60005698:	69a3      	ldr	r3, [r4, #24]
6000569a:	681d      	ldr	r5, [r3, #0]
6000569c:	b925      	cbnz	r5, 600056a8 <ztest_verify_all_test_suites_ran+0x48>
				all_tests_run = false;
6000569e:	462f      	mov	r7, r5
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
600056a0:	6821      	ldr	r1, [r4, #0]
600056a2:	4640      	mov	r0, r8
600056a4:	f005 f991 	bl	6000a9ca <printk>
		     ++suite) {
600056a8:	341c      	adds	r4, #28
600056aa:	e7e0      	b.n	6000566e <ztest_verify_all_test_suites_ran+0xe>
			suite = ztest_find_test_suite(test->test_suite_name);
600056ac:	6820      	ldr	r0, [r4, #0]
600056ae:	f7ff fdc3 	bl	60005238 <ztest_find_test_suite>
			if (suite == NULL) {
600056b2:	4605      	mov	r5, r0
600056b4:	b928      	cbnz	r0, 600056c2 <ztest_verify_all_test_suites_ran+0x62>
				all_tests_run = false;
600056b6:	462f      	mov	r7, r5
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
600056b8:	4640      	mov	r0, r8
600056ba:	e9d4 2100 	ldrd	r2, r1, [r4]
600056be:	f005 f984 	bl	6000a9ca <printk>
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
600056c2:	3414      	adds	r4, #20
600056c4:	e7d9      	b.n	6000567a <ztest_verify_all_test_suites_ran+0x1a>
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
600056c6:	6922      	ldr	r2, [r4, #16]
600056c8:	e9d2 3102 	ldrd	r3, r1, [r2, #8]
600056cc:	440b      	add	r3, r1
600056ce:	6851      	ldr	r1, [r2, #4]
600056d0:	6812      	ldr	r2, [r2, #0]
600056d2:	440b      	add	r3, r1
600056d4:	4293      	cmp	r3, r2
600056d6:	d006      	beq.n	600056e6 <ztest_verify_all_test_suites_ran+0x86>
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
600056d8:	4628      	mov	r0, r5
600056da:	e9d4 1200 	ldrd	r1, r2, [r4]
600056de:	f005 f974 	bl	6000a9ca <printk>
			test_status = 1;
600056e2:	f887 8000 	strb.w	r8, [r7]
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
600056e6:	3414      	adds	r4, #20
600056e8:	e7d2      	b.n	60005690 <ztest_verify_all_test_suites_ran+0x30>
600056ea:	bf00      	nop
600056ec:	6000bacc 	.word	0x6000bacc
600056f0:	6000bacc 	.word	0x6000bacc
600056f4:	6000ce4b 	.word	0x6000ce4b
600056f8:	6000bacc 	.word	0x6000bacc
600056fc:	6000bacc 	.word	0x6000bacc
60005700:	6000ce70 	.word	0x6000ce70
60005704:	8000170b 	.word	0x8000170b
60005708:	6000ceb2 	.word	0x6000ceb2

6000570c <ztest_run_all>:

void ztest_run_all(const void *state) { ztest_api.run_all(state); }
6000570c:	4b01      	ldr	r3, [pc, #4]	; (60005714 <ztest_run_all+0x8>)
6000570e:	681b      	ldr	r3, [r3, #0]
60005710:	4718      	bx	r3
60005712:	bf00      	nop
60005714:	6000bb48 	.word	0x6000bb48

60005718 <main>:

	return test_status;
}
#else
void main(void)
{
60005718:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
6000571c:	4e54      	ldr	r6, [pc, #336]	; (60005870 <main+0x158>)
6000571e:	b08b      	sub	sp, #44	; 0x2c
	     ptr < _ztest_suite_node_list_end; ++ptr) {
60005720:	f8df b150 	ldr.w	fp, [pc, #336]	; 60005874 <main+0x15c>
	k_mem_domain_add_partition(&k_mem_domain_default, &z_malloc_partition);
#endif
#endif /* CONFIG_USERSPACE */

	z_init_mock();
	test_main();
60005724:	f005 fa3f 	bl	6000aba6 <test_main>
	TC_SUMMARY_PRINT("SUITE %s - %3d.%02d%% [%s]: pass = %d, fail = %d, "
60005728:	f8df a14c 	ldr.w	sl, [pc, #332]	; 60005878 <main+0x160>
	TC_SUMMARY_PRINT("\n------ TESTSUITE SUMMARY START ------\n\n");
6000572c:	4853      	ldr	r0, [pc, #332]	; (6000587c <main+0x164>)
6000572e:	f005 f94c 	bl	6000a9ca <printk>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
60005732:	f1a6 031c 	sub.w	r3, r6, #28
60005736:	455b      	cmp	r3, fp
60005738:	d371      	bcc.n	6000581e <main+0x106>
	TC_SUMMARY_PRINT("------ TESTSUITE SUMMARY END ------\n\n");
6000573a:	4851      	ldr	r0, [pc, #324]	; (60005880 <main+0x168>)
6000573c:	f005 f945 	bl	6000a9ca <printk>
	if (test_status) {
60005740:	4b50      	ldr	r3, [pc, #320]	; (60005884 <main+0x16c>)
		TC_END_REPORT(TC_FAIL);
60005742:	4851      	ldr	r0, [pc, #324]	; (60005888 <main+0x170>)
	if (test_status) {
60005744:	781b      	ldrb	r3, [r3, #0]
60005746:	2b00      	cmp	r3, #0
60005748:	f000 808e 	beq.w	60005868 <main+0x150>
		TC_END_REPORT(TC_FAIL);
6000574c:	f005 f93d 	bl	6000a9ca <printk>
60005750:	494e      	ldr	r1, [pc, #312]	; (6000588c <main+0x174>)
		TC_END_REPORT(TC_PASS);
60005752:	484f      	ldr	r0, [pc, #316]	; (60005890 <main+0x178>)
		} else {
			PRINT("Failed after %u attempts\n", state.boots);
			state.boots = 0;
		}
	}
}
60005754:	b00b      	add	sp, #44	; 0x2c
60005756:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		TC_END_REPORT(TC_PASS);
6000575a:	f005 b936 	b.w	6000a9ca <printk>
		suite_duration_worst_ms += test->stats->duration_worst_ms;
6000575e:	6921      	ldr	r1, [r4, #16]
		distinct_total++;
60005760:	f108 0801 	add.w	r8, r8, #1
		suite_duration_worst_ms += test->stats->duration_worst_ms;
60005764:	6908      	ldr	r0, [r1, #16]
60005766:	4405      	add	r5, r0
		if (test->stats->skip_count == test->stats->run_count) {
60005768:	e9d1 0c00 	ldrd	r0, ip, [r1]
6000576c:	4584      	cmp	ip, r0
6000576e:	d150      	bne.n	60005812 <main+0xfa>
			distinct_skip++;
60005770:	3701      	adds	r7, #1
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
60005772:	4621      	mov	r1, r4
60005774:	f856 0c1c 	ldr.w	r0, [r6, #-28]
60005778:	e9cd 3208 	strd	r3, r2, [sp, #32]
6000577c:	f7ff fda0 	bl	600052c0 <z_ztest_get_next_test>
60005780:	4604      	mov	r4, r0
60005782:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
60005786:	2800      	cmp	r0, #0
60005788:	d1e9      	bne.n	6000575e <main+0x46>
	if (distinct_skip == distinct_total) {
6000578a:	45b8      	cmp	r8, r7
6000578c:	d04e      	beq.n	6000582c <main+0x114>
		expanded_pass = distinct_pass * 100000;
6000578e:	4941      	ldr	r1, [pc, #260]	; (60005894 <main+0x17c>)
		passrate_major = expanded_passrate / 1000;
60005790:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
		passrate_tail = expanded_passrate - passrate_major * 1000 - passrate_minor * 10;
60005794:	f06f 0909 	mvn.w	r9, #9
		suite_result = (distinct_fail > 0) ? TC_FAIL : TC_PASS;
60005798:	2a00      	cmp	r2, #0
		expanded_pass = distinct_pass * 100000;
6000579a:	fb01 fe03 	mul.w	lr, r1, r3
		effective_total = distinct_total - distinct_skip;
6000579e:	eba8 0107 	sub.w	r1, r8, r7
		suite_result = (distinct_fail > 0) ? TC_FAIL : TC_PASS;
600057a2:	bfd4      	ite	le
600057a4:	f04f 0c00 	movle.w	ip, #0
600057a8:	f04f 0c01 	movgt.w	ip, #1
		expanded_passrate = expanded_pass / effective_total;
600057ac:	fb9e fef1 	sdiv	lr, lr, r1
		passrate_major = expanded_passrate / 1000;
600057b0:	fb9e f0f0 	sdiv	r0, lr, r0
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
600057b4:	4938      	ldr	r1, [pc, #224]	; (60005898 <main+0x180>)
600057b6:	fb01 ee00 	mla	lr, r1, r0, lr
600057ba:	210a      	movs	r1, #10
600057bc:	fb9e f1f1 	sdiv	r1, lr, r1
		passrate_tail = expanded_passrate - passrate_major * 1000 - passrate_minor * 10;
600057c0:	fb09 ee01 	mla	lr, r9, r1, lr
		if (passrate_tail >= 5) { /* rounding */
600057c4:	f1be 0f04 	cmp.w	lr, #4
600057c8:	dd00      	ble.n	600057cc <main+0xb4>
			passrate_minor++;
600057ca:	3101      	adds	r1, #1
	TC_SUMMARY_PRINT("SUITE %s - %3d.%02d%% [%s]: pass = %d, fail = %d, "
600057cc:	f44f 797a 	mov.w	r9, #1000	; 0x3e8
600057d0:	fbb5 fef9 	udiv	lr, r5, r9
600057d4:	fb09 551e 	mls	r5, r9, lr, r5
600057d8:	e9cd 3201 	strd	r3, r2, [sp, #4]
600057dc:	e9cd e505 	strd	lr, r5, [sp, #20]
600057e0:	e9cd 7803 	strd	r7, r8, [sp, #12]
600057e4:	f856 3c1c 	ldr.w	r3, [r6, #-28]
600057e8:	4602      	mov	r2, r0
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
600057ea:	4d2c      	ldr	r5, [pc, #176]	; (6000589c <main+0x184>)
	TC_SUMMARY_PRINT("SUITE %s - %3d.%02d%% [%s]: pass = %d, fail = %d, "
600057ec:	9300      	str	r3, [sp, #0]
600057ee:	460b      	mov	r3, r1
600057f0:	482b      	ldr	r0, [pc, #172]	; (600058a0 <main+0x188>)
600057f2:	f85a 102c 	ldr.w	r1, [sl, ip, lsl #2]
600057f6:	f005 f8e8 	bl	6000a9ca <printk>
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
600057fa:	4621      	mov	r1, r4
600057fc:	f856 0c1c 	ldr.w	r0, [r6, #-28]
60005800:	f7ff fd5e 	bl	600052c0 <z_ztest_get_next_test>
60005804:	4604      	mov	r4, r0
60005806:	b9a8      	cbnz	r0, 60005834 <main+0x11c>
	TC_SUMMARY_PRINT("\n");
60005808:	4826      	ldr	r0, [pc, #152]	; (600058a4 <main+0x18c>)
6000580a:	361c      	adds	r6, #28
6000580c:	f005 f8dd 	bl	6000a9ca <printk>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
60005810:	e78f      	b.n	60005732 <main+0x1a>
		} else if (test->stats->pass_count == test->stats->run_count) {
60005812:	68c9      	ldr	r1, [r1, #12]
60005814:	4288      	cmp	r0, r1
			distinct_pass++;
60005816:	bf0c      	ite	eq
60005818:	3301      	addeq	r3, #1
			distinct_fail++;
6000581a:	3201      	addne	r2, #1
6000581c:	e7a9      	b.n	60005772 <main+0x5a>
	unsigned int suite_duration_worst_ms = 0;
6000581e:	2500      	movs	r5, #0
	struct ztest_unit_test *test = NULL;
60005820:	462c      	mov	r4, r5
	int distinct_pass = 0, distinct_fail = 0, distinct_skip = 0, distinct_total = 0;
60005822:	46a8      	mov	r8, r5
60005824:	462f      	mov	r7, r5
60005826:	462a      	mov	r2, r5
60005828:	462b      	mov	r3, r5
6000582a:	e7a2      	b.n	60005772 <main+0x5a>
6000582c:	f04f 0c02 	mov.w	ip, #2
		passrate_major = passrate_minor = 0;
60005830:	4601      	mov	r1, r0
60005832:	e7cb      	b.n	600057cc <main+0xb4>
		if (test->stats->skip_count == test->stats->run_count) {
60005834:	6923      	ldr	r3, [r4, #16]
60005836:	e9d3 2100 	ldrd	r2, r1, [r3]
6000583a:	4291      	cmp	r1, r2
6000583c:	d012      	beq.n	60005864 <main+0x14c>
		} else if (test->stats->pass_count == test->stats->run_count) {
6000583e:	68d9      	ldr	r1, [r3, #12]
60005840:	1a89      	subs	r1, r1, r2
60005842:	bf18      	it	ne
60005844:	2101      	movne	r1, #1
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
60005846:	691b      	ldr	r3, [r3, #16]
60005848:	4628      	mov	r0, r5
6000584a:	f85a 1021 	ldr.w	r1, [sl, r1, lsl #2]
6000584e:	fbb3 f2f9 	udiv	r2, r3, r9
60005852:	fb09 3312 	mls	r3, r9, r2, r3
60005856:	e9cd 2300 	strd	r2, r3, [sp]
6000585a:	e9d4 2300 	ldrd	r2, r3, [r4]
6000585e:	f005 f8b4 	bl	6000a9ca <printk>
		flush_frequency++;
60005862:	e7ca      	b.n	600057fa <main+0xe2>
60005864:	2102      	movs	r1, #2
60005866:	e7ee      	b.n	60005846 <main+0x12e>
		TC_END_REPORT(TC_PASS);
60005868:	f005 f8af 	bl	6000a9ca <printk>
6000586c:	490e      	ldr	r1, [pc, #56]	; (600058a8 <main+0x190>)
6000586e:	e770      	b.n	60005752 <main+0x3a>
60005870:	6000bae8 	.word	0x6000bae8
60005874:	6000bacc 	.word	0x6000bacc
60005878:	6000bb3c 	.word	0x6000bb3c
6000587c:	6000cec7 	.word	0x6000cec7
60005880:	6000cf80 	.word	0x6000cf80
60005884:	8000170b 	.word	0x8000170b
60005888:	6000cdaf 	.word	0x6000cdaf
6000588c:	6000cfa6 	.word	0x6000cfa6
60005890:	6000cfad 	.word	0x6000cfad
60005894:	000186a0 	.word	0x000186a0
60005898:	fffffc18 	.word	0xfffffc18
6000589c:	6000cf54 	.word	0x6000cf54
600058a0:	6000cef0 	.word	0x6000cef0
600058a4:	6000e2a1 	.word	0x6000e2a1
600058a8:	6000cfc3 	.word	0x6000cfc3

600058ac <mcux_ccm_get_subsys_rate>:
#else
	uint32_t clock_name = (uint32_t) sub_system;
#endif
	uint32_t mux __unused;

	switch (clock_name) {
600058ac:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
{
600058b0:	b538      	push	{r3, r4, r5, lr}
600058b2:	4614      	mov	r4, r2
	switch (clock_name) {
600058b4:	d013      	beq.n	600058de <mcux_ccm_get_subsys_rate+0x32>
600058b6:	f5b1 6fe0 	cmp.w	r1, #1792	; 0x700
600058ba:	d032      	beq.n	60005922 <mcux_ccm_get_subsys_rate+0x76>
600058bc:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
600058c0:	d12b      	bne.n	6000591a <mcux_ccm_get_subsys_rate+0x6e>
    return (CCM_TUPLE_REG(CCM, mux) & CCM_TUPLE_MASK(mux)) >> CCM_TUPLE_SHIFT(mux);
600058c2:	4d19      	ldr	r5, [pc, #100]	; (60005928 <mcux_ccm_get_subsys_rate+0x7c>)
600058c4:	6a6b      	ldr	r3, [r5, #36]	; 0x24

	} break;

#else
	case IMX_CCM_LPUART_CLK:
		if (CLOCK_GetMux(kCLOCK_UartMux) == 0) {
600058c6:	065a      	lsls	r2, r3, #25
600058c8:	d419      	bmi.n	600058fe <mcux_ccm_get_subsys_rate+0x52>
			*rate = CLOCK_GetPllFreq(kCLOCK_PllUsb1) / 6
600058ca:	4818      	ldr	r0, [pc, #96]	; (6000592c <mcux_ccm_get_subsys_rate+0x80>)
600058cc:	f001 f90c 	bl	60006ae8 <CLOCK_GetPllFreq>
    return ((CCM_TUPLE_REG(CCM, divider) & CCM_TUPLE_MASK(divider)) >> CCM_TUPLE_SHIFT(divider));
600058d0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
600058d2:	2206      	movs	r2, #6
600058d4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
600058d8:	fbb0 f0f2 	udiv	r0, r0, r2
600058dc:	e00a      	b.n	600058f4 <mcux_ccm_get_subsys_rate+0x48>
    return (CCM_TUPLE_REG(CCM, mux) & CCM_TUPLE_MASK(mux)) >> CCM_TUPLE_SHIFT(mux);
600058de:	4d12      	ldr	r5, [pc, #72]	; (60005928 <mcux_ccm_get_subsys_rate+0x7c>)
		*rate = CLOCK_GetFreq(lpspi_clock)
600058e0:	4a13      	ldr	r2, [pc, #76]	; (60005930 <mcux_ccm_get_subsys_rate+0x84>)
600058e2:	69ab      	ldr	r3, [r5, #24]
600058e4:	f3c3 1301 	ubfx	r3, r3, #4, #2
600058e8:	5cd0      	ldrb	r0, [r2, r3]
600058ea:	f001 fab1 	bl	60006e50 <CLOCK_GetFreq>
    return ((CCM_TUPLE_REG(CCM, divider) & CCM_TUPLE_MASK(divider)) >> CCM_TUPLE_SHIFT(divider));
600058ee:	69ab      	ldr	r3, [r5, #24]
600058f0:	f3c3 6382 	ubfx	r3, r3, #26, #3
				/ (CLOCK_GetDiv(kCLOCK_UartDiv) + 1);
600058f4:	3301      	adds	r3, #1
600058f6:	fbb0 f0f3 	udiv	r0, r0, r3
		break;
#endif

#ifdef CONFIG_DMA_MCUX_EDMA
	case IMX_CCM_EDMA_CLK:
		*rate = CLOCK_GetIpgFreq();
600058fa:	6020      	str	r0, [r4, #0]
		break;
600058fc:	e00d      	b.n	6000591a <mcux_ccm_get_subsys_rate+0x6e>
    return ((XTALOSC24M->LOWPWR_CTRL & (uint32_t)XTALOSC24M_LOWPWR_CTRL_OSC_SEL_MASK) != 0UL) ? 24000000UL : g_xtalFreq;
600058fe:	4b0d      	ldr	r3, [pc, #52]	; (60005934 <mcux_ccm_get_subsys_rate+0x88>)
60005900:	f8d3 3270 	ldr.w	r3, [r3, #624]	; 0x270
60005904:	06db      	lsls	r3, r3, #27
60005906:	d40a      	bmi.n	6000591e <mcux_ccm_get_subsys_rate+0x72>
60005908:	4b0b      	ldr	r3, [pc, #44]	; (60005938 <mcux_ccm_get_subsys_rate+0x8c>)
6000590a:	681a      	ldr	r2, [r3, #0]
    return ((CCM_TUPLE_REG(CCM, divider) & CCM_TUPLE_MASK(divider)) >> CCM_TUPLE_SHIFT(divider));
6000590c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
6000590e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
				/ (CLOCK_GetDiv(kCLOCK_UartDiv) + 1);
60005912:	3301      	adds	r3, #1
60005914:	fbb2 f2f3 	udiv	r2, r2, r3
			*rate = CLOCK_GetOscFreq()
60005918:	6022      	str	r2, [r4, #0]
		break;
#endif
	}

	return 0;
}
6000591a:	2000      	movs	r0, #0
6000591c:	bd38      	pop	{r3, r4, r5, pc}
    return ((XTALOSC24M->LOWPWR_CTRL & (uint32_t)XTALOSC24M_LOWPWR_CTRL_OSC_SEL_MASK) != 0UL) ? 24000000UL : g_xtalFreq;
6000591e:	4a07      	ldr	r2, [pc, #28]	; (6000593c <mcux_ccm_get_subsys_rate+0x90>)
60005920:	e7f4      	b.n	6000590c <mcux_ccm_get_subsys_rate+0x60>
		*rate = CLOCK_GetIpgFreq();
60005922:	f001 fa57 	bl	60006dd4 <CLOCK_GetIpgFreq>
60005926:	e7e8      	b.n	600058fa <mcux_ccm_get_subsys_rate+0x4e>
60005928:	400fc000 	.word	0x400fc000
6000592c:	0010000d 	.word	0x0010000d
60005930:	6000d023 	.word	0x6000d023
60005934:	400d8000 	.word	0x400d8000
60005938:	8000162c 	.word	0x8000162c
6000593c:	016e3600 	.word	0x016e3600

60005940 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
60005940:	b508      	push	{r3, lr}
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
60005942:	4807      	ldr	r0, [pc, #28]	; (60005960 <uart_console_init+0x20>)
60005944:	f005 fd9e 	bl	6000b484 <z_device_is_ready>

	ARG_UNUSED(arg);

	if (!device_is_ready(uart_console_dev)) {
60005948:	b138      	cbz	r0, 6000595a <uart_console_init+0x1a>
	__stdout_hook_install(console_out);
6000594a:	4806      	ldr	r0, [pc, #24]	; (60005964 <uart_console_init+0x24>)
6000594c:	f7ff fc6e 	bl	6000522c <__stdout_hook_install>
	__printk_hook_install(console_out);
60005950:	4804      	ldr	r0, [pc, #16]	; (60005964 <uart_console_init+0x24>)
60005952:	f7fe fa95 	bl	60003e80 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
60005956:	2000      	movs	r0, #0
}
60005958:	bd08      	pop	{r3, pc}
		return -ENODEV;
6000595a:	f06f 0012 	mvn.w	r0, #18
6000595e:	e7fb      	b.n	60005958 <uart_console_init+0x18>
60005960:	6000b588 	.word	0x6000b588
60005964:	60005969 	.word	0x60005969

60005968 <console_out>:
	if ('\n' == c) {
60005968:	280a      	cmp	r0, #10
{
6000596a:	b538      	push	{r3, r4, r5, lr}
6000596c:	4604      	mov	r4, r0
6000596e:	4d07      	ldr	r5, [pc, #28]	; (6000598c <console_out+0x24>)
	if ('\n' == c) {
60005970:	d104      	bne.n	6000597c <console_out+0x14>
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
60005972:	68ab      	ldr	r3, [r5, #8]
60005974:	210d      	movs	r1, #13
60005976:	4628      	mov	r0, r5
60005978:	685b      	ldr	r3, [r3, #4]
6000597a:	4798      	blx	r3
6000597c:	68ab      	ldr	r3, [r5, #8]
6000597e:	b2e1      	uxtb	r1, r4
60005980:	4802      	ldr	r0, [pc, #8]	; (6000598c <console_out+0x24>)
60005982:	685b      	ldr	r3, [r3, #4]
60005984:	4798      	blx	r3
}
60005986:	4620      	mov	r0, r4
60005988:	bd38      	pop	{r3, r4, r5, pc}
6000598a:	bf00      	nop
6000598c:	6000b588 	.word	0x6000b588

60005990 <data_size_valid>:
#define DEV_EDMA_HANDLE(dev, ch) \
	((edma_handle_t *)(&(DEV_CHANNEL_DATA(dev, ch)->edma_handle)))

static bool data_size_valid(const size_t data_size)
{
	return (data_size == 4U || data_size == 2U ||
60005990:	2802      	cmp	r0, #2
60005992:	d809      	bhi.n	600059a8 <data_size_valid+0x18>
60005994:	3800      	subs	r0, #0
60005996:	bf18      	it	ne
60005998:	2001      	movne	r0, #1
6000599a:	4770      	bx	lr
6000599c:	4b05      	ldr	r3, [pc, #20]	; (600059b4 <data_size_valid+0x24>)
6000599e:	fa23 f000 	lsr.w	r0, r3, r0
600059a2:	f000 0001 	and.w	r0, r0, #1
600059a6:	4770      	bx	lr
600059a8:	3804      	subs	r0, #4
600059aa:	281c      	cmp	r0, #28
600059ac:	d9f6      	bls.n	6000599c <data_size_valid+0xc>
{
600059ae:	2000      	movs	r0, #0
		data_size == 1U || data_size == 8U ||
		data_size == 16U ||
		data_size == 32U);
}
600059b0:	4770      	bx	lr
600059b2:	bf00      	nop
600059b4:	10001011 	.word	0x10001011

600059b8 <dma_mcux_edma_reload>:
}


static int dma_mcux_edma_reload(const struct device *dev, uint32_t channel,
				uint32_t src, uint32_t dst, size_t size)
{
600059b8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
600059bc:	460c      	mov	r4, r1
600059be:	4680      	mov	r8, r0
600059c0:	4611      	mov	r1, r2
	struct call_back *data = DEV_CHANNEL_DATA(dev, channel);
600059c2:	6905      	ldr	r5, [r0, #16]
	__asm__ volatile(
600059c4:	f04f 0210 	mov.w	r2, #16
600059c8:	f3ef 8711 	mrs	r7, BASEPRI
600059cc:	f382 8812 	msr	BASEPRI_MAX, r2
600059d0:	f3bf 8f6f 	isb	sy

	/* Lock the channel configuration */
	const unsigned int key = irq_lock();
	int ret = 0;

	if (!data->transfer_settings.valid) {
600059d4:	2654      	movs	r6, #84	; 0x54
600059d6:	fb06 5604 	mla	r6, r6, r4, r5
600059da:	f896 205a 	ldrb.w	r2, [r6, #90]	; 0x5a
600059de:	b932      	cbnz	r2, 600059ee <dma_mcux_edma_reload+0x36>
		LOG_ERR("Invalid EDMA settings on initial config. Configure DMA before reload.");
600059e0:	2145      	movs	r1, #69	; 0x45
600059e2:	481d      	ldr	r0, [pc, #116]	; (60005a58 <dma_mcux_edma_reload+0xa0>)
600059e4:	f005 f87c 	bl	6000aae0 <z_log_minimal_printk>
		ret = -EFAULT;
600059e8:	f06f 000d 	mvn.w	r0, #13
600059ec:	e00a      	b.n	60005a04 <dma_mcux_edma_reload+0x4c>
		goto cleanup;
	}

	/* If the tcdPool is not in use (no s/g) then only a single TCD can be active at once. */
	if (data->busy && data->edma_handle.tcdPool == NULL) {
600059ee:	f896 205c 	ldrb.w	r2, [r6, #92]	; 0x5c
600059f2:	b172      	cbz	r2, 60005a12 <dma_mcux_edma_reload+0x5a>
600059f4:	6b32      	ldr	r2, [r6, #48]	; 0x30
600059f6:	b962      	cbnz	r2, 60005a12 <dma_mcux_edma_reload+0x5a>
		LOG_ERR("EDMA busy. Wait until the transfer completes before reloading.");
600059f8:	4818      	ldr	r0, [pc, #96]	; (60005a5c <dma_mcux_edma_reload+0xa4>)
600059fa:	2145      	movs	r1, #69	; 0x45
600059fc:	f005 f870 	bl	6000aae0 <z_log_minimal_printk>
		ret = -EBUSY;
60005a00:	f06f 000f 	mvn.w	r0, #15
	__asm__ volatile(
60005a04:	f387 8811 	msr	BASEPRI, r7
60005a08:	f3bf 8f6f 	isb	sy
	}

cleanup:
	irq_unlock(key);
	return ret;
}
60005a0c:	b004      	add	sp, #16
60005a0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	EDMA_PrepareTransfer(
60005a12:	2254      	movs	r2, #84	; 0x54
60005a14:	4354      	muls	r4, r2
60005a16:	f104 060c 	add.w	r6, r4, #12
60005a1a:	442e      	add	r6, r5
60005a1c:	4425      	add	r5, r4
		EDMA_SubmitTransfer(DEV_EDMA_HANDLE(dev, channel), &(data->transferConfig));
60005a1e:	3424      	adds	r4, #36	; 0x24
	EDMA_PrepareTransfer(
60005a20:	f895 2059 	ldrb.w	r2, [r5, #89]	; 0x59
60005a24:	4630      	mov	r0, r6
60005a26:	9203      	str	r2, [sp, #12]
60005a28:	9a0a      	ldr	r2, [sp, #40]	; 0x28
60005a2a:	9202      	str	r2, [sp, #8]
60005a2c:	6d2a      	ldr	r2, [r5, #80]	; 0x50
60005a2e:	9201      	str	r2, [sp, #4]
60005a30:	6cea      	ldr	r2, [r5, #76]	; 0x4c
60005a32:	9200      	str	r2, [sp, #0]
60005a34:	6caa      	ldr	r2, [r5, #72]	; 0x48
60005a36:	f001 ff81 	bl	6000793c <EDMA_PrepareTransfer>
		EDMA_SubmitTransfer(DEV_EDMA_HANDLE(dev, channel), &(data->transferConfig));
60005a3a:	f8d8 0010 	ldr.w	r0, [r8, #16]
60005a3e:	4631      	mov	r1, r6
60005a40:	4420      	add	r0, r4
60005a42:	f001 ffbd 	bl	600079c0 <EDMA_SubmitTransfer>
	if (submit_status != kStatus_Success) {
60005a46:	2800      	cmp	r0, #0
60005a48:	d0dc      	beq.n	60005a04 <dma_mcux_edma_reload+0x4c>
		LOG_ERR("Error submitting EDMA Transfer: 0x%x", submit_status);
60005a4a:	4602      	mov	r2, r0
60005a4c:	2145      	movs	r1, #69	; 0x45
60005a4e:	4804      	ldr	r0, [pc, #16]	; (60005a60 <dma_mcux_edma_reload+0xa8>)
60005a50:	f005 f846 	bl	6000aae0 <z_log_minimal_printk>
		ret = -EFAULT;
60005a54:	e7c8      	b.n	600059e8 <dma_mcux_edma_reload+0x30>
60005a56:	bf00      	nop
60005a58:	6000d027 	.word	0x6000d027
60005a5c:	6000d072 	.word	0x6000d072
60005a60:	6000d0b6 	.word	0x6000d0b6

60005a64 <dma_mcux_edma_error_irq_handler>:
{
60005a64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60005a68:	4605      	mov	r5, r0
	for (i = 0; i < DT_INST_PROP(0, dma_channels); i++) {
60005a6a:	2400      	movs	r4, #0
		if (DEV_CHANNEL_DATA(dev, i)->busy) {
60005a6c:	2754      	movs	r7, #84	; 0x54
			LOG_INF("channel %d error status is 0x%x", i, flag);
60005a6e:	f8df 8054 	ldr.w	r8, [pc, #84]	; 60005ac4 <dma_mcux_edma_error_irq_handler+0x60>
		if (DEV_CHANNEL_DATA(dev, i)->busy) {
60005a72:	692b      	ldr	r3, [r5, #16]
60005a74:	fb07 f604 	mul.w	r6, r7, r4
60005a78:	4433      	add	r3, r6
60005a7a:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
60005a7e:	b1e3      	cbz	r3, 60005aba <dma_mcux_edma_error_irq_handler+0x56>
			flag = EDMA_GetChannelStatusFlags(DEV_BASE(dev), i);
60005a80:	686b      	ldr	r3, [r5, #4]
60005a82:	4621      	mov	r1, r4
60005a84:	6818      	ldr	r0, [r3, #0]
60005a86:	f001 fdb1 	bl	600075ec <EDMA_GetChannelStatusFlags>
			LOG_INF("channel %d error status is 0x%x", i, flag);
60005a8a:	4622      	mov	r2, r4
			flag = EDMA_GetChannelStatusFlags(DEV_BASE(dev), i);
60005a8c:	4603      	mov	r3, r0
			LOG_INF("channel %d error status is 0x%x", i, flag);
60005a8e:	2149      	movs	r1, #73	; 0x49
60005a90:	4640      	mov	r0, r8
60005a92:	f005 f825 	bl	6000aae0 <z_log_minimal_printk>
			EDMA_ClearChannelStatusFlags(DEV_BASE(dev), i,
60005a96:	686b      	ldr	r3, [r5, #4]
60005a98:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60005a9c:	4621      	mov	r1, r4
60005a9e:	6818      	ldr	r0, [r3, #0]
60005aa0:	f001 fdce 	bl	60007640 <EDMA_ClearChannelStatusFlags>
			EDMA_AbortTransfer(DEV_EDMA_HANDLE(dev, i));
60005aa4:	f106 0324 	add.w	r3, r6, #36	; 0x24
60005aa8:	6928      	ldr	r0, [r5, #16]
60005aaa:	4418      	add	r0, r3
60005aac:	f005 fcc0 	bl	6000b430 <EDMA_AbortTransfer>
			DEV_CHANNEL_DATA(dev, i)->busy = false;
60005ab0:	692b      	ldr	r3, [r5, #16]
60005ab2:	2200      	movs	r2, #0
60005ab4:	4433      	add	r3, r6
60005ab6:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
	for (i = 0; i < DT_INST_PROP(0, dma_channels); i++) {
60005aba:	3401      	adds	r4, #1
60005abc:	2c20      	cmp	r4, #32
60005abe:	d1d8      	bne.n	60005a72 <dma_mcux_edma_error_irq_handler+0xe>
}
60005ac0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
60005ac4:	6000d0e0 	.word	0x6000d0e0

60005ac8 <dma_mcux_edma_init>:
	.get_status = dma_mcux_edma_get_status,
	.chan_filter = dma_mcux_edma_channel_filter,
};

static int dma_mcux_edma_init(const struct device *dev)
{
60005ac8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	const struct dma_mcux_edma_config *config = dev->config;
60005aca:	6847      	ldr	r7, [r0, #4]
	struct dma_mcux_edma_data *data = dev->data;

	edma_config_t userConfig = { 0 };
60005acc:	2500      	movs	r5, #0
	struct dma_mcux_edma_data *data = dev->data;
60005ace:	6906      	ldr	r6, [r0, #16]
{
60005ad0:	4604      	mov	r4, r0

	LOG_DBG("INIT NXP EDMA");
	DMAMUX_Init(DEV_DMAMUX_BASE(dev));
60005ad2:	6878      	ldr	r0, [r7, #4]
	edma_config_t userConfig = { 0 };
60005ad4:	9501      	str	r5, [sp, #4]
	DMAMUX_Init(DEV_DMAMUX_BASE(dev));
60005ad6:	f002 f939 	bl	60007d4c <DMAMUX_Init>
	EDMA_GetDefaultConfig(&userConfig);
60005ada:	a801      	add	r0, sp, #4
60005adc:	f001 fb6a 	bl	600071b4 <EDMA_GetDefaultConfig>
	EDMA_Init(DEV_BASE(dev), &userConfig);
60005ae0:	6863      	ldr	r3, [r4, #4]
60005ae2:	a901      	add	r1, sp, #4
60005ae4:	6818      	ldr	r0, [r3, #0]
60005ae6:	f001 fb27 	bl	60007138 <EDMA_Init>
	config->irq_config_func(dev);
60005aea:	68fb      	ldr	r3, [r7, #12]
60005aec:	4620      	mov	r0, r4
60005aee:	4798      	blx	r3
	memset(dev->data, 0, sizeof(struct dma_mcux_edma_data));
60005af0:	4629      	mov	r1, r5
60005af2:	f44f 6229 	mov.w	r2, #2704	; 0xa90
60005af6:	6920      	ldr	r0, [r4, #16]
60005af8:	f005 f849 	bl	6000ab8e <memset>
	memset(tcdpool, 0, sizeof(tcdpool));
60005afc:	f44f 6200 	mov.w	r2, #2048	; 0x800
60005b00:	4629      	mov	r1, r5
60005b02:	4806      	ldr	r0, [pc, #24]	; (60005b1c <dma_mcux_edma_init+0x54>)
60005b04:	f005 f843 	bl	6000ab8e <memset>
	data->dma_ctx.magic = DMA_MAGIC;
60005b08:	4b05      	ldr	r3, [pc, #20]	; (60005b20 <dma_mcux_edma_init+0x58>)
	data->dma_ctx.dma_channels = config->dma_channels;
	data->dma_ctx.atomic = data->channels_atomic;
	return 0;
}
60005b0a:	4628      	mov	r0, r5
	data->dma_ctx.magic = DMA_MAGIC;
60005b0c:	6033      	str	r3, [r6, #0]
	data->dma_ctx.dma_channels = config->dma_channels;
60005b0e:	68bb      	ldr	r3, [r7, #8]
60005b10:	6073      	str	r3, [r6, #4]
	data->dma_ctx.atomic = data->channels_atomic;
60005b12:	f606 238c 	addw	r3, r6, #2700	; 0xa8c
60005b16:	60b3      	str	r3, [r6, #8]
}
60005b18:	b003      	add	sp, #12
60005b1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
60005b1c:	80000000 	.word	0x80000000
60005b20:	47494749 	.word	0x47494749

60005b24 <dma_mcux_edma_configure>:
{
60005b24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60005b28:	460d      	mov	r5, r1
60005b2a:	b087      	sub	sp, #28
60005b2c:	4614      	mov	r4, r2
	if (NULL == dev || NULL == config) {
60005b2e:	4606      	mov	r6, r0
60005b30:	b300      	cbz	r0, 60005b74 <dma_mcux_edma_configure+0x50>
60005b32:	b1fa      	cbz	r2, 60005b74 <dma_mcux_edma_configure+0x50>
	edma_handle_t *p_handle = DEV_EDMA_HANDLE(dev, channel);
60005b34:	2354      	movs	r3, #84	; 0x54
60005b36:	6907      	ldr	r7, [r0, #16]
	struct dma_block_config *block_config = config->head_block;
60005b38:	f8d2 8010 	ldr.w	r8, [r2, #16]
60005b3c:	434b      	muls	r3, r1
	uint32_t slot = config->dma_slot;
60005b3e:	7811      	ldrb	r1, [r2, #0]
	edma_handle_t *p_handle = DEV_EDMA_HANDLE(dev, channel);
60005b40:	f103 0a24 	add.w	sl, r3, #36	; 0x24
	struct call_back *data = DEV_CHANNEL_DATA(dev, channel);
60005b44:	f103 0b0c 	add.w	fp, r3, #12
	if (slot > DT_INST_PROP(0, dma_requests)) {
60005b48:	2980      	cmp	r1, #128	; 0x80
	edma_handle_t *p_handle = DEV_EDMA_HANDLE(dev, channel);
60005b4a:	44ba      	add	sl, r7
	struct call_back *data = DEV_CHANNEL_DATA(dev, channel);
60005b4c:	44bb      	add	fp, r7
	if (slot > DT_INST_PROP(0, dma_requests)) {
60005b4e:	d90a      	bls.n	60005b66 <dma_mcux_edma_configure+0x42>
		return -ENOTSUP;
60005b50:	f06f 0985 	mvn.w	r9, #133	; 0x85
		LOG_ERR("source number is outof scope %d", slot);
60005b54:	460a      	mov	r2, r1
60005b56:	4897      	ldr	r0, [pc, #604]	; (60005db4 <dma_mcux_edma_configure+0x290>)
60005b58:	2145      	movs	r1, #69	; 0x45
60005b5a:	f004 ffc1 	bl	6000aae0 <z_log_minimal_printk>
}
60005b5e:	4648      	mov	r0, r9
60005b60:	b007      	add	sp, #28
60005b62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (channel > DT_INST_PROP(0, dma_channels)) {
60005b66:	2d20      	cmp	r5, #32
60005b68:	d907      	bls.n	60005b7a <dma_mcux_edma_configure+0x56>
		LOG_ERR("out of DMA channel %d", channel);
60005b6a:	462a      	mov	r2, r5
60005b6c:	2145      	movs	r1, #69	; 0x45
60005b6e:	4892      	ldr	r0, [pc, #584]	; (60005db8 <dma_mcux_edma_configure+0x294>)
60005b70:	f004 ffb6 	bl	6000aae0 <z_log_minimal_printk>
		return -EINVAL;
60005b74:	f06f 0915 	mvn.w	r9, #21
60005b78:	e7f1      	b.n	60005b5e <dma_mcux_edma_configure+0x3a>
	data->transfer_settings.valid = false;
60005b7a:	443b      	add	r3, r7
60005b7c:	2200      	movs	r2, #0
60005b7e:	f883 205a 	strb.w	r2, [r3, #90]	; 0x5a
	switch (config->channel_direction) {
60005b82:	7863      	ldrb	r3, [r4, #1]
60005b84:	f003 0307 	and.w	r3, r3, #7
60005b88:	2b03      	cmp	r3, #3
60005b8a:	d80c      	bhi.n	60005ba6 <dma_mcux_edma_configure+0x82>
60005b8c:	4a8b      	ldr	r2, [pc, #556]	; (60005dbc <dma_mcux_edma_configure+0x298>)
	if (!data_size_valid(config->source_data_size)) {
60005b8e:	f8b4 9004 	ldrh.w	r9, [r4, #4]
60005b92:	5cd3      	ldrb	r3, [r2, r3]
60005b94:	4648      	mov	r0, r9
60005b96:	9304      	str	r3, [sp, #16]
60005b98:	f7ff fefa 	bl	60005990 <data_size_valid>
60005b9c:	b940      	cbnz	r0, 60005bb0 <dma_mcux_edma_configure+0x8c>
		LOG_ERR("Source unit size error, %d", config->source_data_size);
60005b9e:	464a      	mov	r2, r9
60005ba0:	2145      	movs	r1, #69	; 0x45
60005ba2:	4887      	ldr	r0, [pc, #540]	; (60005dc0 <dma_mcux_edma_configure+0x29c>)
60005ba4:	e7e4      	b.n	60005b70 <dma_mcux_edma_configure+0x4c>
		LOG_ERR("not support transfer direction");
60005ba6:	2145      	movs	r1, #69	; 0x45
60005ba8:	4886      	ldr	r0, [pc, #536]	; (60005dc4 <dma_mcux_edma_configure+0x2a0>)
60005baa:	f004 ff99 	bl	6000aae0 <z_log_minimal_printk>
		return -EINVAL;
60005bae:	e7e1      	b.n	60005b74 <dma_mcux_edma_configure+0x50>
	if (!data_size_valid(config->dest_data_size)) {
60005bb0:	88e2      	ldrh	r2, [r4, #6]
60005bb2:	4610      	mov	r0, r2
60005bb4:	f7ff feec 	bl	60005990 <data_size_valid>
60005bb8:	b910      	cbnz	r0, 60005bc0 <dma_mcux_edma_configure+0x9c>
		LOG_ERR("Dest unit size error, %d", config->dest_data_size);
60005bba:	2145      	movs	r1, #69	; 0x45
60005bbc:	4882      	ldr	r0, [pc, #520]	; (60005dc8 <dma_mcux_edma_configure+0x2a4>)
60005bbe:	e7d7      	b.n	60005b70 <dma_mcux_edma_configure+0x4c>
	if (block_config->source_gather_en || block_config->dest_scatter_en) {
60005bc0:	f898 301c 	ldrb.w	r3, [r8, #28]
60005bc4:	0798      	lsls	r0, r3, #30
60005bc6:	d005      	beq.n	60005bd4 <dma_mcux_edma_configure+0xb0>
		if (config->block_count > CONFIG_DMA_TCD_QUEUE_SIZE) {
60005bc8:	68e2      	ldr	r2, [r4, #12]
60005bca:	2a02      	cmp	r2, #2
60005bcc:	d902      	bls.n	60005bd4 <dma_mcux_edma_configure+0xb0>
			LOG_ERR("please config DMA_TCD_QUEUE_SIZE as %d", config->block_count);
60005bce:	2145      	movs	r1, #69	; 0x45
60005bd0:	487e      	ldr	r0, [pc, #504]	; (60005dcc <dma_mcux_edma_configure+0x2a8>)
60005bd2:	e7cd      	b.n	60005b70 <dma_mcux_edma_configure+0x4c>
	data->transfer_settings.source_data_size = config->source_data_size;
60005bd4:	2354      	movs	r3, #84	; 0x54
60005bd6:	fb03 7305 	mla	r3, r3, r5, r7
60005bda:	f8c3 9048 	str.w	r9, [r3, #72]	; 0x48
	data->transfer_settings.dest_data_size = config->dest_data_size;
60005bde:	88e2      	ldrh	r2, [r4, #6]
60005be0:	64da      	str	r2, [r3, #76]	; 0x4c
	data->transfer_settings.source_burst_length = config->source_burst_length;
60005be2:	8922      	ldrh	r2, [r4, #8]
60005be4:	651a      	str	r2, [r3, #80]	; 0x50
	data->transfer_settings.dest_burst_length = config->dest_burst_length;
60005be6:	8962      	ldrh	r2, [r4, #10]
60005be8:	655a      	str	r2, [r3, #84]	; 0x54
	data->transfer_settings.direction = config->channel_direction;
60005bea:	7862      	ldrb	r2, [r4, #1]
60005bec:	f3c2 0202 	ubfx	r2, r2, #0, #3
60005bf0:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	data->transfer_settings.transfer_type = transfer_type;
60005bf4:	9a04      	ldr	r2, [sp, #16]
60005bf6:	f883 2059 	strb.w	r2, [r3, #89]	; 0x59
	data->transfer_settings.valid = true;
60005bfa:	2201      	movs	r2, #1
60005bfc:	f883 205a 	strb.w	r2, [r3, #90]	; 0x5a
	__asm__ volatile(
60005c00:	f04f 0310 	mov.w	r3, #16
60005c04:	f3ef 8211 	mrs	r2, BASEPRI
60005c08:	f383 8812 	msr	BASEPRI_MAX, r3
60005c0c:	f3bf 8f6f 	isb	sy
	if (config->source_handshake || config->dest_handshake ||
60005c10:	7863      	ldrb	r3, [r4, #1]
60005c12:	9205      	str	r2, [sp, #20]
60005c14:	f013 0f60 	tst.w	r3, #96	; 0x60
60005c18:	6873      	ldr	r3, [r6, #4]
60005c1a:	d103      	bne.n	60005c24 <dma_mcux_edma_configure+0x100>
60005c1c:	9a04      	ldr	r2, [sp, #16]
60005c1e:	2a00      	cmp	r2, #0
60005c20:	f040 8094 	bne.w	60005d4c <dma_mcux_edma_configure+0x228>
 * @param channel DMAMUX channel number.
 * @param enable Switcher of the always ON feature. "true" means enabled, "false" means disabled.
 */
static inline void DMAMUX_EnableAlwaysOn(DMAMUX_Type *base, uint32_t channel, bool enable)
{
    assert(channel < (uint32_t)FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
60005c24:	2d20      	cmp	r5, #32
		DMAMUX_EnableAlwaysOn(DEV_DMAMUX_BASE(dev), channel, true);
60005c26:	685a      	ldr	r2, [r3, #4]
60005c28:	d109      	bne.n	60005c3e <dma_mcux_edma_configure+0x11a>
60005c2a:	4969      	ldr	r1, [pc, #420]	; (60005dd0 <dma_mcux_edma_configure+0x2ac>)
60005c2c:	23a8      	movs	r3, #168	; 0xa8
60005c2e:	4a69      	ldr	r2, [pc, #420]	; (60005dd4 <dma_mcux_edma_configure+0x2b0>)
60005c30:	4869      	ldr	r0, [pc, #420]	; (60005dd8 <dma_mcux_edma_configure+0x2b4>)
60005c32:	f004 ff45 	bl	6000aac0 <assert_print>
60005c36:	21a8      	movs	r1, #168	; 0xa8
    assert(channel < (uint32_t)FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
60005c38:	4866      	ldr	r0, [pc, #408]	; (60005dd4 <dma_mcux_edma_configure+0x2b0>)
60005c3a:	f004 ff3a 	bl	6000aab2 <assert_post_action>

    if (enable)
    {
        base->CHCFG[channel] |= DMAMUX_CHCFG_A_ON_MASK;
60005c3e:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
60005c42:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    base->CHCFG[channel] = ((base->CHCFG[channel] & ~DMAMUX_CHCFG_SOURCE_MASK) | DMAMUX_CHCFG_SOURCE(source));
60005c46:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
	DMAMUX_EnableChannel(DEV_DMAMUX_BASE(dev), channel);
60005c4a:	6873      	ldr	r3, [r6, #4]
60005c4c:	685b      	ldr	r3, [r3, #4]
    base->CHCFG[channel] |= DMAMUX_CHCFG_ENBL_MASK;
60005c4e:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
60005c52:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
60005c56:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
	if (data->busy) {
60005c5a:	2354      	movs	r3, #84	; 0x54
60005c5c:	fb03 7305 	mla	r3, r3, r5, r7
60005c60:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
60005c64:	b113      	cbz	r3, 60005c6c <dma_mcux_edma_configure+0x148>
		EDMA_AbortTransfer(p_handle);
60005c66:	4650      	mov	r0, sl
60005c68:	f005 fbe2 	bl	6000b430 <EDMA_AbortTransfer>
	EDMA_ResetChannel(DEV_BASE(dev), channel);
60005c6c:	6873      	ldr	r3, [r6, #4]
60005c6e:	4629      	mov	r1, r5
60005c70:	6818      	ldr	r0, [r3, #0]
60005c72:	f001 fb21 	bl	600072b8 <EDMA_ResetChannel>
	EDMA_CreateHandle(p_handle, DEV_BASE(dev), channel);
60005c76:	6873      	ldr	r3, [r6, #4]
60005c78:	462a      	mov	r2, r5
60005c7a:	4650      	mov	r0, sl
60005c7c:	6819      	ldr	r1, [r3, #0]
60005c7e:	f001 fd01 	bl	60007684 <EDMA_CreateHandle>
	EDMA_SetCallback(p_handle, nxp_edma_callback, (void *)data);
60005c82:	465a      	mov	r2, fp
60005c84:	4955      	ldr	r1, [pc, #340]	; (60005ddc <dma_mcux_edma_configure+0x2b8>)
60005c86:	4650      	mov	r0, sl
60005c88:	f001 fd9a 	bl	600077c0 <EDMA_SetCallback>
	EDMA_EnableChannelInterrupts(DEV_BASE(dev), channel, kEDMA_ErrorInterruptEnable);
60005c8c:	6873      	ldr	r3, [r6, #4]
60005c8e:	4629      	mov	r1, r5
60005c90:	2201      	movs	r2, #1
60005c92:	6818      	ldr	r0, [r3, #0]
60005c94:	f001 faac 	bl	600071f0 <EDMA_EnableChannelInterrupts>
	if (block_config->source_gather_en || block_config->dest_scatter_en) {
60005c98:	f898 301c 	ldrb.w	r3, [r8, #28]
60005c9c:	0799      	lsls	r1, r3, #30
60005c9e:	d068      	beq.n	60005d72 <dma_mcux_edma_configure+0x24e>
		EDMA_InstallTCDMemory(p_handle, tcdpool[channel], CONFIG_DMA_TCD_QUEUE_SIZE);
60005ca0:	494f      	ldr	r1, [pc, #316]	; (60005de0 <dma_mcux_edma_configure+0x2bc>)
	int ret = 0;
60005ca2:	f04f 0900 	mov.w	r9, #0
		EDMA_InstallTCDMemory(p_handle, tcdpool[channel], CONFIG_DMA_TCD_QUEUE_SIZE);
60005ca6:	2202      	movs	r2, #2
60005ca8:	4650      	mov	r0, sl
60005caa:	eb01 1185 	add.w	r1, r1, r5, lsl #6
60005cae:	f001 fd5b 	bl	60007768 <EDMA_InstallTCDMemory>
			EDMA_PrepareTransfer(
60005cb2:	9b04      	ldr	r3, [sp, #16]
60005cb4:	4658      	mov	r0, fp
60005cb6:	9303      	str	r3, [sp, #12]
60005cb8:	f8d8 3014 	ldr.w	r3, [r8, #20]
60005cbc:	9302      	str	r3, [sp, #8]
60005cbe:	8923      	ldrh	r3, [r4, #8]
60005cc0:	9301      	str	r3, [sp, #4]
60005cc2:	88e3      	ldrh	r3, [r4, #6]
60005cc4:	9300      	str	r3, [sp, #0]
60005cc6:	88a2      	ldrh	r2, [r4, #4]
60005cc8:	f8d8 3004 	ldr.w	r3, [r8, #4]
60005ccc:	f8d8 1000 	ldr.w	r1, [r8]
60005cd0:	f001 fe34 	bl	6000793c <EDMA_PrepareTransfer>
				EDMA_SubmitTransfer(p_handle, &(data->transferConfig));
60005cd4:	4659      	mov	r1, fp
60005cd6:	4650      	mov	r0, sl
60005cd8:	f001 fe72 	bl	600079c0 <EDMA_SubmitTransfer>
			if (submit_status != kStatus_Success) {
60005cdc:	4602      	mov	r2, r0
60005cde:	b128      	cbz	r0, 60005cec <dma_mcux_edma_configure+0x1c8>
				ret = -EFAULT;
60005ce0:	f06f 090d 	mvn.w	r9, #13
				LOG_ERR("Error submitting EDMA Transfer: 0x%x", submit_status);
60005ce4:	2145      	movs	r1, #69	; 0x45
60005ce6:	483f      	ldr	r0, [pc, #252]	; (60005de4 <dma_mcux_edma_configure+0x2c0>)
60005ce8:	f004 fefa 	bl	6000aae0 <z_log_minimal_printk>
			block_config = block_config->next_block;
60005cec:	f8d8 8018 	ldr.w	r8, [r8, #24]
		while (block_config != NULL) {
60005cf0:	f1b8 0f00 	cmp.w	r8, #0
60005cf4:	d1dd      	bne.n	60005cb2 <dma_mcux_edma_configure+0x18e>
	if (config->dest_chaining_en) {
60005cf6:	78a3      	ldrb	r3, [r4, #2]
60005cf8:	06da      	lsls	r2, r3, #27
60005cfa:	d508      	bpl.n	60005d0e <dma_mcux_edma_configure+0x1ea>
				    config->linked_channel);
60005cfc:	8863      	ldrh	r3, [r4, #2]
		EDMA_SetChannelLink(DEV_BASE(dev), channel, kEDMA_MajorLink,
60005cfe:	2202      	movs	r2, #2
60005d00:	6870      	ldr	r0, [r6, #4]
60005d02:	4629      	mov	r1, r5
60005d04:	f3c3 1346 	ubfx	r3, r3, #5, #7
60005d08:	6800      	ldr	r0, [r0, #0]
60005d0a:	f001 fc17 	bl	6000753c <EDMA_SetChannelLink>
	if (config->source_chaining_en) {
60005d0e:	78a3      	ldrb	r3, [r4, #2]
60005d10:	071b      	lsls	r3, r3, #28
60005d12:	d508      	bpl.n	60005d26 <dma_mcux_edma_configure+0x202>
				    config->linked_channel);
60005d14:	8863      	ldrh	r3, [r4, #2]
		EDMA_SetChannelLink(DEV_BASE(dev), channel, kEDMA_MinorLink,
60005d16:	2201      	movs	r2, #1
60005d18:	6870      	ldr	r0, [r6, #4]
60005d1a:	4629      	mov	r1, r5
60005d1c:	f3c3 1346 	ubfx	r3, r3, #5, #7
60005d20:	6800      	ldr	r0, [r0, #0]
60005d22:	f001 fc0b 	bl	6000753c <EDMA_SetChannelLink>
	data->busy = false;
60005d26:	2354      	movs	r3, #84	; 0x54
60005d28:	fb03 7705 	mla	r7, r3, r5, r7
60005d2c:	2300      	movs	r3, #0
60005d2e:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
	if (config->dma_callback) {
60005d32:	69a3      	ldr	r3, [r4, #24]
60005d34:	b123      	cbz	r3, 60005d40 <dma_mcux_edma_configure+0x21c>
		data->user_data = config->user_data;
60005d36:	6963      	ldr	r3, [r4, #20]
60005d38:	643b      	str	r3, [r7, #64]	; 0x40
		data->dma_callback = config->dma_callback;
60005d3a:	69a3      	ldr	r3, [r4, #24]
		data->dev = dev;
60005d3c:	63fe      	str	r6, [r7, #60]	; 0x3c
		data->dma_callback = config->dma_callback;
60005d3e:	647b      	str	r3, [r7, #68]	; 0x44
	__asm__ volatile(
60005d40:	9b05      	ldr	r3, [sp, #20]
60005d42:	f383 8811 	msr	BASEPRI, r3
60005d46:	f3bf 8f6f 	isb	sy
	return ret;
60005d4a:	e708      	b.n	60005b5e <dma_mcux_edma_configure+0x3a>
    assert(channel < (uint32_t)FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
60005d4c:	2d20      	cmp	r5, #32
		DMAMUX_SetSource(DEV_DMAMUX_BASE(dev), channel, slot);
60005d4e:	685a      	ldr	r2, [r3, #4]
60005d50:	d107      	bne.n	60005d62 <dma_mcux_edma_configure+0x23e>
60005d52:	491f      	ldr	r1, [pc, #124]	; (60005dd0 <dma_mcux_edma_configure+0x2ac>)
60005d54:	236f      	movs	r3, #111	; 0x6f
60005d56:	4a1f      	ldr	r2, [pc, #124]	; (60005dd4 <dma_mcux_edma_configure+0x2b0>)
60005d58:	481f      	ldr	r0, [pc, #124]	; (60005dd8 <dma_mcux_edma_configure+0x2b4>)
60005d5a:	f004 feb1 	bl	6000aac0 <assert_print>
60005d5e:	216f      	movs	r1, #111	; 0x6f
60005d60:	e76a      	b.n	60005c38 <dma_mcux_edma_configure+0x114>
    base->CHCFG[channel] = ((base->CHCFG[channel] & ~DMAMUX_CHCFG_SOURCE_MASK) | DMAMUX_CHCFG_SOURCE(source));
60005d62:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
60005d66:	f001 017f 	and.w	r1, r1, #127	; 0x7f
60005d6a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
60005d6e:	430b      	orrs	r3, r1
60005d70:	e769      	b.n	60005c46 <dma_mcux_edma_configure+0x122>
		EDMA_PrepareTransfer(&(data->transferConfig),
60005d72:	9b04      	ldr	r3, [sp, #16]
60005d74:	4658      	mov	r0, fp
60005d76:	9303      	str	r3, [sp, #12]
60005d78:	f8d8 3014 	ldr.w	r3, [r8, #20]
60005d7c:	9302      	str	r3, [sp, #8]
60005d7e:	8923      	ldrh	r3, [r4, #8]
60005d80:	9301      	str	r3, [sp, #4]
60005d82:	88e3      	ldrh	r3, [r4, #6]
60005d84:	9300      	str	r3, [sp, #0]
60005d86:	f8d8 3004 	ldr.w	r3, [r8, #4]
60005d8a:	88a2      	ldrh	r2, [r4, #4]
60005d8c:	f8d8 1000 	ldr.w	r1, [r8]
60005d90:	f001 fdd4 	bl	6000793c <EDMA_PrepareTransfer>
			EDMA_SubmitTransfer(p_handle, &(data->transferConfig));
60005d94:	4659      	mov	r1, fp
60005d96:	4650      	mov	r0, sl
60005d98:	f001 fe12 	bl	600079c0 <EDMA_SubmitTransfer>
		if (submit_status != kStatus_Success) {
60005d9c:	4681      	mov	r9, r0
60005d9e:	2800      	cmp	r0, #0
60005da0:	d0a9      	beq.n	60005cf6 <dma_mcux_edma_configure+0x1d2>
			LOG_ERR("Error submitting EDMA Transfer: 0x%x", submit_status);
60005da2:	4602      	mov	r2, r0
60005da4:	2145      	movs	r1, #69	; 0x45
60005da6:	480f      	ldr	r0, [pc, #60]	; (60005de4 <dma_mcux_edma_configure+0x2c0>)
			ret = -EFAULT;
60005da8:	f06f 090d 	mvn.w	r9, #13
			LOG_ERR("Error submitting EDMA Transfer: 0x%x", submit_status);
60005dac:	f004 fe98 	bl	6000aae0 <z_log_minimal_printk>
			ret = -EFAULT;
60005db0:	e7a1      	b.n	60005cf6 <dma_mcux_edma_configure+0x1d2>
60005db2:	bf00      	nop
60005db4:	6000d105 	.word	0x6000d105
60005db8:	6000d12a 	.word	0x6000d12a
60005dbc:	6000d232 	.word	0x6000d232
60005dc0:	6000d169 	.word	0x6000d169
60005dc4:	6000d145 	.word	0x6000d145
60005dc8:	6000d189 	.word	0x6000d189
60005dcc:	6000d1a7 	.word	0x6000d1a7
60005dd0:	6000d219 	.word	0x6000d219
60005dd4:	6000d1d3 	.word	0x6000d1d3
60005dd8:	6000c68a 	.word	0x6000c68a
60005ddc:	6000abd5 	.word	0x6000abd5
60005de0:	80000000 	.word	0x80000000
60005de4:	6000d0b6 	.word	0x6000d0b6

60005de8 <mcux_igpio_manage_callback>:
}

static int mcux_igpio_manage_callback(const struct device *dev,
				      struct gpio_callback *callback,
				      bool set)
{
60005de8:	b510      	push	{r4, lr}
	struct mcux_igpio_data *data = dev->data;
60005dea:	6903      	ldr	r3, [r0, #16]
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
	__ASSERT(callback, "No callback!");
60005dec:	b961      	cbnz	r1, 60005e08 <mcux_igpio_manage_callback+0x20>
60005dee:	4920      	ldr	r1, [pc, #128]	; (60005e70 <mcux_igpio_manage_callback+0x88>)
60005df0:	232a      	movs	r3, #42	; 0x2a
60005df2:	4a20      	ldr	r2, [pc, #128]	; (60005e74 <mcux_igpio_manage_callback+0x8c>)
60005df4:	4820      	ldr	r0, [pc, #128]	; (60005e78 <mcux_igpio_manage_callback+0x90>)
60005df6:	f004 fe63 	bl	6000aac0 <assert_print>
60005dfa:	4820      	ldr	r0, [pc, #128]	; (60005e7c <mcux_igpio_manage_callback+0x94>)
60005dfc:	f004 fe60 	bl	6000aac0 <assert_print>
60005e00:	212a      	movs	r1, #42	; 0x2a
	__ASSERT(callback->handler, "No callback handler!");
60005e02:	481c      	ldr	r0, [pc, #112]	; (60005e74 <mcux_igpio_manage_callback+0x8c>)
60005e04:	f004 fe55 	bl	6000aab2 <assert_post_action>
60005e08:	6848      	ldr	r0, [r1, #4]
60005e0a:	b950      	cbnz	r0, 60005e22 <mcux_igpio_manage_callback+0x3a>
60005e0c:	491c      	ldr	r1, [pc, #112]	; (60005e80 <mcux_igpio_manage_callback+0x98>)
60005e0e:	232b      	movs	r3, #43	; 0x2b
60005e10:	4a18      	ldr	r2, [pc, #96]	; (60005e74 <mcux_igpio_manage_callback+0x8c>)
60005e12:	4819      	ldr	r0, [pc, #100]	; (60005e78 <mcux_igpio_manage_callback+0x90>)
60005e14:	f004 fe54 	bl	6000aac0 <assert_print>
60005e18:	481a      	ldr	r0, [pc, #104]	; (60005e84 <mcux_igpio_manage_callback+0x9c>)
60005e1a:	f004 fe51 	bl	6000aac0 <assert_print>
60005e1e:	212b      	movs	r1, #43	; 0x2b
60005e20:	e7ef      	b.n	60005e02 <mcux_igpio_manage_callback+0x1a>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
60005e22:	6858      	ldr	r0, [r3, #4]

	if (!sys_slist_is_empty(callbacks)) {
60005e24:	b1f8      	cbz	r0, 60005e66 <mcux_igpio_manage_callback+0x7e>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
60005e26:	4288      	cmp	r0, r1
60005e28:	d119      	bne.n	60005e5e <mcux_igpio_manage_callback+0x76>
Z_GENLIST_REMOVE(slist, snode)
60005e2a:	689c      	ldr	r4, [r3, #8]
	return node->next;
60005e2c:	6808      	ldr	r0, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
60005e2e:	42a1      	cmp	r1, r4
	list->head = node;
60005e30:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
60005e32:	d100      	bne.n	60005e36 <mcux_igpio_manage_callback+0x4e>
	list->tail = node;
60005e34:	6098      	str	r0, [r3, #8]
	parent->next = child;
60005e36:	2000      	movs	r0, #0
60005e38:	6008      	str	r0, [r1, #0]
		}
	} else if (!set) {
		return -EINVAL;
	}

	if (set) {
60005e3a:	b12a      	cbz	r2, 60005e48 <mcux_igpio_manage_callback+0x60>
	return list->head;
60005e3c:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
60005e3e:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
60005e40:	689a      	ldr	r2, [r3, #8]
	list->head = node;
60005e42:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
60005e44:	b902      	cbnz	r2, 60005e48 <mcux_igpio_manage_callback+0x60>
	list->tail = node;
60005e46:	6099      	str	r1, [r3, #8]
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
60005e48:	2000      	movs	r0, #0

	return gpio_manage_callback(&data->callbacks, callback, set);
60005e4a:	e010      	b.n	60005e6e <mcux_igpio_manage_callback+0x86>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
60005e4c:	4281      	cmp	r1, r0
60005e4e:	d106      	bne.n	60005e5e <mcux_igpio_manage_callback+0x76>
	return node->next;
60005e50:	6808      	ldr	r0, [r1, #0]
	parent->next = child;
60005e52:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
60005e54:	6898      	ldr	r0, [r3, #8]
60005e56:	4281      	cmp	r1, r0
60005e58:	d1ed      	bne.n	60005e36 <mcux_igpio_manage_callback+0x4e>
	list->tail = node;
60005e5a:	609c      	str	r4, [r3, #8]
}
60005e5c:	e7eb      	b.n	60005e36 <mcux_igpio_manage_callback+0x4e>
	return node->next;
60005e5e:	4604      	mov	r4, r0
60005e60:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
60005e62:	2800      	cmp	r0, #0
60005e64:	d1f2      	bne.n	60005e4c <mcux_igpio_manage_callback+0x64>
			if (!set) {
60005e66:	2a00      	cmp	r2, #0
60005e68:	d1e8      	bne.n	60005e3c <mcux_igpio_manage_callback+0x54>
				return -EINVAL;
60005e6a:	f06f 0015 	mvn.w	r0, #21
}
60005e6e:	bd10      	pop	{r4, pc}
60005e70:	6000d298 	.word	0x6000d298
60005e74:	6000d25c 	.word	0x6000d25c
60005e78:	6000c68a 	.word	0x6000c68a
60005e7c:	6000d2a1 	.word	0x6000d2a1
60005e80:	6000d2b0 	.word	0x6000d2b0
60005e84:	6000d2c2 	.word	0x6000d2c2

60005e88 <mcux_igpio_port_isr>:

static void mcux_igpio_port_isr(const struct device *dev)
{
60005e88:	b570      	push	{r4, r5, r6, lr}
	const struct mcux_igpio_config *config = dev->config;
	struct mcux_igpio_data *data = dev->data;
	GPIO_Type *base = config->base;
60005e8a:	6843      	ldr	r3, [r0, #4]
{
60005e8c:	4605      	mov	r5, r0
	struct mcux_igpio_data *data = dev->data;
60005e8e:	6902      	ldr	r2, [r0, #16]
	GPIO_Type *base = config->base;
60005e90:	685b      	ldr	r3, [r3, #4]
	uint32_t int_flags;

	int_flags = base->ISR;
60005e92:	699e      	ldr	r6, [r3, #24]
	base->ISR = int_flags;
60005e94:	619e      	str	r6, [r3, #24]

	gpio_fire_callbacks(&data->callbacks, dev, int_flags);
60005e96:	6851      	ldr	r1, [r2, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
60005e98:	b109      	cbz	r1, 60005e9e <mcux_igpio_port_isr+0x16>
	return node->next;
60005e9a:	680c      	ldr	r4, [r1, #0]
60005e9c:	b901      	cbnz	r1, 60005ea0 <mcux_igpio_port_isr+0x18>
}
60005e9e:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->pin_mask & pins) {
60005ea0:	688a      	ldr	r2, [r1, #8]
60005ea2:	4032      	ands	r2, r6
60005ea4:	d010      	beq.n	60005ec8 <mcux_igpio_port_isr+0x40>
			__ASSERT(cb->handler, "No callback handler!");
60005ea6:	684b      	ldr	r3, [r1, #4]
60005ea8:	b963      	cbnz	r3, 60005ec4 <mcux_igpio_port_isr+0x3c>
60005eaa:	490b      	ldr	r1, [pc, #44]	; (60005ed8 <mcux_igpio_port_isr+0x50>)
60005eac:	234d      	movs	r3, #77	; 0x4d
60005eae:	4a0b      	ldr	r2, [pc, #44]	; (60005edc <mcux_igpio_port_isr+0x54>)
60005eb0:	480b      	ldr	r0, [pc, #44]	; (60005ee0 <mcux_igpio_port_isr+0x58>)
60005eb2:	f004 fe05 	bl	6000aac0 <assert_print>
60005eb6:	480b      	ldr	r0, [pc, #44]	; (60005ee4 <mcux_igpio_port_isr+0x5c>)
60005eb8:	f004 fe02 	bl	6000aac0 <assert_print>
60005ebc:	214d      	movs	r1, #77	; 0x4d
60005ebe:	4807      	ldr	r0, [pc, #28]	; (60005edc <mcux_igpio_port_isr+0x54>)
60005ec0:	f004 fdf7 	bl	6000aab2 <assert_post_action>
			cb->handler(port, cb, cb->pin_mask & pins);
60005ec4:	4628      	mov	r0, r5
60005ec6:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
60005ec8:	b11c      	cbz	r4, 60005ed2 <mcux_igpio_port_isr+0x4a>
60005eca:	6823      	ldr	r3, [r4, #0]
60005ecc:	4621      	mov	r1, r4
60005ece:	461c      	mov	r4, r3
60005ed0:	e7e4      	b.n	60005e9c <mcux_igpio_port_isr+0x14>
60005ed2:	4623      	mov	r3, r4
60005ed4:	e7fa      	b.n	60005ecc <mcux_igpio_port_isr+0x44>
60005ed6:	bf00      	nop
60005ed8:	6000d2d9 	.word	0x6000d2d9
60005edc:	6000d25c 	.word	0x6000d25c
60005ee0:	6000c68a 	.word	0x6000c68a
60005ee4:	6000d2c2 	.word	0x6000d2c2

60005ee8 <imx_pinctrl_init>:
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
60005ee8:	4b12      	ldr	r3, [pc, #72]	; (60005f34 <imx_pinctrl_init+0x4c>)
60005eea:	f103 0278 	add.w	r2, r3, #120	; 0x78
60005eee:	e852 2f00 	ldrex	r2, [r2]

static inline void _SDK_AtomicLocalClearAndSet4Byte(volatile uint32_t *addr, uint32_t clearBits, uint32_t setBits)
{
    uint32_t s_val;

    _SDK_ATOMIC_LOCAL_OPS_4BYTE(addr, s_val, s_val = (s_val & ~clearBits) | setBits);
60005ef2:	f042 020c 	orr.w	r2, r2, #12
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
60005ef6:	f103 0078 	add.w	r0, r3, #120	; 0x78
60005efa:	e840 2100 	strex	r1, r2, [r0]
60005efe:	2900      	cmp	r1, #0
60005f00:	d1f3      	bne.n	60005eea <imx_pinctrl_init+0x2>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
60005f02:	f103 0270 	add.w	r2, r3, #112	; 0x70
60005f06:	e852 2f00 	ldrex	r2, [r2]
60005f0a:	f042 0230 	orr.w	r2, r2, #48	; 0x30
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
60005f0e:	f103 0070 	add.w	r0, r3, #112	; 0x70
60005f12:	e840 2100 	strex	r1, r2, [r0]
60005f16:	2900      	cmp	r1, #0
60005f18:	d1f3      	bne.n	60005f02 <imx_pinctrl_init+0x1a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
60005f1a:	f103 0278 	add.w	r2, r3, #120	; 0x78
60005f1e:	e852 2f00 	ldrex	r2, [r2]
60005f22:	f042 0230 	orr.w	r2, r2, #48	; 0x30
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
60005f26:	f103 0178 	add.w	r1, r3, #120	; 0x78
60005f2a:	e841 2000 	strex	r0, r2, [r1]
60005f2e:	2800      	cmp	r0, #0
60005f30:	d1f3      	bne.n	60005f1a <imx_pinctrl_init+0x32>
#elif defined(CONFIG_SOC_MIMX8MQ6)
	CLOCK_EnableClock(kCLOCK_Iomux);
#endif /* CONFIG_SOC_SERIES_IMX_RT */

	return 0;
}
60005f32:	4770      	bx	lr
60005f34:	400fc000 	.word	0x400fc000

60005f38 <spi_mcux_dma_callback>:
#ifdef CONFIG_SPI_MCUX_LPSPI_DMA

/* This function is executed in the interrupt context */
static void spi_mcux_dma_callback(const struct device *dev, void *arg,
			 uint32_t channel, int status)
{
60005f38:	b510      	push	{r4, lr}
	/* arg directly holds the spi device */
	const struct device *spi_dev = arg;
	struct spi_mcux_data *data = (struct spi_mcux_data *)spi_dev->data;
60005f3a:	690c      	ldr	r4, [r1, #16]

	if (status != 0) {
60005f3c:	b143      	cbz	r3, 60005f50 <spi_mcux_dma_callback+0x18>
		LOG_ERR("DMA callback error with channel %d.", channel);
60005f3e:	2145      	movs	r1, #69	; 0x45
60005f40:	4812      	ldr	r0, [pc, #72]	; (60005f8c <spi_mcux_dma_callback+0x54>)
		} else if (channel == data->dma_rx.channel) {
			/* this part of the transfer ends */
			data->status_flags |= SPI_MCUX_LPSPI_DMA_RX_DONE_FLAG;
			LOG_DBG("DMA RX Block Complete");
		} else {
			LOG_ERR("DMA callback channel %d is not valid.",
60005f42:	f004 fdcd 	bl	6000aae0 <z_log_minimal_printk>
								channel);
			data->status_flags |= SPI_MCUX_LPSPI_DMA_ERROR_FLAG;
60005f46:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
60005f4a:	f043 0301 	orr.w	r3, r3, #1
60005f4e:	e007      	b.n	60005f60 <spi_mcux_dma_callback+0x28>
		if (channel == data->dma_tx.channel) {
60005f50:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
60005f54:	4293      	cmp	r3, r2
60005f56:	d10d      	bne.n	60005f74 <spi_mcux_dma_callback+0x3c>
			data->status_flags |= SPI_MCUX_LPSPI_DMA_TX_DONE_FLAG;
60005f58:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
60005f5c:	f043 0304 	orr.w	r3, r3, #4
			data->status_flags |= SPI_MCUX_LPSPI_DMA_ERROR_FLAG;
60005f60:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
			ctx->owner = NULL;
			k_sem_give(&ctx->lock);
		}
	}
#else
	ctx->sync_status = status;
60005f64:	2300      	movs	r3, #0
60005f66:	66e3      	str	r3, [r4, #108]	; 0x6c
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
60005f68:	f104 005c 	add.w	r0, r4, #92	; 0x5c
		}
	}
	spi_context_complete(&data->ctx, spi_dev, 0);
}
60005f6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
60005f70:	f003 b8e2 	b.w	60009138 <z_impl_k_sem_give>
		} else if (channel == data->dma_rx.channel) {
60005f74:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
60005f78:	4293      	cmp	r3, r2
60005f7a:	d104      	bne.n	60005f86 <spi_mcux_dma_callback+0x4e>
			data->status_flags |= SPI_MCUX_LPSPI_DMA_RX_DONE_FLAG;
60005f7c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
60005f80:	f043 0302 	orr.w	r3, r3, #2
60005f84:	e7ec      	b.n	60005f60 <spi_mcux_dma_callback+0x28>
			LOG_ERR("DMA callback channel %d is not valid.",
60005f86:	2145      	movs	r1, #69	; 0x45
60005f88:	4801      	ldr	r0, [pc, #4]	; (60005f90 <spi_mcux_dma_callback+0x58>)
60005f8a:	e7da      	b.n	60005f42 <spi_mcux_dma_callback+0xa>
60005f8c:	6000d33e 	.word	0x6000d33e
60005f90:	6000d367 	.word	0x6000d367

60005f94 <gpio_pin_set_dt.isra.0>:
 *
 * @param spec GPIO specification from devicetree
 * @param value Value assigned to the pin.
 * @return a value from gpio_pin_set()
 */
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
60005f94:	4603      	mov	r3, r0
60005f96:	460a      	mov	r2, r1
60005f98:	b510      	push	{r4, lr}
{
	return gpio_pin_set(spec->port, spec->pin, value);
60005f9a:	6800      	ldr	r0, [r0, #0]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
60005f9c:	7919      	ldrb	r1, [r3, #4]
60005f9e:	2301      	movs	r3, #1
	const struct gpio_driver_data *const data =
60005fa0:	6904      	ldr	r4, [r0, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
60005fa2:	fa03 f101 	lsl.w	r1, r3, r1
60005fa6:	6843      	ldr	r3, [r0, #4]
60005fa8:	681b      	ldr	r3, [r3, #0]
60005faa:	4219      	tst	r1, r3
60005fac:	d10e      	bne.n	60005fcc <gpio_pin_set_dt.isra.0+0x38>
60005fae:	490e      	ldr	r1, [pc, #56]	; (60005fe8 <gpio_pin_set_dt.isra.0+0x54>)
60005fb0:	f240 533e 	movw	r3, #1342	; 0x53e
60005fb4:	4a0d      	ldr	r2, [pc, #52]	; (60005fec <gpio_pin_set_dt.isra.0+0x58>)
60005fb6:	480e      	ldr	r0, [pc, #56]	; (60005ff0 <gpio_pin_set_dt.isra.0+0x5c>)
60005fb8:	f004 fd82 	bl	6000aac0 <assert_print>
60005fbc:	480d      	ldr	r0, [pc, #52]	; (60005ff4 <gpio_pin_set_dt.isra.0+0x60>)
60005fbe:	f004 fd7f 	bl	6000aac0 <assert_print>
60005fc2:	f240 513e 	movw	r1, #1342	; 0x53e
60005fc6:	4809      	ldr	r0, [pc, #36]	; (60005fec <gpio_pin_set_dt.isra.0+0x58>)
60005fc8:	f004 fd73 	bl	6000aab2 <assert_post_action>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
60005fcc:	6823      	ldr	r3, [r4, #0]
60005fce:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
60005fd0:	bf18      	it	ne
60005fd2:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
60005fd6:	b122      	cbz	r2, 60005fe2 <gpio_pin_set_dt.isra.0+0x4e>
	return api->port_set_bits_raw(port, pins);
60005fd8:	6883      	ldr	r3, [r0, #8]
60005fda:	68db      	ldr	r3, [r3, #12]
}
60005fdc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return api->port_clear_bits_raw(port, pins);
60005fe0:	4718      	bx	r3
60005fe2:	6883      	ldr	r3, [r0, #8]
60005fe4:	691b      	ldr	r3, [r3, #16]
60005fe6:	e7f9      	b.n	60005fdc <gpio_pin_set_dt.isra.0+0x48>
60005fe8:	6000d3c3 	.word	0x6000d3c3
60005fec:	6000d392 	.word	0x6000d392
60005ff0:	6000c68a 	.word	0x6000c68a
60005ff4:	6000d401 	.word	0x6000d401

60005ff8 <spi_mcux_transceive>:

static int spi_mcux_transceive(const struct device *dev,
			       const struct spi_config *spi_cfg,
			       const struct spi_buf_set *tx_bufs,
			       const struct spi_buf_set *rx_bufs)
{
60005ff8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60005ffc:	461f      	mov	r7, r3
	LPSPI_Type *base = config->base;
60005ffe:	6843      	ldr	r3, [r0, #4]
{
60006000:	b091      	sub	sp, #68	; 0x44
60006002:	4605      	mov	r5, r0
	LPSPI_Type *base = config->base;
60006004:	681b      	ldr	r3, [r3, #0]
{
60006006:	460e      	mov	r6, r1
	struct spi_mcux_data *data = dev->data;
60006008:	6904      	ldr	r4, [r0, #16]
{
6000600a:	4690      	mov	r8, r2
	LPSPI_Type *base = config->base;
6000600c:	9300      	str	r3, [sp, #0]
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
6000600e:	888b      	ldrh	r3, [r1, #4]
60006010:	0498      	lsls	r0, r3, #18
60006012:	d429      	bmi.n	60006068 <spi_mcux_transceive+0x70>
	return z_impl_k_sem_take(sem, timeout);
60006014:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60006018:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
6000601c:	f104 004c 	add.w	r0, r4, #76	; 0x4c
60006020:	f003 f8ca 	bl	600091b8 <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
60006024:	6426      	str	r6, [r4, #64]	; 0x40
	struct spi_mcux_data *data = dev->data;
60006026:	f8d5 a010 	ldr.w	sl, [r5, #16]
	const struct spi_mcux_config *config = dev->config;
6000602a:	f8d5 b004 	ldr.w	fp, [r5, #4]
	if (spi_context_configured(&data->ctx, spi_cfg)) {
6000602e:	f8da 303c 	ldr.w	r3, [sl, #60]	; 0x3c
60006032:	429e      	cmp	r6, r3
60006034:	d07b      	beq.n	6000612e <spi_mcux_transceive+0x136>
	if (spi_cfg->operation & SPI_HALF_DUPLEX) {
60006036:	88b3      	ldrh	r3, [r6, #4]
	LPSPI_Type *base = config->base;
60006038:	f8db 9000 	ldr.w	r9, [fp]
	if (spi_cfg->operation & SPI_HALF_DUPLEX) {
6000603c:	0519      	lsls	r1, r3, #20
6000603e:	d51a      	bpl.n	60006076 <spi_mcux_transceive+0x7e>
		return -ENOTSUP;
60006040:	f06f 0685 	mvn.w	r6, #133	; 0x85
		LOG_ERR("Half-duplex not supported");
60006044:	2145      	movs	r1, #69	; 0x45
60006046:	4869      	ldr	r0, [pc, #420]	; (600061ec <spi_mcux_transceive+0x1f4>)
60006048:	f004 fd4a 	bl	6000aae0 <z_log_minimal_printk>
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
6000604c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
6000604e:	889b      	ldrh	r3, [r3, #4]
60006050:	f413 5300 	ands.w	r3, r3, #8192	; 0x2000
60006054:	d104      	bne.n	60006060 <spi_mcux_transceive+0x68>
		ctx->owner = NULL;
60006056:	6423      	str	r3, [r4, #64]	; 0x40
	z_impl_k_sem_give(sem);
60006058:	f104 004c 	add.w	r0, r4, #76	; 0x4c
6000605c:	f003 f86c 	bl	60009138 <z_impl_k_sem_give>
#ifdef CONFIG_SPI_MCUX_LPSPI_DMA
	return transceive_dma(dev, spi_cfg, tx_bufs, rx_bufs, false, NULL, NULL);
#endif /* CONFIG_SPI_MCUX_LPSPI_DMA */
	return transceive(dev, spi_cfg, tx_bufs, rx_bufs, false, NULL, NULL);
}
60006060:	4630      	mov	r0, r6
60006062:	b011      	add	sp, #68	; 0x44
60006064:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
60006068:	6d63      	ldr	r3, [r4, #84]	; 0x54
6000606a:	2b00      	cmp	r3, #0
6000606c:	d1d2      	bne.n	60006014 <spi_mcux_transceive+0x1c>
		(k_sem_count_get(&ctx->lock) == 0) &&
6000606e:	6c23      	ldr	r3, [r4, #64]	; 0x40
60006070:	4299      	cmp	r1, r3
60006072:	d1cf      	bne.n	60006014 <spi_mcux_transceive+0x1c>
60006074:	e7d7      	b.n	60006026 <spi_mcux_transceive+0x2e>
	LPSPI_MasterGetDefaultConfig(&master_config);
60006076:	a809      	add	r0, sp, #36	; 0x24
60006078:	f002 f8ba 	bl	600081f0 <LPSPI_MasterGetDefaultConfig>
	if (spi_cfg->slave > CHIP_SELECT_COUNT) {
6000607c:	88f2      	ldrh	r2, [r6, #6]
6000607e:	2a04      	cmp	r2, #4
60006080:	d907      	bls.n	60006092 <spi_mcux_transceive+0x9a>
		LOG_ERR("Slave %d is greater than %d",
60006082:	2304      	movs	r3, #4
60006084:	2145      	movs	r1, #69	; 0x45
60006086:	485a      	ldr	r0, [pc, #360]	; (600061f0 <spi_mcux_transceive+0x1f8>)
60006088:	f004 fd2a 	bl	6000aae0 <z_log_minimal_printk>
		return -EINVAL;
6000608c:	f06f 0615 	mvn.w	r6, #21
60006090:	e7dc      	b.n	6000604c <spi_mcux_transceive+0x54>
	word_size = SPI_WORD_SIZE_GET(spi_cfg->operation);
60006092:	88b3      	ldrh	r3, [r6, #4]
60006094:	f3c3 1245 	ubfx	r2, r3, #5, #6
	master_config.bitsPerFrame = word_size;
60006098:	920a      	str	r2, [sp, #40]	; 0x28
		: kLPSPI_ClockPolarityActiveHigh;
6000609a:	f3c3 0240 	ubfx	r2, r3, #1, #1
	master_config.cpol =
6000609e:	f88d 202c 	strb.w	r2, [sp, #44]	; 0x2c
		: kLPSPI_ClockPhaseFirstEdge;
600060a2:	f3c3 0280 	ubfx	r2, r3, #2, #1
		: kLPSPI_MsbFirst;
600060a6:	f3c3 1300 	ubfx	r3, r3, #4, #1
	master_config.cpha =
600060aa:	f88d 202d 	strb.w	r2, [sp, #45]	; 0x2d
	master_config.direction =
600060ae:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
	master_config.baudRate = spi_cfg->frequency;
600060b2:	6833      	ldr	r3, [r6, #0]
600060b4:	9309      	str	r3, [sp, #36]	; 0x24
	master_config.pcsToSckDelayInNanoSec = config->pcs_sck_delay;
600060b6:	f8db 3010 	ldr.w	r3, [fp, #16]
600060ba:	930c      	str	r3, [sp, #48]	; 0x30
	master_config.lastSckToPcsDelayInNanoSec = config->sck_pcs_delay;
600060bc:	f8db 3014 	ldr.w	r3, [fp, #20]
600060c0:	930d      	str	r3, [sp, #52]	; 0x34
	master_config.betweenTransferDelayInNanoSec = config->transfer_delay;
600060c2:	f8db 3018 	ldr.w	r3, [fp, #24]
600060c6:	930e      	str	r3, [sp, #56]	; 0x38
	if (!device_is_ready(config->clock_dev)) {
600060c8:	f8db 0004 	ldr.w	r0, [fp, #4]
600060cc:	f005 f9da 	bl	6000b484 <z_device_is_ready>
600060d0:	b930      	cbnz	r0, 600060e0 <spi_mcux_transceive+0xe8>
		LOG_ERR("clock control device not ready");
600060d2:	2145      	movs	r1, #69	; 0x45
600060d4:	4847      	ldr	r0, [pc, #284]	; (600061f4 <spi_mcux_transceive+0x1fc>)
		return -ENODEV;
600060d6:	f06f 0612 	mvn.w	r6, #18
		LOG_ERR("clock control device not ready");
600060da:	f004 fd01 	bl	6000aae0 <z_log_minimal_printk>
	if (ret) {
600060de:	e7b5      	b.n	6000604c <spi_mcux_transceive+0x54>
	if (clock_control_get_rate(config->clock_dev, config->clock_subsys,
600060e0:	e9db 0101 	ldrd	r0, r1, [fp, #4]
					 uint32_t *rate)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->api;

	if (api->get_rate == NULL) {
600060e4:	6883      	ldr	r3, [r0, #8]
600060e6:	68db      	ldr	r3, [r3, #12]
600060e8:	2b00      	cmp	r3, #0
600060ea:	d0cf      	beq.n	6000608c <spi_mcux_transceive+0x94>
		return -ENOSYS;
	}

	return api->get_rate(dev, sys, rate);
600060ec:	aa08      	add	r2, sp, #32
600060ee:	4798      	blx	r3
600060f0:	2800      	cmp	r0, #0
600060f2:	d1cb      	bne.n	6000608c <spi_mcux_transceive+0x94>
    {
        base->CR |= LPSPI_CR_MEN_MASK;
    }
    else
    {
        base->CR &= ~LPSPI_CR_MEN_MASK;
600060f4:	f8d9 3010 	ldr.w	r3, [r9, #16]
600060f8:	f023 0301 	bic.w	r3, r3, #1
600060fc:	f8c9 3010 	str.w	r3, [r9, #16]
	while ((base->CR & LPSPI_CR_MEN_MASK) != 0U) {
60006100:	f8d9 3010 	ldr.w	r3, [r9, #16]
60006104:	f013 0b01 	ands.w	fp, r3, #1
60006108:	d1fa      	bne.n	60006100 <spi_mcux_transceive+0x108>
	LPSPI_MasterInit(base, &master_config, clock_freq);
6000610a:	9a08      	ldr	r2, [sp, #32]
6000610c:	a909      	add	r1, sp, #36	; 0x24
6000610e:	4648      	mov	r0, r9
60006110:	f002 f92c 	bl	6000836c <LPSPI_MasterInit>
	LPSPI_MasterTransferCreateHandle(base, &data->handle,
60006114:	4653      	mov	r3, sl
60006116:	4a38      	ldr	r2, [pc, #224]	; (600061f8 <spi_mcux_transceive+0x200>)
60006118:	f10a 0104 	add.w	r1, sl, #4
6000611c:	4648      	mov	r0, r9
6000611e:	f002 f9a9 	bl	60008474 <LPSPI_MasterTransferCreateHandle>
	LPSPI_SetDummyData(base, 0);
60006122:	4659      	mov	r1, fp
60006124:	4648      	mov	r0, r9
60006126:	f002 f859 	bl	600081dc <LPSPI_SetDummyData>
	data->ctx.config = spi_cfg;
6000612a:	f8ca 603c 	str.w	r6, [sl, #60]	; 0x3c
			       const struct spi_buf_set *rx_bufs,
			       uint8_t dfs)
{
	LOG_DBG("tx_bufs %p - rx_bufs %p - %u", tx_bufs, rx_bufs, dfs);

	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
6000612e:	f1b8 0f00 	cmp.w	r8, #0
60006132:	d145      	bne.n	600061c0 <spi_mcux_transceive+0x1c8>
60006134:	f8c4 8070 	str.w	r8, [r4, #112]	; 0x70
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
60006138:	2300      	movs	r3, #0
6000613a:	6763      	str	r3, [r4, #116]	; 0x74
	ctx->tx_buf = (const uint8_t *)
		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
6000613c:	f104 0370 	add.w	r3, r4, #112	; 0x70
60006140:	f104 0174 	add.w	r1, r4, #116	; 0x74
60006144:	f104 0070 	add.w	r0, r4, #112	; 0x70
60006148:	9302      	str	r3, [sp, #8]
6000614a:	f104 0374 	add.w	r3, r4, #116	; 0x74
6000614e:	9303      	str	r3, [sp, #12]
60006150:	f104 0384 	add.w	r3, r4, #132	; 0x84
60006154:	461a      	mov	r2, r3
60006156:	9304      	str	r3, [sp, #16]
60006158:	f005 f91d 	bl	6000b396 <spi_context_get_next_buf.constprop.0>
	ctx->tx_buf = (const uint8_t *)
6000615c:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
					 &ctx->tx_len, dfs);

	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
60006160:	2f00      	cmp	r7, #0
60006162:	d135      	bne.n	600061d0 <spi_mcux_transceive+0x1d8>
60006164:	67a7      	str	r7, [r4, #120]	; 0x78
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
60006166:	2300      	movs	r3, #0
60006168:	67e3      	str	r3, [r4, #124]	; 0x7c
	ctx->rx_buf = (uint8_t *)
		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
6000616a:	f104 0378 	add.w	r3, r4, #120	; 0x78
	spi_context_lock(&data->ctx, asynchronous, cb, userdata, spi_cfg);
6000616e:	f104 023c 	add.w	r2, r4, #60	; 0x3c
					 &ctx->rx_len, dfs);

	ctx->sync_status = 0;
60006172:	2600      	movs	r6, #0
		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
60006174:	9305      	str	r3, [sp, #20]
60006176:	f104 037c 	add.w	r3, r4, #124	; 0x7c
6000617a:	f104 017c 	add.w	r1, r4, #124	; 0x7c
6000617e:	9201      	str	r2, [sp, #4]
60006180:	9306      	str	r3, [sp, #24]
60006182:	f104 038c 	add.w	r3, r4, #140	; 0x8c
60006186:	f104 0078 	add.w	r0, r4, #120	; 0x78
6000618a:	461a      	mov	r2, r3
6000618c:	9307      	str	r3, [sp, #28]
6000618e:	f005 f902 	bl	6000b396 <spi_context_get_next_buf.constprop.0>
	_spi_context_cs_control(ctx, on, false);
60006192:	4632      	mov	r2, r6
	ctx->rx_buf = (uint8_t *)
60006194:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
	_spi_context_cs_control(ctx, on, false);
60006198:	2101      	movs	r1, #1
6000619a:	f104 003c 	add.w	r0, r4, #60	; 0x3c
	ctx->sync_status = 0;
6000619e:	66e6      	str	r6, [r4, #108]	; 0x6c
	_spi_context_cs_control(ctx, on, false);
600061a0:	f005 f90c 	bl	6000b3bc <_spi_context_cs_control>
 * @param txWater The TX FIFO watermark value. Writing a value equal or greater than the FIFO size is truncated.
 * @param rxWater The RX FIFO watermark value. Writing a value equal or greater than the FIFO size is truncated.
 */
static inline void LPSPI_SetFifoWatermarks(LPSPI_Type *base, uint32_t txWater, uint32_t rxWater)
{
    base->FCR = LPSPI_FCR_TXWATER(txWater) | LPSPI_FCR_RXWATER(rxWater);
600061a4:	9b00      	ldr	r3, [sp, #0]
600061a6:	659e      	str	r6, [r3, #88]	; 0x58
	while (data->ctx.rx_len > 0 || data->ctx.tx_len > 0) {
600061a8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
		dma_size = MIN(data->ctx.tx_len, data->ctx.rx_len);
600061ac:	f8d4 6084 	ldr.w	r6, [r4, #132]	; 0x84
	while (data->ctx.rx_len > 0 || data->ctx.tx_len > 0) {
600061b0:	bb23      	cbnz	r3, 600061fc <spi_mcux_transceive+0x204>
600061b2:	b99e      	cbnz	r6, 600061dc <spi_mcux_transceive+0x1e4>
600061b4:	4632      	mov	r2, r6
600061b6:	4631      	mov	r1, r6
600061b8:	9801      	ldr	r0, [sp, #4]
600061ba:	f005 f8ff 	bl	6000b3bc <_spi_context_cs_control>
}
600061be:	e745      	b.n	6000604c <spi_mcux_transceive+0x54>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
600061c0:	f8d8 3000 	ldr.w	r3, [r8]
600061c4:	6723      	str	r3, [r4, #112]	; 0x70
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
600061c6:	2b00      	cmp	r3, #0
600061c8:	d0b6      	beq.n	60006138 <spi_mcux_transceive+0x140>
600061ca:	f8d8 3004 	ldr.w	r3, [r8, #4]
600061ce:	e7b4      	b.n	6000613a <spi_mcux_transceive+0x142>
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
600061d0:	683b      	ldr	r3, [r7, #0]
600061d2:	67a3      	str	r3, [r4, #120]	; 0x78
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
600061d4:	2b00      	cmp	r3, #0
600061d6:	d0c6      	beq.n	60006166 <spi_mcux_transceive+0x16e>
600061d8:	687b      	ldr	r3, [r7, #4]
600061da:	e7c5      	b.n	60006168 <spi_mcux_transceive+0x170>
		data->status_flags = 0U;
600061dc:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
			dma_size = MAX(data->ctx.tx_len, data->ctx.rx_len);
600061e0:	42b3      	cmp	r3, r6
600061e2:	bf38      	it	cc
600061e4:	4633      	movcc	r3, r6
600061e6:	4698      	mov	r8, r3
600061e8:	e013      	b.n	60006212 <spi_mcux_transceive+0x21a>
600061ea:	bf00      	nop
600061ec:	6000d413 	.word	0x6000d413
600061f0:	6000d432 	.word	0x6000d432
600061f4:	6000d453 	.word	0x6000d453
600061f8:	60006479 	.word	0x60006479
		dma_size = MIN(data->ctx.tx_len, data->ctx.rx_len);
600061fc:	42b3      	cmp	r3, r6
		data->status_flags = 0U;
600061fe:	f04f 0200 	mov.w	r2, #0
		dma_size = MIN(data->ctx.tx_len, data->ctx.rx_len);
60006202:	4698      	mov	r8, r3
60006204:	bf28      	it	cs
60006206:	46b0      	movcs	r8, r6
		data->status_flags = 0U;
60006208:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
		if (dma_size == 0) {
6000620c:	f1b8 0f00 	cmp.w	r8, #0
60006210:	d0e6      	beq.n	600061e0 <spi_mcux_transceive+0x1e8>
	struct spi_mcux_data *data = dev->data;
60006212:	692e      	ldr	r6, [r5, #16]
	memset(blk_cfg, 0, sizeof(struct dma_block_config));
60006214:	2220      	movs	r2, #32
		ret = spi_mcux_dma_tx_load(dev, data->ctx.tx_buf, dma_size);
60006216:	f8d4 7080 	ldr.w	r7, [r4, #128]	; 0x80
	memset(blk_cfg, 0, sizeof(struct dma_block_config));
6000621a:	2100      	movs	r1, #0
	blk_cfg = &stream->dma_blk_cfg;
6000621c:	f506 7a80 	add.w	sl, r6, #256	; 0x100
	LPSPI_Type *base = cfg->base;
60006220:	686b      	ldr	r3, [r5, #4]
	memset(blk_cfg, 0, sizeof(struct dma_block_config));
60006222:	4650      	mov	r0, sl
	LPSPI_Type *base = cfg->base;
60006224:	f8d3 9000 	ldr.w	r9, [r3]
	memset(blk_cfg, 0, sizeof(struct dma_block_config));
60006228:	f004 fcb1 	bl	6000ab8e <memset>
	if (buf == NULL) {
6000622c:	2f00      	cmp	r7, #0
6000622e:	f040 80a4 	bne.w	6000637a <spi_mcux_transceive+0x382>
		blk_cfg->source_address = (uint32_t)&data->dummy_tx_buffer;
60006232:	f506 7790 	add.w	r7, r6, #288	; 0x120
		stream->dma_cfg.channel_direction = PERIPHERAL_TO_PERIPHERAL;
60006236:	2203      	movs	r2, #3
60006238:	f896 30e5 	ldrb.w	r3, [r6, #229]	; 0xe5
	return dma_config(data->dma_tx.dma_dev, data->dma_tx.channel,
6000623c:	f8d6 00dc 	ldr.w	r0, [r6, #220]	; 0xdc
		stream->dma_cfg.channel_direction = PERIPHERAL_TO_PERIPHERAL;
60006240:	f362 0302 	bfi	r3, r2, #0, #3
		blk_cfg->source_address = (uint32_t)&data->dummy_tx_buffer;
60006244:	f8c6 7100 	str.w	r7, [r6, #256]	; 0x100
	blk_cfg->block_size = len;
60006248:	f8c6 8114 	str.w	r8, [r6, #276]	; 0x114
			     struct dma_config *config)
{
	const struct dma_driver_api *api =
		(const struct dma_driver_api *)dev->api;

	return api->config(dev, channel, config);
6000624c:	f106 02e4 	add.w	r2, r6, #228	; 0xe4
		stream->dma_cfg.channel_direction = PERIPHERAL_TO_PERIPHERAL;
60006250:	f886 30e5 	strb.w	r3, [r6, #229]	; 0xe5
	blk_cfg->source_gather_en = 1;
60006254:	f896 311c 	ldrb.w	r3, [r6, #284]	; 0x11c
60006258:	f8d6 10e0 	ldr.w	r1, [r6, #224]	; 0xe0
6000625c:	f043 0301 	orr.w	r3, r3, #1
60006260:	f886 311c 	strb.w	r3, [r6, #284]	; 0x11c
    return (uint32_t) & (base->TDR);
60006264:	f109 0364 	add.w	r3, r9, #100	; 0x64
	blk_cfg->dest_address = LPSPI_GetTxRegisterAddress(base);
60006268:	f8c6 3104 	str.w	r3, [r6, #260]	; 0x104
	stream->dma_cfg.source_burst_length = 1;
6000626c:	f04f 0301 	mov.w	r3, #1
	stream->dma_cfg.user_data = (struct device *)dev;
60006270:	e9c6 a53d 	strd	sl, r5, [r6, #244]	; 0xf4
	stream->dma_cfg.source_burst_length = 1;
60006274:	f8a6 30ec 	strh.w	r3, [r6, #236]	; 0xec
60006278:	6883      	ldr	r3, [r0, #8]
6000627a:	681b      	ldr	r3, [r3, #0]
6000627c:	4798      	blx	r3
		if (ret != 0) {
6000627e:	4606      	mov	r6, r0
60006280:	2800      	cmp	r0, #0
60006282:	f47f aee3 	bne.w	6000604c <spi_mcux_transceive+0x54>
	struct spi_mcux_data *data = dev->data;
60006286:	692f      	ldr	r7, [r5, #16]
	memset(blk_cfg, 0, sizeof(struct dma_block_config));
60006288:	4601      	mov	r1, r0
		ret = spi_mcux_dma_rx_load(dev, data->ctx.rx_buf, dma_size);
6000628a:	f8d4 9088 	ldr.w	r9, [r4, #136]	; 0x88
	memset(blk_cfg, 0, sizeof(struct dma_block_config));
6000628e:	2220      	movs	r2, #32
	blk_cfg = &stream->dma_blk_cfg;
60006290:	f107 0bbc 	add.w	fp, r7, #188	; 0xbc
	LPSPI_Type *base = cfg->base;
60006294:	686b      	ldr	r3, [r5, #4]
	memset(blk_cfg, 0, sizeof(struct dma_block_config));
60006296:	4658      	mov	r0, fp
	LPSPI_Type *base = cfg->base;
60006298:	f8d3 a000 	ldr.w	sl, [r3]
	memset(blk_cfg, 0, sizeof(struct dma_block_config));
6000629c:	f004 fc77 	bl	6000ab8e <memset>
	if (buf == NULL) {
600062a0:	f1b9 0f00 	cmp.w	r9, #0
600062a4:	d16b      	bne.n	6000637e <spi_mcux_transceive+0x386>
		blk_cfg->dest_address = (uint32_t)&data->dummy_rx_buffer;
600062a6:	f507 7392 	add.w	r3, r7, #292	; 0x124
		stream->dma_cfg.channel_direction = PERIPHERAL_TO_PERIPHERAL;
600062aa:	2203      	movs	r2, #3
		blk_cfg->dest_address = (uint32_t)&data->dummy_rx_buffer;
600062ac:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
		stream->dma_cfg.channel_direction = PERIPHERAL_TO_PERIPHERAL;
600062b0:	f897 30a1 	ldrb.w	r3, [r7, #161]	; 0xa1
	return dma_config(data->dma_rx.dma_dev, data->dma_rx.channel,
600062b4:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
		stream->dma_cfg.channel_direction = PERIPHERAL_TO_PERIPHERAL;
600062b8:	f362 0302 	bfi	r3, r2, #0, #3
	blk_cfg->block_size = len;
600062bc:	f8c7 80d0 	str.w	r8, [r7, #208]	; 0xd0
600062c0:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
600062c4:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
		stream->dma_cfg.channel_direction = PERIPHERAL_TO_PERIPHERAL;
600062c8:	f887 30a1 	strb.w	r3, [r7, #161]	; 0xa1
	blk_cfg->dest_scatter_en = 1;
600062cc:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
600062d0:	f043 0302 	orr.w	r3, r3, #2
600062d4:	f887 30d8 	strb.w	r3, [r7, #216]	; 0xd8
    return (uint32_t) & (base->RDR);
600062d8:	f10a 0374 	add.w	r3, sl, #116	; 0x74
	blk_cfg->source_address = LPSPI_GetRxRegisterAddress(base);
600062dc:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
	stream->dma_cfg.source_burst_length = 1;
600062e0:	f04f 0301 	mov.w	r3, #1
	stream->dma_cfg.user_data = (struct device *)dev;
600062e4:	e9c7 b52c 	strd	fp, r5, [r7, #176]	; 0xb0
	stream->dma_cfg.source_burst_length = 1;
600062e8:	f8a7 30a8 	strh.w	r3, [r7, #168]	; 0xa8
600062ec:	6883      	ldr	r3, [r0, #8]
600062ee:	681b      	ldr	r3, [r3, #0]
600062f0:	4798      	blx	r3
		if (ret != 0) {
600062f2:	4606      	mov	r6, r0
600062f4:	2800      	cmp	r0, #0
600062f6:	f47f aea9 	bne.w	6000604c <spi_mcux_transceive+0x54>
		ret = dma_start(data->dma_tx.dma_dev, data->dma_tx.channel);
600062fa:	e9d4 0137 	ldrd	r0, r1, [r4, #220]	; 0xdc
static inline int z_impl_dma_start(const struct device *dev, uint32_t channel)
{
	const struct dma_driver_api *api =
		(const struct dma_driver_api *)dev->api;

	return api->start(dev, channel);
600062fe:	6883      	ldr	r3, [r0, #8]
60006300:	689b      	ldr	r3, [r3, #8]
60006302:	4798      	blx	r3
		if (ret != 0) {
60006304:	4606      	mov	r6, r0
60006306:	2800      	cmp	r0, #0
60006308:	f47f aea0 	bne.w	6000604c <spi_mcux_transceive+0x54>
		ret = dma_start(data->dma_rx.dma_dev, data->dma_rx.channel);
6000630c:	e9d4 0126 	ldrd	r0, r1, [r4, #152]	; 0x98
60006310:	6883      	ldr	r3, [r0, #8]
60006312:	689b      	ldr	r3, [r3, #8]
60006314:	4798      	blx	r3
		if (ret != 0) {
60006316:	4606      	mov	r6, r0
60006318:	2800      	cmp	r0, #0
6000631a:	f47f ae97 	bne.w	6000604c <spi_mcux_transceive+0x54>
    base->DER |= mask;
6000631e:	9b00      	ldr	r3, [sp, #0]
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
60006320:	f44f 5bfa 	mov.w	fp, #8000	; 0x1f40
60006324:	9a00      	ldr	r2, [sp, #0]
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
60006326:	f04f 090a 	mov.w	r9, #10
6000632a:	69db      	ldr	r3, [r3, #28]
6000632c:	f043 0303 	orr.w	r3, r3, #3
60006330:	61d3      	str	r3, [r2, #28]
		ret = wait_dma_rx_tx_done(dev);
60006332:	692f      	ldr	r7, [r5, #16]
		if (k_sem_take(&ctx->sync, timeout)) {
60006334:	f107 0a5c 	add.w	sl, r7, #92	; 0x5c
}

static inline size_t spi_context_total_tx_len(struct spi_context *ctx)
{
	size_t n;
	size_t total_len = 0;
60006338:	2100      	movs	r1, #0

	for (n = 0; n < ctx->tx_count; ++n) {
6000633a:	6f78      	ldr	r0, [r7, #116]	; 0x74
6000633c:	460a      	mov	r2, r1
6000633e:	4282      	cmp	r2, r0
60006340:	d120      	bne.n	60006384 <spi_mcux_transceive+0x38c>
}

static inline size_t spi_context_total_rx_len(struct spi_context *ctx)
{
	size_t n;
	size_t total_len = 0;
60006342:	2300      	movs	r3, #0

	for (n = 0; n < ctx->rx_count; ++n) {
60006344:	6ffe      	ldr	r6, [r7, #124]	; 0x7c
60006346:	4618      	mov	r0, r3
60006348:	42b0      	cmp	r0, r6
6000634a:	d122      	bne.n	60006392 <spi_mcux_transceive+0x39a>
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
6000634c:	428b      	cmp	r3, r1
6000634e:	bf38      	it	cc
60006350:	460b      	movcc	r3, r1
60006352:	fb0b f203 	mul.w	r2, fp, r3
				     ctx->config->frequency;
60006356:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
60006358:	681b      	ldr	r3, [r3, #0]
6000635a:	fbb2 f2f3 	udiv	r2, r2, r3
			timeout_ms += CONFIG_SPI_COMPLETION_TIMEOUT_TOLERANCE;
6000635e:	32c8      	adds	r2, #200	; 0xc8
60006360:	fba2 2309 	umull	r2, r3, r2, r9
	return z_impl_k_sem_take(sem, timeout);
60006364:	4650      	mov	r0, sl
60006366:	f002 ff27 	bl	600091b8 <z_impl_k_sem_take>
		if (k_sem_take(&ctx->sync, timeout)) {
6000636a:	b1c8      	cbz	r0, 600063a0 <spi_mcux_transceive+0x3a8>
			LOG_ERR("Timeout waiting for transfer complete");
6000636c:	2145      	movs	r1, #69	; 0x45
6000636e:	4840      	ldr	r0, [pc, #256]	; (60006470 <spi_mcux_transceive+0x478>)
			return -ETIMEDOUT;
60006370:	f06f 0673 	mvn.w	r6, #115	; 0x73
			LOG_ERR("Timeout waiting for transfer complete");
60006374:	f004 fbb4 	bl	6000aae0 <z_log_minimal_printk>
		if (ret != 0) {
60006378:	e668      	b.n	6000604c <spi_mcux_transceive+0x54>
		blk_cfg->source_address = (uint32_t)buf;
6000637a:	2201      	movs	r2, #1
6000637c:	e75c      	b.n	60006238 <spi_mcux_transceive+0x240>
		blk_cfg->dest_address = (uint32_t)buf;
6000637e:	464b      	mov	r3, r9
60006380:	2202      	movs	r2, #2
60006382:	e793      	b.n	600062ac <spi_mcux_transceive+0x2b4>
		total_len += ctx->current_tx[n].len;
60006384:	6f3b      	ldr	r3, [r7, #112]	; 0x70
60006386:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
	for (n = 0; n < ctx->tx_count; ++n) {
6000638a:	3201      	adds	r2, #1
		total_len += ctx->current_tx[n].len;
6000638c:	685b      	ldr	r3, [r3, #4]
6000638e:	4419      	add	r1, r3
	for (n = 0; n < ctx->tx_count; ++n) {
60006390:	e7d5      	b.n	6000633e <spi_mcux_transceive+0x346>
		total_len += ctx->current_rx[n].len;
60006392:	6fba      	ldr	r2, [r7, #120]	; 0x78
60006394:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
	for (n = 0; n < ctx->rx_count; ++n) {
60006398:	3001      	adds	r0, #1
		total_len += ctx->current_rx[n].len;
6000639a:	6852      	ldr	r2, [r2, #4]
6000639c:	4413      	add	r3, r2
	for (n = 0; n < ctx->rx_count; ++n) {
6000639e:	e7d3      	b.n	60006348 <spi_mcux_transceive+0x350>
		status = ctx->sync_status;
600063a0:	6efe      	ldr	r6, [r7, #108]	; 0x6c
		if (ret) {
600063a2:	2e00      	cmp	r6, #0
600063a4:	f47f ae52 	bne.w	6000604c <spi_mcux_transceive+0x54>
		if (data->status_flags & SPI_MCUX_LPSPI_DMA_ERROR_FLAG) {
600063a8:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
600063ac:	07da      	lsls	r2, r3, #31
600063ae:	d45b      	bmi.n	60006468 <spi_mcux_transceive+0x470>
		if ((data->status_flags & SPI_MCUX_LPSPI_DMA_DONE_FLAG) ==
600063b0:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
600063b4:	f003 0306 	and.w	r3, r3, #6
600063b8:	2b06      	cmp	r3, #6
600063ba:	d1bd      	bne.n	60006338 <spi_mcux_transceive+0x340>
    return (base->SR);
600063bc:	9b00      	ldr	r3, [sp, #0]
600063be:	695b      	ldr	r3, [r3, #20]
		while ((LPSPI_GetStatusFlags(base) & kLPSPI_ModuleBusyFlag)) {
600063c0:	01db      	lsls	r3, r3, #7
600063c2:	d4fb      	bmi.n	600063bc <spi_mcux_transceive+0x3c4>
    base->DER &= ~mask;
600063c4:	9b00      	ldr	r3, [sp, #0]
600063c6:	9a00      	ldr	r2, [sp, #0]
600063c8:	69db      	ldr	r3, [r3, #28]
600063ca:	f023 0303 	bic.w	r3, r3, #3
600063ce:	61d3      	str	r3, [r2, #28]
	if (!ctx->tx_len) {
600063d0:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
600063d4:	b12b      	cbz	r3, 600063e2 <spi_mcux_transceive+0x3ea>
	if (len > ctx->tx_len) {
600063d6:	4598      	cmp	r8, r3
600063d8:	d90f      	bls.n	600063fa <spi_mcux_transceive+0x402>
		LOG_ERR("Update exceeds current buffer");
600063da:	2145      	movs	r1, #69	; 0x45
600063dc:	4825      	ldr	r0, [pc, #148]	; (60006474 <spi_mcux_transceive+0x47c>)
600063de:	f004 fb7f 	bl	6000aae0 <z_log_minimal_printk>
	if (!ctx->rx_len) {
600063e2:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
600063e6:	2b00      	cmp	r3, #0
600063e8:	f43f aede 	beq.w	600061a8 <spi_mcux_transceive+0x1b0>
	if (len > ctx->rx_len) {
600063ec:	4598      	cmp	r8, r3
600063ee:	d91f      	bls.n	60006430 <spi_mcux_transceive+0x438>
		LOG_ERR("Update exceeds current buffer");
600063f0:	2145      	movs	r1, #69	; 0x45
600063f2:	4820      	ldr	r0, [pc, #128]	; (60006474 <spi_mcux_transceive+0x47c>)
600063f4:	f004 fb74 	bl	6000aae0 <z_log_minimal_printk>
		return;
600063f8:	e6d6      	b.n	600061a8 <spi_mcux_transceive+0x1b0>
	ctx->tx_len -= len;
600063fa:	eba3 0308 	sub.w	r3, r3, r8
600063fe:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	if (!ctx->tx_len) {
60006402:	b96b      	cbnz	r3, 60006420 <spi_mcux_transceive+0x428>
		++ctx->current_tx;
60006404:	6f23      	ldr	r3, [r4, #112]	; 0x70
			spi_context_get_next_buf(&ctx->current_tx,
60006406:	9802      	ldr	r0, [sp, #8]
		++ctx->current_tx;
60006408:	3308      	adds	r3, #8
6000640a:	6723      	str	r3, [r4, #112]	; 0x70
		--ctx->tx_count;
6000640c:	6f63      	ldr	r3, [r4, #116]	; 0x74
6000640e:	3b01      	subs	r3, #1
			spi_context_get_next_buf(&ctx->current_tx,
60006410:	e9dd 1203 	ldrd	r1, r2, [sp, #12]
		--ctx->tx_count;
60006414:	6763      	str	r3, [r4, #116]	; 0x74
			spi_context_get_next_buf(&ctx->current_tx,
60006416:	f004 ffbe 	bl	6000b396 <spi_context_get_next_buf.constprop.0>
		ctx->tx_buf = (const uint8_t *)
6000641a:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
6000641e:	e7e0      	b.n	600063e2 <spi_mcux_transceive+0x3ea>
	} else if (ctx->tx_buf) {
60006420:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
60006424:	2b00      	cmp	r3, #0
60006426:	d0dc      	beq.n	600063e2 <spi_mcux_transceive+0x3ea>
		ctx->tx_buf += dfs * len;
60006428:	4443      	add	r3, r8
6000642a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
6000642e:	e7d8      	b.n	600063e2 <spi_mcux_transceive+0x3ea>
	ctx->rx_len -= len;
60006430:	eba3 0308 	sub.w	r3, r3, r8
60006434:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
	if (!ctx->rx_len) {
60006438:	b96b      	cbnz	r3, 60006456 <spi_mcux_transceive+0x45e>
		++ctx->current_rx;
6000643a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
			spi_context_get_next_buf(&ctx->current_rx,
6000643c:	9805      	ldr	r0, [sp, #20]
		++ctx->current_rx;
6000643e:	3308      	adds	r3, #8
60006440:	67a3      	str	r3, [r4, #120]	; 0x78
		--ctx->rx_count;
60006442:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
60006444:	3b01      	subs	r3, #1
			spi_context_get_next_buf(&ctx->current_rx,
60006446:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
		--ctx->rx_count;
6000644a:	67e3      	str	r3, [r4, #124]	; 0x7c
			spi_context_get_next_buf(&ctx->current_rx,
6000644c:	f004 ffa3 	bl	6000b396 <spi_context_get_next_buf.constprop.0>
		ctx->rx_buf = (uint8_t *)
60006450:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
60006454:	e6a8      	b.n	600061a8 <spi_mcux_transceive+0x1b0>
	} else if (ctx->rx_buf) {
60006456:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
6000645a:	2b00      	cmp	r3, #0
6000645c:	f43f aea4 	beq.w	600061a8 <spi_mcux_transceive+0x1b0>
		ctx->rx_buf += dfs * len;
60006460:	4443      	add	r3, r8
60006462:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
60006466:	e69f      	b.n	600061a8 <spi_mcux_transceive+0x1b0>
			return -EIO;
60006468:	f06f 0604 	mvn.w	r6, #4
		if (ret != 0) {
6000646c:	e5ee      	b.n	6000604c <spi_mcux_transceive+0x54>
6000646e:	bf00      	nop
60006470:	6000d477 	.word	0x6000d477
60006474:	6000d4a2 	.word	0x6000d4a2

60006478 <spi_mcux_master_transfer_callback>:
{
60006478:	b530      	push	{r4, r5, lr}
6000647a:	461c      	mov	r4, r3
	spi_context_update_tx(&data->ctx, 1, data->transfer_len);
6000647c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
	if (!ctx->tx_len) {
60006480:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
{
60006484:	b085      	sub	sp, #20
60006486:	b12b      	cbz	r3, 60006494 <spi_mcux_master_transfer_callback+0x1c>
	if (len > ctx->tx_len) {
60006488:	429a      	cmp	r2, r3
6000648a:	d926      	bls.n	600064da <spi_mcux_master_transfer_callback+0x62>
		LOG_ERR("Update exceeds current buffer");
6000648c:	2145      	movs	r1, #69	; 0x45
6000648e:	4847      	ldr	r0, [pc, #284]	; (600065ac <spi_mcux_master_transfer_callback+0x134>)
60006490:	f004 fb26 	bl	6000aae0 <z_log_minimal_printk>
	if (!ctx->rx_len) {
60006494:	e9d4 3223 	ldrd	r3, r2, [r4, #140]	; 0x8c
60006498:	b12b      	cbz	r3, 600064a6 <spi_mcux_master_transfer_callback+0x2e>
	if (len > ctx->rx_len) {
6000649a:	429a      	cmp	r2, r3
6000649c:	d93a      	bls.n	60006514 <spi_mcux_master_transfer_callback+0x9c>
		LOG_ERR("Update exceeds current buffer");
6000649e:	2145      	movs	r1, #69	; 0x45
600064a0:	4842      	ldr	r0, [pc, #264]	; (600065ac <spi_mcux_master_transfer_callback+0x134>)
600064a2:	f004 fb1d 	bl	6000aae0 <z_log_minimal_printk>
	spi_mcux_transfer_next_packet(data->dev);
600064a6:	6823      	ldr	r3, [r4, #0]
	struct spi_mcux_data *data = dev->data;
600064a8:	691c      	ldr	r4, [r3, #16]
	LPSPI_Type *base = config->base;
600064aa:	685b      	ldr	r3, [r3, #4]
	if ((ctx->tx_len == 0) && (ctx->rx_len == 0)) {
600064ac:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
	LPSPI_Type *base = config->base;
600064b0:	6818      	ldr	r0, [r3, #0]
	if ((ctx->tx_len == 0) && (ctx->rx_len == 0)) {
600064b2:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
600064b6:	2b00      	cmp	r3, #0
600064b8:	d149      	bne.n	6000654e <spi_mcux_master_transfer_callback+0xd6>
600064ba:	2d00      	cmp	r5, #0
600064bc:	d158      	bne.n	60006570 <spi_mcux_master_transfer_callback+0xf8>
	_spi_context_cs_control(ctx, on, false);
600064be:	462a      	mov	r2, r5
600064c0:	4629      	mov	r1, r5
600064c2:	f104 003c 	add.w	r0, r4, #60	; 0x3c
600064c6:	f004 ff79 	bl	6000b3bc <_spi_context_cs_control>
	ctx->sync_status = status;
600064ca:	66e5      	str	r5, [r4, #108]	; 0x6c
	z_impl_k_sem_give(sem);
600064cc:	f104 005c 	add.w	r0, r4, #92	; 0x5c
}
600064d0:	b005      	add	sp, #20
600064d2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
600064d6:	f002 be2f 	b.w	60009138 <z_impl_k_sem_give>
	ctx->tx_len -= len;
600064da:	1a9b      	subs	r3, r3, r2
600064dc:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	if (!ctx->tx_len) {
600064e0:	b983      	cbnz	r3, 60006504 <spi_mcux_master_transfer_callback+0x8c>
		++ctx->current_tx;
600064e2:	6f23      	ldr	r3, [r4, #112]	; 0x70
			spi_context_get_next_buf(&ctx->current_tx,
600064e4:	f104 0284 	add.w	r2, r4, #132	; 0x84
600064e8:	f104 0174 	add.w	r1, r4, #116	; 0x74
600064ec:	f104 0070 	add.w	r0, r4, #112	; 0x70
		++ctx->current_tx;
600064f0:	3308      	adds	r3, #8
600064f2:	6723      	str	r3, [r4, #112]	; 0x70
		--ctx->tx_count;
600064f4:	6f63      	ldr	r3, [r4, #116]	; 0x74
600064f6:	3b01      	subs	r3, #1
600064f8:	6763      	str	r3, [r4, #116]	; 0x74
			spi_context_get_next_buf(&ctx->current_tx,
600064fa:	f004 ff4c 	bl	6000b396 <spi_context_get_next_buf.constprop.0>
		ctx->tx_buf = (const uint8_t *)
600064fe:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
60006502:	e7c7      	b.n	60006494 <spi_mcux_master_transfer_callback+0x1c>
	} else if (ctx->tx_buf) {
60006504:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
60006508:	2b00      	cmp	r3, #0
6000650a:	d0c3      	beq.n	60006494 <spi_mcux_master_transfer_callback+0x1c>
		ctx->tx_buf += dfs * len;
6000650c:	4413      	add	r3, r2
6000650e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
60006512:	e7bf      	b.n	60006494 <spi_mcux_master_transfer_callback+0x1c>
	ctx->rx_len -= len;
60006514:	1a9b      	subs	r3, r3, r2
60006516:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
	if (!ctx->rx_len) {
6000651a:	b983      	cbnz	r3, 6000653e <spi_mcux_master_transfer_callback+0xc6>
		++ctx->current_rx;
6000651c:	6fa3      	ldr	r3, [r4, #120]	; 0x78
			spi_context_get_next_buf(&ctx->current_rx,
6000651e:	f104 028c 	add.w	r2, r4, #140	; 0x8c
60006522:	f104 017c 	add.w	r1, r4, #124	; 0x7c
60006526:	f104 0078 	add.w	r0, r4, #120	; 0x78
		++ctx->current_rx;
6000652a:	3308      	adds	r3, #8
6000652c:	67a3      	str	r3, [r4, #120]	; 0x78
		--ctx->rx_count;
6000652e:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
60006530:	3b01      	subs	r3, #1
60006532:	67e3      	str	r3, [r4, #124]	; 0x7c
			spi_context_get_next_buf(&ctx->current_rx,
60006534:	f004 ff2f 	bl	6000b396 <spi_context_get_next_buf.constprop.0>
		ctx->rx_buf = (uint8_t *)
60006538:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
6000653c:	e7b3      	b.n	600064a6 <spi_mcux_master_transfer_callback+0x2e>
	} else if (ctx->rx_buf) {
6000653e:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
60006542:	2b00      	cmp	r3, #0
60006544:	d0af      	beq.n	600064a6 <spi_mcux_master_transfer_callback+0x2e>
		ctx->rx_buf += dfs * len;
60006546:	4413      	add	r3, r2
60006548:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
6000654c:	e7ab      	b.n	600064a6 <spi_mcux_master_transfer_callback+0x2e>
			       (ctx->config->slave << LPSPI_MASTER_PCS_SHIFT);
6000654e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
60006550:	88d2      	ldrh	r2, [r2, #6]
60006552:	0112      	lsls	r2, r2, #4
	transfer.configFlags = kLPSPI_MasterPcsContinuous |
60006554:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
60006558:	9203      	str	r2, [sp, #12]
		transfer.txData = (uint8_t *) ctx->tx_buf;
6000655a:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
	} else if (ctx->rx_len == 0) {
6000655e:	b305      	cbz	r5, 600065a2 <spi_mcux_master_transfer_callback+0x12a>
	} else if (ctx->tx_len == ctx->rx_len) {
60006560:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
60006564:	42ab      	cmp	r3, r5
		transfer.rxData = ctx->rx_buf;
60006566:	e9cd 2100 	strd	r2, r1, [sp]
	} else if (ctx->tx_len == ctx->rx_len) {
6000656a:	d01c      	beq.n	600065a6 <spi_mcux_master_transfer_callback+0x12e>
	} else if (ctx->tx_len > ctx->rx_len) {
6000656c:	d91b      	bls.n	600065a6 <spi_mcux_master_transfer_callback+0x12e>
6000656e:	e009      	b.n	60006584 <spi_mcux_master_transfer_callback+0x10c>
			       (ctx->config->slave << LPSPI_MASTER_PCS_SHIFT);
60006570:	6be2      	ldr	r2, [r4, #60]	; 0x3c
		transfer.txData = NULL;
60006572:	9300      	str	r3, [sp, #0]
			       (ctx->config->slave << LPSPI_MASTER_PCS_SHIFT);
60006574:	88d2      	ldrh	r2, [r2, #6]
		transfer.rxData = ctx->rx_buf;
60006576:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
			       (ctx->config->slave << LPSPI_MASTER_PCS_SHIFT);
6000657a:	0112      	lsls	r2, r2, #4
		transfer.rxData = ctx->rx_buf;
6000657c:	9301      	str	r3, [sp, #4]
	transfer.configFlags = kLPSPI_MasterPcsContinuous |
6000657e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
60006582:	9203      	str	r2, [sp, #12]
		transfer.dataSize = ctx->rx_len;
60006584:	9502      	str	r5, [sp, #8]
	data->transfer_len = transfer.dataSize;
60006586:	9b02      	ldr	r3, [sp, #8]
	status = LPSPI_MasterTransferNonBlocking(base, &data->handle,
60006588:	466a      	mov	r2, sp
6000658a:	1d21      	adds	r1, r4, #4
	data->transfer_len = transfer.dataSize;
6000658c:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
	status = LPSPI_MasterTransferNonBlocking(base, &data->handle,
60006590:	f001 fff4 	bl	6000857c <LPSPI_MasterTransferNonBlocking>
	if (status != kStatus_Success) {
60006594:	b118      	cbz	r0, 6000659e <spi_mcux_master_transfer_callback+0x126>
		LOG_ERR("Transfer could not start");
60006596:	2145      	movs	r1, #69	; 0x45
60006598:	4805      	ldr	r0, [pc, #20]	; (600065b0 <spi_mcux_master_transfer_callback+0x138>)
6000659a:	f004 faa1 	bl	6000aae0 <z_log_minimal_printk>
}
6000659e:	b005      	add	sp, #20
600065a0:	bd30      	pop	{r4, r5, pc}
		transfer.rxData = NULL;
600065a2:	e9cd 2500 	strd	r2, r5, [sp]
		transfer.dataSize = ctx->tx_len;
600065a6:	9302      	str	r3, [sp, #8]
		transfer.configFlags |= kLPSPI_MasterPcsContinuous;
600065a8:	e7ed      	b.n	60006586 <spi_mcux_master_transfer_callback+0x10e>
600065aa:	bf00      	nop
600065ac:	6000d4a2 	.word	0x6000d4a2
600065b0:	6000d4c5 	.word	0x6000d4c5

600065b4 <spi_mcux_init>:

	return 0;
}

static int spi_mcux_init(const struct device *dev)
{
600065b4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int err;
	const struct spi_mcux_config *config = dev->config;
600065b8:	f8d0 8004 	ldr.w	r8, [r0, #4]
{
600065bc:	4607      	mov	r7, r0
	struct spi_mcux_data *data = dev->data;
600065be:	6905      	ldr	r5, [r0, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
600065c0:	f04f 0901 	mov.w	r9, #1

	config->irq_config_func(dev);
600065c4:	f8d8 300c 	ldr.w	r3, [r8, #12]
600065c8:	4798      	blx	r3
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
600065ca:	6c6e      	ldr	r6, [r5, #68]	; 0x44
600065cc:	e9d5 3211 	ldrd	r3, r2, [r5, #68]	; 0x44
600065d0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
600065d4:	429e      	cmp	r6, r3
600065d6:	d313      	bcc.n	60006600 <spi_mcux_init+0x4c>

	err = spi_context_cs_configure_all(&data->ctx);
600065d8:	f105 063c 	add.w	r6, r5, #60	; 0x3c
	if (err < 0) {
		return err;
	}

	spi_context_unlock_unconditionally(&data->ctx);
600065dc:	4630      	mov	r0, r6
600065de:	f004 ff0f 	bl	6000b400 <spi_context_unlock_unconditionally>

	data->dev = dev;

#ifdef CONFIG_SPI_MCUX_LPSPI_DMA
	if (!device_is_ready(data->dma_tx.dma_dev)) {
600065e2:	f8d5 00dc 	ldr.w	r0, [r5, #220]	; 0xdc
	data->dev = dev;
600065e6:	602f      	str	r7, [r5, #0]
600065e8:	f004 ff4c 	bl	6000b484 <z_device_is_ready>
	if (!device_is_ready(data->dma_tx.dma_dev)) {
600065ec:	2800      	cmp	r0, #0
600065ee:	d16d      	bne.n	600066cc <spi_mcux_init+0x118>
		LOG_ERR("%s device is not ready", data->dma_tx.dma_dev->name);
600065f0:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
		return -ENODEV;
	}

	if (!device_is_ready(data->dma_rx.dma_dev)) {
		LOG_ERR("%s device is not ready", data->dma_rx.dma_dev->name);
600065f4:	681a      	ldr	r2, [r3, #0]
600065f6:	2145      	movs	r1, #69	; 0x45
600065f8:	4843      	ldr	r0, [pc, #268]	; (60006708 <spi_mcux_init+0x154>)
600065fa:	f004 fa71 	bl	6000aae0 <z_log_minimal_printk>
		return -ENODEV;
600065fe:	e00a      	b.n	60006616 <spi_mcux_init+0x62>
		if (!device_is_ready(cs_gpio->port)) {
60006600:	6830      	ldr	r0, [r6, #0]
60006602:	f004 ff3f 	bl	6000b484 <z_device_is_ready>
60006606:	b960      	cbnz	r0, 60006622 <spi_mcux_init+0x6e>
			LOG_ERR("CS GPIO port %s pin %d is not ready",
60006608:	6832      	ldr	r2, [r6, #0]
6000660a:	2145      	movs	r1, #69	; 0x45
6000660c:	7933      	ldrb	r3, [r6, #4]
6000660e:	6812      	ldr	r2, [r2, #0]
60006610:	483e      	ldr	r0, [pc, #248]	; (6000670c <spi_mcux_init+0x158>)
60006612:	f004 fa65 	bl	6000aae0 <z_log_minimal_printk>
		return -ENODEV;
60006616:	f06f 0412 	mvn.w	r4, #18
#endif /* CONFIG_PINCTRL */

	spi_context_unlock_unconditionally(&data->ctx);

	return 0;
}
6000661a:	4620      	mov	r0, r4
6000661c:	b003      	add	sp, #12
6000661e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return gpio_pin_configure(spec->port,
60006622:	6830      	ldr	r0, [r6, #0]
				  spec->pin,
60006624:	7931      	ldrb	r1, [r6, #4]
				  spec->dt_flags | extra_flags);
60006626:	88f3      	ldrh	r3, [r6, #6]
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
60006628:	f003 0230 	and.w	r2, r3, #48	; 0x30
	struct gpio_driver_data *data =
6000662c:	f8d0 e010 	ldr.w	lr, [r0, #16]
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
60006630:	2a30      	cmp	r2, #48	; 0x30
	__unused const struct gpio_driver_config *const cfg =
60006632:	e9d0 ba01 	ldrd	fp, sl, [r0, #4]
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
60006636:	d10e      	bne.n	60006656 <spi_mcux_init+0xa2>
60006638:	4935      	ldr	r1, [pc, #212]	; (60006710 <spi_mcux_init+0x15c>)
6000663a:	f240 23b9 	movw	r3, #697	; 0x2b9
6000663e:	4a35      	ldr	r2, [pc, #212]	; (60006714 <spi_mcux_init+0x160>)
60006640:	4835      	ldr	r0, [pc, #212]	; (60006718 <spi_mcux_init+0x164>)
60006642:	f004 fa3d 	bl	6000aac0 <assert_print>
60006646:	4835      	ldr	r0, [pc, #212]	; (6000671c <spi_mcux_init+0x168>)
60006648:	f004 fa3a 	bl	6000aac0 <assert_print>
6000664c:	f240 21b9 	movw	r1, #697	; 0x2b9
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
60006650:	4830      	ldr	r0, [pc, #192]	; (60006714 <spi_mcux_init+0x160>)
60006652:	f004 fa2e 	bl	6000aab2 <assert_post_action>
60006656:	f003 0206 	and.w	r2, r3, #6
6000665a:	2a04      	cmp	r2, #4
6000665c:	d109      	bne.n	60006672 <spi_mcux_init+0xbe>
6000665e:	4930      	ldr	r1, [pc, #192]	; (60006720 <spi_mcux_init+0x16c>)
60006660:	f44f 7330 	mov.w	r3, #704	; 0x2c0
60006664:	4a2b      	ldr	r2, [pc, #172]	; (60006714 <spi_mcux_init+0x160>)
60006666:	482c      	ldr	r0, [pc, #176]	; (60006718 <spi_mcux_init+0x164>)
60006668:	f004 fa2a 	bl	6000aac0 <assert_print>
6000666c:	f44f 7130 	mov.w	r1, #704	; 0x2c0
60006670:	e7ee      	b.n	60006650 <spi_mcux_init+0x9c>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
60006672:	07da      	lsls	r2, r3, #31
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
60006674:	fa09 fc01 	lsl.w	ip, r9, r1
	return gpio_pin_configure(spec->port,
60006678:	bf54      	ite	pl
6000667a:	f443 14b0 	orrpl.w	r4, r3, #1441792	; 0x160000
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
6000667e:	f483 14d0 	eormi.w	r4, r3, #1703936	; 0x1a0000
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
60006682:	f8db 3000 	ldr.w	r3, [fp]
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
60006686:	f424 1280 	bic.w	r2, r4, #1048576	; 0x100000
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
6000668a:	ea1c 0f03 	tst.w	ip, r3
6000668e:	d10c      	bne.n	600066aa <spi_mcux_init+0xf6>
60006690:	4924      	ldr	r1, [pc, #144]	; (60006724 <spi_mcux_init+0x170>)
60006692:	f240 23d3 	movw	r3, #723	; 0x2d3
60006696:	4a1f      	ldr	r2, [pc, #124]	; (60006714 <spi_mcux_init+0x160>)
60006698:	481f      	ldr	r0, [pc, #124]	; (60006718 <spi_mcux_init+0x164>)
6000669a:	f004 fa11 	bl	6000aac0 <assert_print>
6000669e:	4822      	ldr	r0, [pc, #136]	; (60006728 <spi_mcux_init+0x174>)
600066a0:	f004 fa0e 	bl	6000aac0 <assert_print>
600066a4:	f240 21d3 	movw	r1, #723	; 0x2d3
600066a8:	e7d2      	b.n	60006650 <spi_mcux_init+0x9c>
		data->invert |= (gpio_port_pins_t)BIT(pin);
600066aa:	f8de 3000 	ldr.w	r3, [lr]
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
600066ae:	07e4      	lsls	r4, r4, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
600066b0:	bf4c      	ite	mi
600066b2:	ea4c 0303 	orrmi.w	r3, ip, r3
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
600066b6:	ea23 030c 	bicpl.w	r3, r3, ip
600066ba:	f8ce 3000 	str.w	r3, [lr]
	return api->pin_configure(port, pin, flags);
600066be:	f8da 3000 	ldr.w	r3, [sl]
600066c2:	4798      	blx	r3
		if (ret < 0) {
600066c4:	1e04      	subs	r4, r0, #0
600066c6:	dba8      	blt.n	6000661a <spi_mcux_init+0x66>
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
600066c8:	3608      	adds	r6, #8
600066ca:	e77f      	b.n	600065cc <spi_mcux_init+0x18>
	if (!device_is_ready(data->dma_rx.dma_dev)) {
600066cc:	f8d5 0098 	ldr.w	r0, [r5, #152]	; 0x98
600066d0:	f004 fed8 	bl	6000b484 <z_device_is_ready>
600066d4:	b910      	cbnz	r0, 600066dc <spi_mcux_init+0x128>
		LOG_ERR("%s device is not ready", data->dma_rx.dma_dev->name);
600066d6:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
600066da:	e78b      	b.n	600065f4 <spi_mcux_init+0x40>
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
600066dc:	aa01      	add	r2, sp, #4
600066de:	2100      	movs	r1, #0
600066e0:	f8d8 001c 	ldr.w	r0, [r8, #28]
600066e4:	f004 fce2 	bl	6000b0ac <pinctrl_lookup_state>
	if (ret < 0) {
600066e8:	1e04      	subs	r4, r0, #0
600066ea:	db96      	blt.n	6000661a <spi_mcux_init+0x66>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
600066ec:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
600066ee:	2200      	movs	r2, #0
600066f0:	7919      	ldrb	r1, [r3, #4]
600066f2:	6818      	ldr	r0, [r3, #0]
600066f4:	f004 fced 	bl	6000b0d2 <pinctrl_configure_pins>
	if (err) {
600066f8:	4604      	mov	r4, r0
600066fa:	2800      	cmp	r0, #0
600066fc:	d18d      	bne.n	6000661a <spi_mcux_init+0x66>
	spi_context_unlock_unconditionally(&data->ctx);
600066fe:	4630      	mov	r0, r6
60006700:	f004 fe7e 	bl	6000b400 <spi_context_unlock_unconditionally>
	return 0;
60006704:	e789      	b.n	6000661a <spi_mcux_init+0x66>
60006706:	bf00      	nop
60006708:	6000d5b5 	.word	0x6000d5b5
6000670c:	6000d4e3 	.word	0x6000d4e3
60006710:	6000d50c 	.word	0x6000d50c
60006714:	6000d392 	.word	0x6000d392
60006718:	6000c68a 	.word	0x6000c68a
6000671c:	6000d545 	.word	0x6000d545
60006720:	6000d582 	.word	0x6000d582
60006724:	6000d3c3 	.word	0x6000d3c3
60006728:	6000d401 	.word	0x6000d401

6000672c <elapsed>:
 *     - and until the current call of the function is completed.
 * - the function is invoked with interrupts disabled.
 */
static uint32_t elapsed(void)
{
	uint32_t val1 = SysTick->VAL;	/* A */
6000672c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
{
60006730:	b510      	push	{r4, lr}
	uint32_t val1 = SysTick->VAL;	/* A */
60006732:	699a      	ldr	r2, [r3, #24]
	uint32_t ctrl = SysTick->CTRL;	/* B */
60006734:	6919      	ldr	r1, [r3, #16]
	uint32_t val2 = SysTick->VAL;	/* C */
60006736:	6998      	ldr	r0, [r3, #24]
	 * 4) After C we'll see it next time
	 *
	 * So the count in val2 is post-wrap and last_load needs to be
	 * added if and only if COUNTFLAG is set or val1 < val2.
	 */
	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
60006738:	f411 3f80 	tst.w	r1, #65536	; 0x10000
6000673c:	4b08      	ldr	r3, [pc, #32]	; (60006760 <elapsed+0x34>)
6000673e:	4909      	ldr	r1, [pc, #36]	; (60006764 <elapsed+0x38>)
60006740:	d101      	bne.n	60006746 <elapsed+0x1a>
	    || (val1 < val2)) {
60006742:	4282      	cmp	r2, r0
60006744:	d206      	bcs.n	60006754 <elapsed+0x28>
		overflow_cyc += last_load;
60006746:	681a      	ldr	r2, [r3, #0]
60006748:	680c      	ldr	r4, [r1, #0]
6000674a:	4422      	add	r2, r4
6000674c:	601a      	str	r2, [r3, #0]

		/* We know there was a wrap, but we might not have
		 * seen it in CTRL, so clear it. */
		(void)SysTick->CTRL;
6000674e:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
60006752:	6912      	ldr	r2, [r2, #16]
	}

	return (last_load - val2) + overflow_cyc;
60006754:	681b      	ldr	r3, [r3, #0]
60006756:	680a      	ldr	r2, [r1, #0]
60006758:	4413      	add	r3, r2
}
6000675a:	1a18      	subs	r0, r3, r0
6000675c:	bd10      	pop	{r4, pc}
6000675e:	bf00      	nop
60006760:	80001614 	.word	0x80001614
60006764:	80001620 	.word	0x80001620

60006768 <sys_clock_driver_init>:
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
60006768:	4b09      	ldr	r3, [pc, #36]	; (60006790 <sys_clock_driver_init+0x28>)
6000676a:	2210      	movs	r2, #16
{
	ARG_UNUSED(dev);

	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
	last_load = CYC_PER_TICK - 1;
	overflow_cyc = 0U;
6000676c:	2000      	movs	r0, #0
6000676e:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	last_load = CYC_PER_TICK - 1;
60006772:	f24c 324f 	movw	r2, #49999	; 0xc34f
60006776:	4b07      	ldr	r3, [pc, #28]	; (60006794 <sys_clock_driver_init+0x2c>)
60006778:	601a      	str	r2, [r3, #0]
	overflow_cyc = 0U;
6000677a:	4b07      	ldr	r3, [pc, #28]	; (60006798 <sys_clock_driver_init+0x30>)
6000677c:	6018      	str	r0, [r3, #0]
	SysTick->LOAD = last_load;
6000677e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
60006782:	615a      	str	r2, [r3, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
60006784:	6198      	str	r0, [r3, #24]
	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
60006786:	691a      	ldr	r2, [r3, #16]
60006788:	f042 0207 	orr.w	r2, r2, #7
6000678c:	611a      	str	r2, [r3, #16]
			  SysTick_CTRL_TICKINT_Msk |
			  SysTick_CTRL_CLKSOURCE_Msk);
	return 0;
}
6000678e:	4770      	bx	lr
60006790:	e000ed00 	.word	0xe000ed00
60006794:	80001620 	.word	0x80001620
60006798:	80001614 	.word	0x80001614

6000679c <sys_clock_isr>:
{
6000679c:	b508      	push	{r3, lr}
	elapsed();
6000679e:	f7ff ffc5 	bl	6000672c <elapsed>
	cycle_count += overflow_cyc;
600067a2:	4b0c      	ldr	r3, [pc, #48]	; (600067d4 <sys_clock_isr+0x38>)
600067a4:	4a0c      	ldr	r2, [pc, #48]	; (600067d8 <sys_clock_isr+0x3c>)
600067a6:	6818      	ldr	r0, [r3, #0]
600067a8:	6811      	ldr	r1, [r2, #0]
600067aa:	4408      	add	r0, r1
		dticks = (cycle_count - announced_cycles) / CYC_PER_TICK;
600067ac:	f24c 3150 	movw	r1, #50000	; 0xc350
	cycle_count += overflow_cyc;
600067b0:	6010      	str	r0, [r2, #0]
	overflow_cyc = 0;
600067b2:	2200      	movs	r2, #0
600067b4:	601a      	str	r2, [r3, #0]
		dticks = (cycle_count - announced_cycles) / CYC_PER_TICK;
600067b6:	4a09      	ldr	r2, [pc, #36]	; (600067dc <sys_clock_isr+0x40>)
600067b8:	6813      	ldr	r3, [r2, #0]
600067ba:	1ac0      	subs	r0, r0, r3
600067bc:	fbb0 f0f1 	udiv	r0, r0, r1
		announced_cycles += dticks * CYC_PER_TICK;
600067c0:	fb01 3300 	mla	r3, r1, r0, r3
600067c4:	6013      	str	r3, [r2, #0]
		sys_clock_announce(dticks);
600067c6:	f003 ffe3 	bl	6000a790 <sys_clock_announce>
}
600067ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
600067ce:	f7fe b91b 	b.w	60004a08 <z_arm_exc_exit>
600067d2:	bf00      	nop
600067d4:	80001614 	.word	0x80001614
600067d8:	8000161c 	.word	0x8000161c
600067dc:	80001618 	.word	0x80001618

600067e0 <sys_clock_set_timeout>:
{
600067e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
600067e4:	4e44      	ldr	r6, [pc, #272]	; (600068f8 <sys_clock_set_timeout+0x118>)
	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
600067e6:	b371      	cbz	r1, 60006846 <sys_clock_set_timeout+0x66>
600067e8:	1c42      	adds	r2, r0, #1
600067ea:	d10a      	bne.n	60006802 <sys_clock_set_timeout+0x22>
		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
600067ec:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
600067f0:	6913      	ldr	r3, [r2, #16]
600067f2:	f023 0301 	bic.w	r3, r3, #1
600067f6:	6113      	str	r3, [r2, #16]
		last_load = TIMER_STOPPED;
600067f8:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
600067fc:	6033      	str	r3, [r6, #0]
}
600067fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint32_t last_load_ = last_load;
60006802:	6834      	ldr	r4, [r6, #0]
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
60006804:	2801      	cmp	r0, #1
60006806:	dd24      	ble.n	60006852 <sys_clock_set_timeout+0x72>
60006808:	f5b0 7fa7 	cmp.w	r0, #334	; 0x14e
6000680c:	dc24      	bgt.n	60006858 <sys_clock_set_timeout+0x78>
6000680e:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
	__asm__ volatile(
60006812:	f04f 0310 	mov.w	r3, #16
60006816:	f3ef 8511 	mrs	r5, BASEPRI
6000681a:	f383 8812 	msr	BASEPRI_MAX, r3
6000681e:	f3bf 8f6f 	isb	sy
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
60006822:	4836      	ldr	r0, [pc, #216]	; (600068fc <sys_clock_set_timeout+0x11c>)
60006824:	f002 fc40 	bl	600090a8 <z_spin_lock_valid>
60006828:	b9c8      	cbnz	r0, 6000685e <sys_clock_set_timeout+0x7e>
6000682a:	2394      	movs	r3, #148	; 0x94
6000682c:	4a34      	ldr	r2, [pc, #208]	; (60006900 <sys_clock_set_timeout+0x120>)
6000682e:	4935      	ldr	r1, [pc, #212]	; (60006904 <sys_clock_set_timeout+0x124>)
60006830:	4835      	ldr	r0, [pc, #212]	; (60006908 <sys_clock_set_timeout+0x128>)
60006832:	f004 f945 	bl	6000aac0 <assert_print>
60006836:	4931      	ldr	r1, [pc, #196]	; (600068fc <sys_clock_set_timeout+0x11c>)
60006838:	4834      	ldr	r0, [pc, #208]	; (6000690c <sys_clock_set_timeout+0x12c>)
6000683a:	f004 f941 	bl	6000aac0 <assert_print>
6000683e:	2194      	movs	r1, #148	; 0x94
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60006840:	482f      	ldr	r0, [pc, #188]	; (60006900 <sys_clock_set_timeout+0x120>)
60006842:	f004 f936 	bl	6000aab2 <assert_post_action>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
60006846:	1c43      	adds	r3, r0, #1
	uint32_t last_load_ = last_load;
60006848:	6834      	ldr	r4, [r6, #0]
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
6000684a:	d1db      	bne.n	60006804 <sys_clock_set_timeout+0x24>
6000684c:	f44f 70a7 	mov.w	r0, #334	; 0x14e
60006850:	e7dd      	b.n	6000680e <sys_clock_set_timeout+0x2e>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
60006852:	f04f 0800 	mov.w	r8, #0
60006856:	e7dc      	b.n	60006812 <sys_clock_set_timeout+0x32>
60006858:	f44f 78a7 	mov.w	r8, #334	; 0x14e
6000685c:	e7d9      	b.n	60006812 <sys_clock_set_timeout+0x32>
	z_spin_lock_set_owner(l);
6000685e:	4827      	ldr	r0, [pc, #156]	; (600068fc <sys_clock_set_timeout+0x11c>)
60006860:	f002 fc3e 	bl	600090e0 <z_spin_lock_set_owner>
	uint32_t pending = elapsed();
60006864:	f7ff ff62 	bl	6000672c <elapsed>
	val1 = SysTick->VAL;
60006868:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
	cycle_count += pending;
6000686c:	4928      	ldr	r1, [pc, #160]	; (60006910 <sys_clock_set_timeout+0x130>)
	overflow_cyc = 0U;
6000686e:	2200      	movs	r2, #0
	val1 = SysTick->VAL;
60006870:	699f      	ldr	r7, [r3, #24]
	cycle_count += pending;
60006872:	680b      	ldr	r3, [r1, #0]
60006874:	4418      	add	r0, r3
	overflow_cyc = 0U;
60006876:	4b27      	ldr	r3, [pc, #156]	; (60006914 <sys_clock_set_timeout+0x134>)
60006878:	601a      	str	r2, [r3, #0]
	uint32_t unannounced = cycle_count - announced_cycles;
6000687a:	4b27      	ldr	r3, [pc, #156]	; (60006918 <sys_clock_set_timeout+0x138>)
6000687c:	681b      	ldr	r3, [r3, #0]
	if ((int32_t)unannounced < 0) {
6000687e:	1ac2      	subs	r2, r0, r3
60006880:	d432      	bmi.n	600068e8 <sys_clock_set_timeout+0x108>
		delay = ticks * CYC_PER_TICK;
60006882:	f24c 3c50 	movw	ip, #50000	; 0xc350
		delay -= unannounced;
60006886:	1a1b      	subs	r3, r3, r0
		 ((delay + CYC_PER_TICK - 1) / CYC_PER_TICK) * CYC_PER_TICK;
60006888:	fb0c 2208 	mla	r2, ip, r8, r2
6000688c:	f502 4243 	add.w	r2, r2, #49920	; 0xc300
60006890:	324f      	adds	r2, #79	; 0x4f
60006892:	fbb2 f2fc 	udiv	r2, r2, ip
		delay -= unannounced;
60006896:	fb0c 3302 	mla	r3, ip, r2, r3
		delay = MAX(delay, MIN_DELAY);
6000689a:	f640 4235 	movw	r2, #3125	; 0xc35
6000689e:	4293      	cmp	r3, r2
600068a0:	d922      	bls.n	600068e8 <sys_clock_set_timeout+0x108>
		if (delay > MAX_CYCLES) {
600068a2:	4a1e      	ldr	r2, [pc, #120]	; (6000691c <sys_clock_set_timeout+0x13c>)
600068a4:	4293      	cmp	r3, r2
600068a6:	bf28      	it	cs
600068a8:	4613      	movcs	r3, r2
	val2 = SysTick->VAL;
600068aa:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
		last_load = MIN_DELAY;
600068ae:	6033      	str	r3, [r6, #0]
	SysTick->LOAD = last_load - 1;
600068b0:	3b01      	subs	r3, #1
	val2 = SysTick->VAL;
600068b2:	6996      	ldr	r6, [r2, #24]
	SysTick->LOAD = last_load - 1;
600068b4:	6153      	str	r3, [r2, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
600068b6:	2300      	movs	r3, #0
	if (val1 < val2) {
600068b8:	42b7      	cmp	r7, r6
600068ba:	eba7 0706 	sub.w	r7, r7, r6
	SysTick->VAL = 0; /* resets timer to last_load */
600068be:	6193      	str	r3, [r2, #24]
		cycle_count += (val1 + (last_load_ - val2));
600068c0:	bf38      	it	cc
600068c2:	193f      	addcc	r7, r7, r4
		cycle_count += (val1 - val2);
600068c4:	4438      	add	r0, r7
600068c6:	6008      	str	r0, [r1, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
600068c8:	480c      	ldr	r0, [pc, #48]	; (600068fc <sys_clock_set_timeout+0x11c>)
600068ca:	f002 fbfb 	bl	600090c4 <z_spin_unlock_valid>
600068ce:	b970      	cbnz	r0, 600068ee <sys_clock_set_timeout+0x10e>
600068d0:	23c2      	movs	r3, #194	; 0xc2
600068d2:	4a0b      	ldr	r2, [pc, #44]	; (60006900 <sys_clock_set_timeout+0x120>)
600068d4:	4912      	ldr	r1, [pc, #72]	; (60006920 <sys_clock_set_timeout+0x140>)
600068d6:	480c      	ldr	r0, [pc, #48]	; (60006908 <sys_clock_set_timeout+0x128>)
600068d8:	f004 f8f2 	bl	6000aac0 <assert_print>
600068dc:	4907      	ldr	r1, [pc, #28]	; (600068fc <sys_clock_set_timeout+0x11c>)
600068de:	4811      	ldr	r0, [pc, #68]	; (60006924 <sys_clock_set_timeout+0x144>)
600068e0:	f004 f8ee 	bl	6000aac0 <assert_print>
600068e4:	21c2      	movs	r1, #194	; 0xc2
600068e6:	e7ab      	b.n	60006840 <sys_clock_set_timeout+0x60>
600068e8:	f640 4335 	movw	r3, #3125	; 0xc35
600068ec:	e7dd      	b.n	600068aa <sys_clock_set_timeout+0xca>
	__asm__ volatile(
600068ee:	f385 8811 	msr	BASEPRI, r5
600068f2:	f3bf 8f6f 	isb	sy
600068f6:	e782      	b.n	600067fe <sys_clock_set_timeout+0x1e>
600068f8:	80001620 	.word	0x80001620
600068fc:	80001624 	.word	0x80001624
60006900:	6000d5ed 	.word	0x6000d5ed
60006904:	6000d61a 	.word	0x6000d61a
60006908:	6000c68a 	.word	0x6000c68a
6000690c:	6000d62f 	.word	0x6000d62f
60006910:	8000161c 	.word	0x8000161c
60006914:	80001614 	.word	0x80001614
60006918:	80001618 	.word	0x80001618
6000691c:	00fed260 	.word	0x00fed260
60006920:	6000d647 	.word	0x6000d647
60006924:	6000d65e 	.word	0x6000d65e

60006928 <sys_clock_elapsed>:
{
60006928:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
6000692a:	f04f 0310 	mov.w	r3, #16
6000692e:	f3ef 8511 	mrs	r5, BASEPRI
60006932:	f383 8812 	msr	BASEPRI_MAX, r3
60006936:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000693a:	481b      	ldr	r0, [pc, #108]	; (600069a8 <sys_clock_elapsed+0x80>)
6000693c:	f002 fbb4 	bl	600090a8 <z_spin_lock_valid>
60006940:	b968      	cbnz	r0, 6000695e <sys_clock_elapsed+0x36>
60006942:	2394      	movs	r3, #148	; 0x94
60006944:	4a19      	ldr	r2, [pc, #100]	; (600069ac <sys_clock_elapsed+0x84>)
60006946:	491a      	ldr	r1, [pc, #104]	; (600069b0 <sys_clock_elapsed+0x88>)
60006948:	481a      	ldr	r0, [pc, #104]	; (600069b4 <sys_clock_elapsed+0x8c>)
6000694a:	f004 f8b9 	bl	6000aac0 <assert_print>
6000694e:	4916      	ldr	r1, [pc, #88]	; (600069a8 <sys_clock_elapsed+0x80>)
60006950:	4819      	ldr	r0, [pc, #100]	; (600069b8 <sys_clock_elapsed+0x90>)
60006952:	f004 f8b5 	bl	6000aac0 <assert_print>
60006956:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60006958:	4814      	ldr	r0, [pc, #80]	; (600069ac <sys_clock_elapsed+0x84>)
6000695a:	f004 f8aa 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
6000695e:	4812      	ldr	r0, [pc, #72]	; (600069a8 <sys_clock_elapsed+0x80>)
60006960:	f002 fbbe 	bl	600090e0 <z_spin_lock_set_owner>
	uint32_t cyc = elapsed() + cycle_count - announced_cycles;
60006964:	f7ff fee2 	bl	6000672c <elapsed>
60006968:	4b14      	ldr	r3, [pc, #80]	; (600069bc <sys_clock_elapsed+0x94>)
6000696a:	681c      	ldr	r4, [r3, #0]
6000696c:	4b14      	ldr	r3, [pc, #80]	; (600069c0 <sys_clock_elapsed+0x98>)
6000696e:	681b      	ldr	r3, [r3, #0]
60006970:	1ae4      	subs	r4, r4, r3
60006972:	4404      	add	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60006974:	480c      	ldr	r0, [pc, #48]	; (600069a8 <sys_clock_elapsed+0x80>)
60006976:	f002 fba5 	bl	600090c4 <z_spin_unlock_valid>
6000697a:	b958      	cbnz	r0, 60006994 <sys_clock_elapsed+0x6c>
6000697c:	23c2      	movs	r3, #194	; 0xc2
6000697e:	4a0b      	ldr	r2, [pc, #44]	; (600069ac <sys_clock_elapsed+0x84>)
60006980:	4910      	ldr	r1, [pc, #64]	; (600069c4 <sys_clock_elapsed+0x9c>)
60006982:	480c      	ldr	r0, [pc, #48]	; (600069b4 <sys_clock_elapsed+0x8c>)
60006984:	f004 f89c 	bl	6000aac0 <assert_print>
60006988:	4907      	ldr	r1, [pc, #28]	; (600069a8 <sys_clock_elapsed+0x80>)
6000698a:	480f      	ldr	r0, [pc, #60]	; (600069c8 <sys_clock_elapsed+0xa0>)
6000698c:	f004 f898 	bl	6000aac0 <assert_print>
60006990:	21c2      	movs	r1, #194	; 0xc2
60006992:	e7e1      	b.n	60006958 <sys_clock_elapsed+0x30>
	__asm__ volatile(
60006994:	f385 8811 	msr	BASEPRI, r5
60006998:	f3bf 8f6f 	isb	sy
}
6000699c:	f24c 3050 	movw	r0, #50000	; 0xc350
600069a0:	fbb4 f0f0 	udiv	r0, r4, r0
600069a4:	bd38      	pop	{r3, r4, r5, pc}
600069a6:	bf00      	nop
600069a8:	80001624 	.word	0x80001624
600069ac:	6000d5ed 	.word	0x6000d5ed
600069b0:	6000d61a 	.word	0x6000d61a
600069b4:	6000c68a 	.word	0x6000c68a
600069b8:	6000d62f 	.word	0x6000d62f
600069bc:	8000161c 	.word	0x8000161c
600069c0:	80001618 	.word	0x80001618
600069c4:	6000d647 	.word	0x6000d647
600069c8:	6000d65e 	.word	0x6000d65e

600069cc <sys_clock_cycle_get_32>:
{
600069cc:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
600069ce:	f04f 0310 	mov.w	r3, #16
600069d2:	f3ef 8511 	mrs	r5, BASEPRI
600069d6:	f383 8812 	msr	BASEPRI_MAX, r3
600069da:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
600069de:	4818      	ldr	r0, [pc, #96]	; (60006a40 <sys_clock_cycle_get_32+0x74>)
600069e0:	f002 fb62 	bl	600090a8 <z_spin_lock_valid>
600069e4:	b968      	cbnz	r0, 60006a02 <sys_clock_cycle_get_32+0x36>
600069e6:	2394      	movs	r3, #148	; 0x94
600069e8:	4a16      	ldr	r2, [pc, #88]	; (60006a44 <sys_clock_cycle_get_32+0x78>)
600069ea:	4917      	ldr	r1, [pc, #92]	; (60006a48 <sys_clock_cycle_get_32+0x7c>)
600069ec:	4817      	ldr	r0, [pc, #92]	; (60006a4c <sys_clock_cycle_get_32+0x80>)
600069ee:	f004 f867 	bl	6000aac0 <assert_print>
600069f2:	4913      	ldr	r1, [pc, #76]	; (60006a40 <sys_clock_cycle_get_32+0x74>)
600069f4:	4816      	ldr	r0, [pc, #88]	; (60006a50 <sys_clock_cycle_get_32+0x84>)
600069f6:	f004 f863 	bl	6000aac0 <assert_print>
600069fa:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
600069fc:	4811      	ldr	r0, [pc, #68]	; (60006a44 <sys_clock_cycle_get_32+0x78>)
600069fe:	f004 f858 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
60006a02:	480f      	ldr	r0, [pc, #60]	; (60006a40 <sys_clock_cycle_get_32+0x74>)
60006a04:	f002 fb6c 	bl	600090e0 <z_spin_lock_set_owner>
	uint32_t ret = elapsed() + cycle_count;
60006a08:	f7ff fe90 	bl	6000672c <elapsed>
60006a0c:	4b11      	ldr	r3, [pc, #68]	; (60006a54 <sys_clock_cycle_get_32+0x88>)
60006a0e:	681c      	ldr	r4, [r3, #0]
60006a10:	4404      	add	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60006a12:	480b      	ldr	r0, [pc, #44]	; (60006a40 <sys_clock_cycle_get_32+0x74>)
60006a14:	f002 fb56 	bl	600090c4 <z_spin_unlock_valid>
60006a18:	b958      	cbnz	r0, 60006a32 <sys_clock_cycle_get_32+0x66>
60006a1a:	23c2      	movs	r3, #194	; 0xc2
60006a1c:	4a09      	ldr	r2, [pc, #36]	; (60006a44 <sys_clock_cycle_get_32+0x78>)
60006a1e:	490e      	ldr	r1, [pc, #56]	; (60006a58 <sys_clock_cycle_get_32+0x8c>)
60006a20:	480a      	ldr	r0, [pc, #40]	; (60006a4c <sys_clock_cycle_get_32+0x80>)
60006a22:	f004 f84d 	bl	6000aac0 <assert_print>
60006a26:	4906      	ldr	r1, [pc, #24]	; (60006a40 <sys_clock_cycle_get_32+0x74>)
60006a28:	480c      	ldr	r0, [pc, #48]	; (60006a5c <sys_clock_cycle_get_32+0x90>)
60006a2a:	f004 f849 	bl	6000aac0 <assert_print>
60006a2e:	21c2      	movs	r1, #194	; 0xc2
60006a30:	e7e4      	b.n	600069fc <sys_clock_cycle_get_32+0x30>
	__asm__ volatile(
60006a32:	f385 8811 	msr	BASEPRI, r5
60006a36:	f3bf 8f6f 	isb	sy
}
60006a3a:	4620      	mov	r0, r4
60006a3c:	bd38      	pop	{r3, r4, r5, pc}
60006a3e:	bf00      	nop
60006a40:	80001624 	.word	0x80001624
60006a44:	6000d5ed 	.word	0x6000d5ed
60006a48:	6000d61a 	.word	0x6000d61a
60006a4c:	6000c68a 	.word	0x6000c68a
60006a50:	6000d62f 	.word	0x6000d62f
60006a54:	8000161c 	.word	0x8000161c
60006a58:	6000d647 	.word	0x6000d647
60006a5c:	6000d65e 	.word	0x6000d65e

60006a60 <CLOCK_GetOscFreq>:
60006a60:	4b04      	ldr	r3, [pc, #16]	; (60006a74 <CLOCK_GetOscFreq+0x14>)
60006a62:	f8d3 3270 	ldr.w	r3, [r3, #624]	; 0x270
60006a66:	06db      	lsls	r3, r3, #27
60006a68:	d402      	bmi.n	60006a70 <CLOCK_GetOscFreq+0x10>
60006a6a:	4b03      	ldr	r3, [pc, #12]	; (60006a78 <CLOCK_GetOscFreq+0x18>)
60006a6c:	6818      	ldr	r0, [r3, #0]
60006a6e:	4770      	bx	lr
60006a70:	4802      	ldr	r0, [pc, #8]	; (60006a7c <CLOCK_GetOscFreq+0x1c>)
}
60006a72:	4770      	bx	lr
60006a74:	400d8000 	.word	0x400d8000
60006a78:	8000162c 	.word	0x8000162c
60006a7c:	016e3600 	.word	0x016e3600

60006a80 <CLOCK_InitEnetPll>:
 */
void CLOCK_InitEnetPll(const clock_enet_pll_config_t *config)
{
    uint32_t enet_pll = CCM_ANALOG_PLL_ENET_DIV_SELECT(config->loopDivider);

    CCM_ANALOG->PLL_ENET = (CCM_ANALOG->PLL_ENET & (~CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_MASK)) |
60006a80:	4918      	ldr	r1, [pc, #96]	; (60006ae4 <CLOCK_InitEnetPll+0x64>)
                           CCM_ANALOG_PLL_ENET_BYPASS_MASK | CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC(config->src);
60006a82:	7902      	ldrb	r2, [r0, #4]
    uint32_t enet_pll = CCM_ANALOG_PLL_ENET_DIV_SELECT(config->loopDivider);
60006a84:	78c3      	ldrb	r3, [r0, #3]
                           CCM_ANALOG_PLL_ENET_BYPASS_MASK | CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC(config->src);
60006a86:	0392      	lsls	r2, r2, #14
    uint32_t enet_pll = CCM_ANALOG_PLL_ENET_DIV_SELECT(config->loopDivider);
60006a88:	f003 0303 	and.w	r3, r3, #3
                           CCM_ANALOG_PLL_ENET_BYPASS_MASK | CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC(config->src);
60006a8c:	b292      	uxth	r2, r2
{
60006a8e:	b510      	push	{r4, lr}
    CCM_ANALOG->PLL_ENET = (CCM_ANALOG->PLL_ENET & (~CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_MASK)) |
60006a90:	f8d1 40e0 	ldr.w	r4, [r1, #224]	; 0xe0
60006a94:	f424 34e0 	bic.w	r4, r4, #114688	; 0x1c000
                           CCM_ANALOG_PLL_ENET_BYPASS_MASK | CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC(config->src);
60006a98:	4322      	orrs	r2, r4
60006a9a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    CCM_ANALOG->PLL_ENET = (CCM_ANALOG->PLL_ENET & (~CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_MASK)) |
60006a9e:	f8c1 20e0 	str.w	r2, [r1, #224]	; 0xe0

    if (config->enableClkOutput)
60006aa2:	7802      	ldrb	r2, [r0, #0]
60006aa4:	b10a      	cbz	r2, 60006aaa <CLOCK_InitEnetPll+0x2a>
    {
        enet_pll |= CCM_ANALOG_PLL_ENET_ENABLE_MASK;
60006aa6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    }

    if (config->enableClkOutput25M)
60006aaa:	7882      	ldrb	r2, [r0, #2]
60006aac:	b10a      	cbz	r2, 60006ab2 <CLOCK_InitEnetPll+0x32>
    {
        enet_pll |= CCM_ANALOG_PLL_ENET_ENET_25M_REF_EN_MASK;
60006aae:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    }

    if (config->enableClkOutput500M)
60006ab2:	7842      	ldrb	r2, [r0, #1]
60006ab4:	b10a      	cbz	r2, 60006aba <CLOCK_InitEnetPll+0x3a>
    {
        enet_pll |= CCM_ANALOG_PLL_ENET_ENET_500M_REF_EN_MASK;
60006ab6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    }

    CCM_ANALOG->PLL_ENET =
        (CCM_ANALOG->PLL_ENET & (~(CCM_ANALOG_PLL_ENET_DIV_SELECT_MASK | CCM_ANALOG_PLL_ENET_POWERDOWN_MASK))) |
60006aba:	f8d1 20e0 	ldr.w	r2, [r1, #224]	; 0xe0
60006abe:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
60006ac2:	f022 0203 	bic.w	r2, r2, #3
60006ac6:	431a      	orrs	r2, r3
        enet_pll;

    /* Wait for stable */
    while ((CCM_ANALOG->PLL_ENET & CCM_ANALOG_PLL_ENET_LOCK_MASK) == 0UL)
60006ac8:	4b06      	ldr	r3, [pc, #24]	; (60006ae4 <CLOCK_InitEnetPll+0x64>)
    CCM_ANALOG->PLL_ENET =
60006aca:	f8c1 20e0 	str.w	r2, [r1, #224]	; 0xe0
    while ((CCM_ANALOG->PLL_ENET & CCM_ANALOG_PLL_ENET_LOCK_MASK) == 0UL)
60006ace:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
60006ad2:	2a00      	cmp	r2, #0
60006ad4:	dafb      	bge.n	60006ace <CLOCK_InitEnetPll+0x4e>
    {
    }

    /* Disable Bypass */
    CCM_ANALOG->PLL_ENET &= ~CCM_ANALOG_PLL_ENET_BYPASS_MASK;
60006ad6:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
60006ada:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
60006ade:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
}
60006ae2:	bd10      	pop	{r4, pc}
60006ae4:	400d8000 	.word	0x400d8000

60006ae8 <CLOCK_GetPllFreq>:
 *         - true: The PLL is enabled.
 *         - false: The PLL is not enabled.
 */
static inline bool CLOCK_IsPllEnabled(CCM_ANALOG_Type *base, clock_pll_t pll)
{
    return (bool)(CCM_ANALOG_TUPLE_REG(base, pll) & (1UL << CCM_ANALOG_TUPLE_SHIFT(pll)));
60006ae8:	f3c0 410b 	ubfx	r1, r0, #16, #12
 *
 * param pll   pll name to get frequency.
 * return The PLL output frequency in hertz.
 */
uint32_t CLOCK_GetPllFreq(clock_pll_t pll)
{
60006aec:	4602      	mov	r2, r0
60006aee:	f000 001f 	and.w	r0, r0, #31
60006af2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
60006af6:	f501 2158 	add.w	r1, r1, #884736	; 0xd8000
60006afa:	b570      	push	{r4, r5, r6, lr}
60006afc:	680b      	ldr	r3, [r1, #0]
60006afe:	40c3      	lsrs	r3, r0
        100000000U, /* 100M */
        125000000U  /* 125M */
    };

    /* check if PLL is enabled */
    if (!CLOCK_IsPllEnabled(CCM_ANALOG, pll))
60006b00:	07d8      	lsls	r0, r3, #31
60006b02:	d519      	bpl.n	60006b38 <CLOCK_GetPllFreq+0x50>
 * @param pll PLL control name (see @ref ccm_analog_pll_control_t enumeration)
 * @retval bypass reference clock frequency value.
 */
static inline uint32_t CLOCK_GetPllBypassRefClk(CCM_ANALOG_Type *base, clock_pll_t pll)
{
    return ((((uint32_t)(CCM_ANALOG_TUPLE_REG(base, pll) & CCM_ANALOG_PLL_BYPASS_CLK_SRC_MASK)) >>
60006b04:	680b      	ldr	r3, [r1, #0]
             CCM_ANALOG_PLL_BYPASS_CLK_SRC_SHIFT) == (uint32_t)kCLOCK_PllClkSrc24M) ?
               CLOCK_GetOscFreq() :
60006b06:	f413 4f40 	tst.w	r3, #49152	; 0xc000
60006b0a:	d118      	bne.n	60006b3e <CLOCK_GetPllFreq+0x56>
60006b0c:	f7ff ffa8 	bl	60006a60 <CLOCK_GetOscFreq>
60006b10:	4604      	mov	r4, r0
    return (bool)(CCM_ANALOG_TUPLE_REG(base, pll) & (1UL << CCM_ANALOG_PLL_BYPASS_SHIFT));
60006b12:	680b      	ldr	r3, [r1, #0]

    /* get pll reference clock */
    freq = CLOCK_GetPllBypassRefClk(CCM_ANALOG, pll);

    /* check if pll is bypassed */
    if (CLOCK_IsPllBypassed(CCM_ANALOG, pll))
60006b14:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
60006b18:	d10f      	bne.n	60006b3a <CLOCK_GetPllFreq+0x52>
    {
        return freq;
    }

    switch (pll)
60006b1a:	4941      	ldr	r1, [pc, #260]	; (60006c20 <CLOCK_GetPllFreq+0x138>)
60006b1c:	428a      	cmp	r2, r1
60006b1e:	d074      	beq.n	60006c0a <CLOCK_GetPllFreq+0x122>
60006b20:	d80f      	bhi.n	60006b42 <CLOCK_GetPllFreq+0x5a>
60006b22:	f5a1 0130 	sub.w	r1, r1, #11534336	; 0xb00000
60006b26:	428a      	cmp	r2, r1
60006b28:	d013      	beq.n	60006b52 <CLOCK_GetPllFreq+0x6a>
60006b2a:	f501 0180 	add.w	r1, r1, #4194304	; 0x400000
60006b2e:	428a      	cmp	r2, r1
60006b30:	d027      	beq.n	60006b82 <CLOCK_GetPllFreq+0x9a>
60006b32:	4b3c      	ldr	r3, [pc, #240]	; (60006c24 <CLOCK_GetPllFreq+0x13c>)
60006b34:	429a      	cmp	r2, r3
60006b36:	d01b      	beq.n	60006b70 <CLOCK_GetPllFreq+0x88>

            freq += (uint32_t)freqTmp;
            break;

        case kCLOCK_PllUsb1:
            freq = (freq * (((CCM_ANALOG->PLL_USB1 & CCM_ANALOG_PLL_USB1_DIV_SELECT_MASK) != 0UL) ? 22U : 20U));
60006b38:	2400      	movs	r4, #0
            freq = 0U;
            break;
    }

    return freq;
}
60006b3a:	4620      	mov	r0, r4
60006b3c:	bd70      	pop	{r4, r5, r6, pc}
               CLOCK_GetOscFreq() :
60006b3e:	2400      	movs	r4, #0
60006b40:	e7e7      	b.n	60006b12 <CLOCK_GetPllFreq+0x2a>
    switch (pll)
60006b42:	4b39      	ldr	r3, [pc, #228]	; (60006c28 <CLOCK_GetPllFreq+0x140>)
60006b44:	429a      	cmp	r2, r3
60006b46:	d069      	beq.n	60006c1c <CLOCK_GetPllFreq+0x134>
60006b48:	3301      	adds	r3, #1
60006b4a:	429a      	cmp	r2, r3
60006b4c:	d1f4      	bne.n	60006b38 <CLOCK_GetPllFreq+0x50>
            freq = 500000000UL;
60006b4e:	4c37      	ldr	r4, [pc, #220]	; (60006c2c <CLOCK_GetPllFreq+0x144>)
60006b50:	e7f3      	b.n	60006b3a <CLOCK_GetPllFreq+0x52>
            freqTmp = ((clock_64b_t)freq * ((clock_64b_t)(CCM_ANALOG->PLL_SYS_NUM)));
60006b52:	4d37      	ldr	r5, [pc, #220]	; (60006c30 <CLOCK_GetPllFreq+0x148>)
60006b54:	6d28      	ldr	r0, [r5, #80]	; 0x50
            freqTmp /= ((clock_64b_t)(CCM_ANALOG->PLL_SYS_DENOM));
60006b56:	6e2a      	ldr	r2, [r5, #96]	; 0x60
60006b58:	fba4 0100 	umull	r0, r1, r4, r0
60006b5c:	f7fc ff8c 	bl	60003a78 <__aeabi_uldivmod>
            if ((CCM_ANALOG->PLL_SYS & CCM_ANALOG_PLL_SYS_DIV_SELECT_MASK) != 0UL)
60006b60:	6b2b      	ldr	r3, [r5, #48]	; 0x30
60006b62:	07db      	lsls	r3, r3, #31
                freq *= 22U;
60006b64:	bf4c      	ite	mi
60006b66:	2316      	movmi	r3, #22
                freq *= 20U;
60006b68:	2314      	movpl	r3, #20
60006b6a:	4363      	muls	r3, r4
            freq += (uint32_t)freqTmp;
60006b6c:	181c      	adds	r4, r3, r0
            break;
60006b6e:	e7e4      	b.n	60006b3a <CLOCK_GetPllFreq+0x52>
            freq = (freq * (((CCM_ANALOG->PLL_USB1 & CCM_ANALOG_PLL_USB1_DIV_SELECT_MASK) != 0UL) ? 22U : 20U));
60006b70:	4b2f      	ldr	r3, [pc, #188]	; (60006c30 <CLOCK_GetPllFreq+0x148>)
60006b72:	691b      	ldr	r3, [r3, #16]
60006b74:	f013 0f02 	tst.w	r3, #2
60006b78:	bf0c      	ite	eq
60006b7a:	2314      	moveq	r3, #20
60006b7c:	2316      	movne	r3, #22
60006b7e:	435c      	muls	r4, r3
            break;
60006b80:	e7db      	b.n	60006b3a <CLOCK_GetPllFreq+0x52>
                (CCM_ANALOG->PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_DIV_SELECT_MASK) >> CCM_ANALOG_PLL_AUDIO_DIV_SELECT_SHIFT;
60006b82:	4d2b      	ldr	r5, [pc, #172]	; (60006c30 <CLOCK_GetPllFreq+0x148>)
60006b84:	6f2e      	ldr	r6, [r5, #112]	; 0x70
            freqTmp = ((clock_64b_t)freq * ((clock_64b_t)(CCM_ANALOG->PLL_AUDIO_NUM)));
60006b86:	f8d5 0080 	ldr.w	r0, [r5, #128]	; 0x80
            freqTmp /= ((clock_64b_t)(CCM_ANALOG->PLL_AUDIO_DENOM));
60006b8a:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
            divSelect =
60006b8e:	f006 067f 	and.w	r6, r6, #127	; 0x7f
            freqTmp /= ((clock_64b_t)(CCM_ANALOG->PLL_AUDIO_DENOM));
60006b92:	fba4 0100 	umull	r0, r1, r4, r0
60006b96:	f7fc ff6f 	bl	60003a78 <__aeabi_uldivmod>
            switch (CCM_ANALOG->PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_MASK)
60006b9a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
            freq = freq * divSelect + (uint32_t)freqTmp;
60006b9c:	4366      	muls	r6, r4
            switch (CCM_ANALOG->PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_MASK)
60006b9e:	f403 13c0 	and.w	r3, r3, #1572864	; 0x180000
            freq = freq * divSelect + (uint32_t)freqTmp;
60006ba2:	1834      	adds	r4, r6, r0
            switch (CCM_ANALOG->PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_MASK)
60006ba4:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
60006ba8:	d01b      	beq.n	60006be2 <CLOCK_GetPllFreq+0xfa>
60006baa:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
60006bae:	d001      	beq.n	60006bb4 <CLOCK_GetPllFreq+0xcc>
60006bb0:	b9cb      	cbnz	r3, 60006be6 <CLOCK_GetPllFreq+0xfe>
                    freq = freq >> 2U;
60006bb2:	08a4      	lsrs	r4, r4, #2
            switch (CCM_ANALOG->MISC2 & (CCM_ANALOG_MISC2_AUDIO_DIV_MSB_MASK | CCM_ANALOG_MISC2_AUDIO_DIV_LSB_MASK))
60006bb4:	f8d5 3170 	ldr.w	r3, [r5, #368]	; 0x170
60006bb8:	4a1e      	ldr	r2, [pc, #120]	; (60006c34 <CLOCK_GetPllFreq+0x14c>)
60006bba:	4013      	ands	r3, r2
60006bbc:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
60006bc0:	d0bb      	beq.n	60006b3a <CLOCK_GetPllFreq+0x52>
60006bc2:	d81c      	bhi.n	60006bfe <CLOCK_GetPllFreq+0x116>
60006bc4:	2b00      	cmp	r3, #0
60006bc6:	d0b8      	beq.n	60006b3a <CLOCK_GetPllFreq+0x52>
60006bc8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
60006bcc:	d01b      	beq.n	60006c06 <CLOCK_GetPllFreq+0x11e>
                    assert(false);
60006bce:	491a      	ldr	r1, [pc, #104]	; (60006c38 <CLOCK_GetPllFreq+0x150>)
60006bd0:	f44f 7359 	mov.w	r3, #868	; 0x364
60006bd4:	4a19      	ldr	r2, [pc, #100]	; (60006c3c <CLOCK_GetPllFreq+0x154>)
60006bd6:	481a      	ldr	r0, [pc, #104]	; (60006c40 <CLOCK_GetPllFreq+0x158>)
60006bd8:	f003 ff72 	bl	6000aac0 <assert_print>
60006bdc:	f44f 7159 	mov.w	r1, #868	; 0x364
60006be0:	e00a      	b.n	60006bf8 <CLOCK_GetPllFreq+0x110>
                    freq = freq >> 1U;
60006be2:	0864      	lsrs	r4, r4, #1
                    break;
60006be4:	e7e6      	b.n	60006bb4 <CLOCK_GetPllFreq+0xcc>
                    assert(false);
60006be6:	4914      	ldr	r1, [pc, #80]	; (60006c38 <CLOCK_GetPllFreq+0x150>)
60006be8:	f44f 7354 	mov.w	r3, #848	; 0x350
60006bec:	4a13      	ldr	r2, [pc, #76]	; (60006c3c <CLOCK_GetPllFreq+0x154>)
60006bee:	4814      	ldr	r0, [pc, #80]	; (60006c40 <CLOCK_GetPllFreq+0x158>)
60006bf0:	f003 ff66 	bl	6000aac0 <assert_print>
60006bf4:	f44f 7154 	mov.w	r1, #848	; 0x350
                    assert(false);
60006bf8:	4810      	ldr	r0, [pc, #64]	; (60006c3c <CLOCK_GetPllFreq+0x154>)
60006bfa:	f003 ff5a 	bl	6000aab2 <assert_post_action>
60006bfe:	4293      	cmp	r3, r2
60006c00:	d1e5      	bne.n	60006bce <CLOCK_GetPllFreq+0xe6>
                    freq >>= 2U;
60006c02:	08a4      	lsrs	r4, r4, #2
                    break;
60006c04:	e799      	b.n	60006b3a <CLOCK_GetPllFreq+0x52>
                    freq >>= 1U;
60006c06:	0864      	lsrs	r4, r4, #1
                    break;
60006c08:	e797      	b.n	60006b3a <CLOCK_GetPllFreq+0x52>
                (CCM_ANALOG->PLL_ENET & CCM_ANALOG_PLL_ENET_DIV_SELECT_MASK) >> CCM_ANALOG_PLL_ENET_DIV_SELECT_SHIFT;
60006c0a:	4b09      	ldr	r3, [pc, #36]	; (60006c30 <CLOCK_GetPllFreq+0x148>)
            freq = enetRefClkFreq[divSelect];
60006c0c:	4a0d      	ldr	r2, [pc, #52]	; (60006c44 <CLOCK_GetPllFreq+0x15c>)
                (CCM_ANALOG->PLL_ENET & CCM_ANALOG_PLL_ENET_DIV_SELECT_MASK) >> CCM_ANALOG_PLL_ENET_DIV_SELECT_SHIFT;
60006c0e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
            divSelect =
60006c12:	f003 0303 	and.w	r3, r3, #3
            freq = enetRefClkFreq[divSelect];
60006c16:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
            break;
60006c1a:	e78e      	b.n	60006b3a <CLOCK_GetPllFreq+0x52>
            freq = 25000000UL;
60006c1c:	4c0a      	ldr	r4, [pc, #40]	; (60006c48 <CLOCK_GetPllFreq+0x160>)
60006c1e:	e78c      	b.n	60006b3a <CLOCK_GetPllFreq+0x52>
60006c20:	00e0000d 	.word	0x00e0000d
60006c24:	0010000d 	.word	0x0010000d
60006c28:	00e00015 	.word	0x00e00015
60006c2c:	1dcd6500 	.word	0x1dcd6500
60006c30:	400d8000 	.word	0x400d8000
60006c34:	00808000 	.word	0x00808000
60006c38:	6000d5b3 	.word	0x6000d5b3
60006c3c:	6000d673 	.word	0x6000d673
60006c40:	6000c68a 	.word	0x6000c68a
60006c44:	6000c4a4 	.word	0x6000c4a4
60006c48:	017d7840 	.word	0x017d7840

60006c4c <CLOCK_GetPllUsb1SWFreq>:
    switch ((CCM->CCSR & CCM_CCSR_PLL3_SW_CLK_SEL_MASK) >> CCM_CCSR_PLL3_SW_CLK_SEL_SHIFT)
60006c4c:	4b04      	ldr	r3, [pc, #16]	; (60006c60 <CLOCK_GetPllUsb1SWFreq+0x14>)
60006c4e:	68db      	ldr	r3, [r3, #12]
60006c50:	07db      	lsls	r3, r3, #31
60006c52:	d402      	bmi.n	60006c5a <CLOCK_GetPllUsb1SWFreq+0xe>
            freq = CLOCK_GetPllFreq(kCLOCK_PllUsb1);
60006c54:	4803      	ldr	r0, [pc, #12]	; (60006c64 <CLOCK_GetPllUsb1SWFreq+0x18>)
60006c56:	f7ff bf47 	b.w	60006ae8 <CLOCK_GetPllFreq>
}
60006c5a:	4803      	ldr	r0, [pc, #12]	; (60006c68 <CLOCK_GetPllUsb1SWFreq+0x1c>)
60006c5c:	4770      	bx	lr
60006c5e:	bf00      	nop
60006c60:	400fc000 	.word	0x400fc000
60006c64:	0010000d 	.word	0x0010000d
60006c68:	016e3600 	.word	0x016e3600

60006c6c <CLOCK_GetSysPfdFreq>:
 *
 * param pfd   pfd name to get frequency.
 * return The PFD output frequency in hertz.
 */
uint32_t CLOCK_GetSysPfdFreq(clock_pfd_t pfd)
{
60006c6c:	b510      	push	{r4, lr}
60006c6e:	4604      	mov	r4, r0
    uint32_t freq = CLOCK_GetPllFreq(kCLOCK_PllSys);
60006c70:	4813      	ldr	r0, [pc, #76]	; (60006cc0 <CLOCK_GetSysPfdFreq+0x54>)
60006c72:	f7ff ff39 	bl	60006ae8 <CLOCK_GetPllFreq>

    switch (pfd)
60006c76:	2c03      	cmp	r4, #3
60006c78:	d81f      	bhi.n	60006cba <CLOCK_GetSysPfdFreq+0x4e>
60006c7a:	e8df f004 	tbb	[pc, r4]
60006c7e:	0c02      	.short	0x0c02
60006c80:	1812      	.short	0x1812
    {
        case kCLOCK_Pfd0:
            freq /= ((CCM_ANALOG->PFD_528 & CCM_ANALOG_PFD_528_PFD0_FRAC_MASK) >> CCM_ANALOG_PFD_528_PFD0_FRAC_SHIFT);
60006c82:	4b10      	ldr	r3, [pc, #64]	; (60006cc4 <CLOCK_GetSysPfdFreq+0x58>)
60006c84:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
60006c88:	f003 033f 	and.w	r3, r3, #63	; 0x3f
        case kCLOCK_Pfd2:
            freq /= ((CCM_ANALOG->PFD_528 & CCM_ANALOG_PFD_528_PFD2_FRAC_MASK) >> CCM_ANALOG_PFD_528_PFD2_FRAC_SHIFT);
            break;

        case kCLOCK_Pfd3:
            freq /= ((CCM_ANALOG->PFD_528 & CCM_ANALOG_PFD_528_PFD3_FRAC_MASK) >> CCM_ANALOG_PFD_528_PFD3_FRAC_SHIFT);
60006c8c:	fbb0 f0f3 	udiv	r0, r0, r3
            break;
    }
    freq *= 18U;

    return freq;
}
60006c90:	2312      	movs	r3, #18
60006c92:	4358      	muls	r0, r3
60006c94:	bd10      	pop	{r4, pc}
            freq /= ((CCM_ANALOG->PFD_528 & CCM_ANALOG_PFD_528_PFD1_FRAC_MASK) >> CCM_ANALOG_PFD_528_PFD1_FRAC_SHIFT);
60006c96:	4b0b      	ldr	r3, [pc, #44]	; (60006cc4 <CLOCK_GetSysPfdFreq+0x58>)
60006c98:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
60006c9c:	f3c3 2305 	ubfx	r3, r3, #8, #6
60006ca0:	e7f4      	b.n	60006c8c <CLOCK_GetSysPfdFreq+0x20>
            freq /= ((CCM_ANALOG->PFD_528 & CCM_ANALOG_PFD_528_PFD2_FRAC_MASK) >> CCM_ANALOG_PFD_528_PFD2_FRAC_SHIFT);
60006ca2:	4b08      	ldr	r3, [pc, #32]	; (60006cc4 <CLOCK_GetSysPfdFreq+0x58>)
60006ca4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
60006ca8:	f3c3 4305 	ubfx	r3, r3, #16, #6
60006cac:	e7ee      	b.n	60006c8c <CLOCK_GetSysPfdFreq+0x20>
            freq /= ((CCM_ANALOG->PFD_528 & CCM_ANALOG_PFD_528_PFD3_FRAC_MASK) >> CCM_ANALOG_PFD_528_PFD3_FRAC_SHIFT);
60006cae:	4b05      	ldr	r3, [pc, #20]	; (60006cc4 <CLOCK_GetSysPfdFreq+0x58>)
60006cb0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
60006cb4:	f3c3 6305 	ubfx	r3, r3, #24, #6
60006cb8:	e7e8      	b.n	60006c8c <CLOCK_GetSysPfdFreq+0x20>
    switch (pfd)
60006cba:	2000      	movs	r0, #0
60006cbc:	e7e8      	b.n	60006c90 <CLOCK_GetSysPfdFreq+0x24>
60006cbe:	bf00      	nop
60006cc0:	0030000d 	.word	0x0030000d
60006cc4:	400d8000 	.word	0x400d8000

60006cc8 <CLOCK_GetUsb1PfdFreq>:
 *
 * param pfd   pfd name to get frequency.
 * return The PFD output frequency in hertz.
 */
uint32_t CLOCK_GetUsb1PfdFreq(clock_pfd_t pfd)
{
60006cc8:	b510      	push	{r4, lr}
60006cca:	4604      	mov	r4, r0
    uint32_t freq = CLOCK_GetPllFreq(kCLOCK_PllUsb1);
60006ccc:	4813      	ldr	r0, [pc, #76]	; (60006d1c <CLOCK_GetUsb1PfdFreq+0x54>)
60006cce:	f7ff ff0b 	bl	60006ae8 <CLOCK_GetPllFreq>

    switch (pfd)
60006cd2:	2c03      	cmp	r4, #3
60006cd4:	d81f      	bhi.n	60006d16 <CLOCK_GetUsb1PfdFreq+0x4e>
60006cd6:	e8df f004 	tbb	[pc, r4]
60006cda:	0c02      	.short	0x0c02
60006cdc:	1812      	.short	0x1812
    {
        case kCLOCK_Pfd0:
            freq /= ((CCM_ANALOG->PFD_480 & CCM_ANALOG_PFD_480_PFD0_FRAC_MASK) >> CCM_ANALOG_PFD_480_PFD0_FRAC_SHIFT);
60006cde:	4b10      	ldr	r3, [pc, #64]	; (60006d20 <CLOCK_GetUsb1PfdFreq+0x58>)
60006ce0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
60006ce4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
        case kCLOCK_Pfd2:
            freq /= ((CCM_ANALOG->PFD_480 & CCM_ANALOG_PFD_480_PFD2_FRAC_MASK) >> CCM_ANALOG_PFD_480_PFD2_FRAC_SHIFT);
            break;

        case kCLOCK_Pfd3:
            freq /= ((CCM_ANALOG->PFD_480 & CCM_ANALOG_PFD_480_PFD3_FRAC_MASK) >> CCM_ANALOG_PFD_480_PFD3_FRAC_SHIFT);
60006ce8:	fbb0 f0f3 	udiv	r0, r0, r3
            break;
    }
    freq *= 18U;

    return freq;
}
60006cec:	2312      	movs	r3, #18
60006cee:	4358      	muls	r0, r3
60006cf0:	bd10      	pop	{r4, pc}
            freq /= ((CCM_ANALOG->PFD_480 & CCM_ANALOG_PFD_480_PFD1_FRAC_MASK) >> CCM_ANALOG_PFD_480_PFD1_FRAC_SHIFT);
60006cf2:	4b0b      	ldr	r3, [pc, #44]	; (60006d20 <CLOCK_GetUsb1PfdFreq+0x58>)
60006cf4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
60006cf8:	f3c3 2305 	ubfx	r3, r3, #8, #6
60006cfc:	e7f4      	b.n	60006ce8 <CLOCK_GetUsb1PfdFreq+0x20>
            freq /= ((CCM_ANALOG->PFD_480 & CCM_ANALOG_PFD_480_PFD2_FRAC_MASK) >> CCM_ANALOG_PFD_480_PFD2_FRAC_SHIFT);
60006cfe:	4b08      	ldr	r3, [pc, #32]	; (60006d20 <CLOCK_GetUsb1PfdFreq+0x58>)
60006d00:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
60006d04:	f3c3 4305 	ubfx	r3, r3, #16, #6
60006d08:	e7ee      	b.n	60006ce8 <CLOCK_GetUsb1PfdFreq+0x20>
            freq /= ((CCM_ANALOG->PFD_480 & CCM_ANALOG_PFD_480_PFD3_FRAC_MASK) >> CCM_ANALOG_PFD_480_PFD3_FRAC_SHIFT);
60006d0a:	4b05      	ldr	r3, [pc, #20]	; (60006d20 <CLOCK_GetUsb1PfdFreq+0x58>)
60006d0c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
60006d10:	f3c3 6305 	ubfx	r3, r3, #24, #6
60006d14:	e7e8      	b.n	60006ce8 <CLOCK_GetUsb1PfdFreq+0x20>
    switch (pfd)
60006d16:	2000      	movs	r0, #0
60006d18:	e7e8      	b.n	60006cec <CLOCK_GetUsb1PfdFreq+0x24>
60006d1a:	bf00      	nop
60006d1c:	0010000d 	.word	0x0010000d
60006d20:	400d8000 	.word	0x400d8000

60006d24 <CLOCK_GetPeriphClkFreq>:
{
60006d24:	b508      	push	{r3, lr}
    if ((CCM->CBCDR & CCM_CBCDR_PERIPH_CLK_SEL_MASK) != 0UL)
60006d26:	4b20      	ldr	r3, [pc, #128]	; (60006da8 <CLOCK_GetPeriphClkFreq+0x84>)
60006d28:	6958      	ldr	r0, [r3, #20]
        switch (CCM->CBCMR & CCM_CBCMR_PERIPH_CLK2_SEL_MASK)
60006d2a:	699b      	ldr	r3, [r3, #24]
    if ((CCM->CBCDR & CCM_CBCDR_PERIPH_CLK_SEL_MASK) != 0UL)
60006d2c:	f010 7000 	ands.w	r0, r0, #33554432	; 0x2000000
60006d30:	d01a      	beq.n	60006d68 <CLOCK_GetPeriphClkFreq+0x44>
        switch (CCM->CBCMR & CCM_CBCMR_PERIPH_CLK2_SEL_MASK)
60006d32:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
60006d36:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
60006d3a:	d007      	beq.n	60006d4c <CLOCK_GetPeriphClkFreq+0x28>
60006d3c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
60006d40:	d00e      	beq.n	60006d60 <CLOCK_GetPeriphClkFreq+0x3c>
60006d42:	b97b      	cbnz	r3, 60006d64 <CLOCK_GetPeriphClkFreq+0x40>
                freq = CLOCK_GetPllFreq(kCLOCK_PllUsb1);
60006d44:	4819      	ldr	r0, [pc, #100]	; (60006dac <CLOCK_GetPeriphClkFreq+0x88>)
                freq = CLOCK_GetPllFreq(kCLOCK_PllSys);
60006d46:	f7ff fecf 	bl	60006ae8 <CLOCK_GetPllFreq>
                break;
60006d4a:	e001      	b.n	60006d50 <CLOCK_GetPeriphClkFreq+0x2c>
                freq = CLOCK_GetOscFreq();
60006d4c:	f7ff fe88 	bl	60006a60 <CLOCK_GetOscFreq>
        freq /= (((CCM->CBCDR & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) >> CCM_CBCDR_PERIPH_CLK2_PODF_SHIFT) + 1U);
60006d50:	4b15      	ldr	r3, [pc, #84]	; (60006da8 <CLOCK_GetPeriphClkFreq+0x84>)
60006d52:	695b      	ldr	r3, [r3, #20]
60006d54:	f3c3 63c2 	ubfx	r3, r3, #27, #3
60006d58:	3301      	adds	r3, #1
60006d5a:	fbb0 f0f3 	udiv	r0, r0, r3
}
60006d5e:	bd08      	pop	{r3, pc}
                freq = CLOCK_GetPllFreq(kCLOCK_PllSys);
60006d60:	4813      	ldr	r0, [pc, #76]	; (60006db0 <CLOCK_GetPeriphClkFreq+0x8c>)
60006d62:	e7f0      	b.n	60006d46 <CLOCK_GetPeriphClkFreq+0x22>
        switch (CCM->CBCMR & CCM_CBCMR_PERIPH_CLK2_SEL_MASK)
60006d64:	2000      	movs	r0, #0
60006d66:	e7f3      	b.n	60006d50 <CLOCK_GetPeriphClkFreq+0x2c>
        switch (CCM->CBCMR & CCM_CBCMR_PRE_PERIPH_CLK_SEL_MASK)
60006d68:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
60006d6c:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
60006d70:	d014      	beq.n	60006d9c <CLOCK_GetPeriphClkFreq+0x78>
60006d72:	d808      	bhi.n	60006d86 <CLOCK_GetPeriphClkFreq+0x62>
60006d74:	b16b      	cbz	r3, 60006d92 <CLOCK_GetPeriphClkFreq+0x6e>
60006d76:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
60006d7a:	d1f0      	bne.n	60006d5e <CLOCK_GetPeriphClkFreq+0x3a>
                freq = CLOCK_GetUsb1PfdFreq(kCLOCK_Pfd3);
60006d7c:	2003      	movs	r0, #3
}
60006d7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
                freq = CLOCK_GetUsb1PfdFreq(kCLOCK_Pfd3);
60006d82:	f7ff bfa1 	b.w	60006cc8 <CLOCK_GetUsb1PfdFreq>
                freq = 500000000U;
60006d86:	4a0b      	ldr	r2, [pc, #44]	; (60006db4 <CLOCK_GetPeriphClkFreq+0x90>)
60006d88:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
60006d8c:	bf08      	it	eq
60006d8e:	4610      	moveq	r0, r2
60006d90:	e7e5      	b.n	60006d5e <CLOCK_GetPeriphClkFreq+0x3a>
                freq = CLOCK_GetPllFreq(kCLOCK_PllSys);
60006d92:	4807      	ldr	r0, [pc, #28]	; (60006db0 <CLOCK_GetPeriphClkFreq+0x8c>)
}
60006d94:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
                freq = CLOCK_GetPllFreq(kCLOCK_PllSys);
60006d98:	f7ff bea6 	b.w	60006ae8 <CLOCK_GetPllFreq>
                freq = CLOCK_GetSysPfdFreq(kCLOCK_Pfd3);
60006d9c:	2003      	movs	r0, #3
}
60006d9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
                freq = CLOCK_GetSysPfdFreq(kCLOCK_Pfd3);
60006da2:	f7ff bf63 	b.w	60006c6c <CLOCK_GetSysPfdFreq>
60006da6:	bf00      	nop
60006da8:	400fc000 	.word	0x400fc000
60006dac:	0010000d 	.word	0x0010000d
60006db0:	0030000d 	.word	0x0030000d
60006db4:	1dcd6500 	.word	0x1dcd6500

60006db8 <CLOCK_GetAhbFreq>:
{
60006db8:	b508      	push	{r3, lr}
    return CLOCK_GetPeriphClkFreq() / (((CCM->CBCDR & CCM_CBCDR_AHB_PODF_MASK) >> CCM_CBCDR_AHB_PODF_SHIFT) + 1U);
60006dba:	f7ff ffb3 	bl	60006d24 <CLOCK_GetPeriphClkFreq>
60006dbe:	4b04      	ldr	r3, [pc, #16]	; (60006dd0 <CLOCK_GetAhbFreq+0x18>)
60006dc0:	695b      	ldr	r3, [r3, #20]
60006dc2:	f3c3 2382 	ubfx	r3, r3, #10, #3
60006dc6:	3301      	adds	r3, #1
}
60006dc8:	fbb0 f0f3 	udiv	r0, r0, r3
60006dcc:	bd08      	pop	{r3, pc}
60006dce:	bf00      	nop
60006dd0:	400fc000 	.word	0x400fc000

60006dd4 <CLOCK_GetIpgFreq>:
{
60006dd4:	b508      	push	{r3, lr}
    return CLOCK_GetAhbFreq() / (((CCM->CBCDR & CCM_CBCDR_IPG_PODF_MASK) >> CCM_CBCDR_IPG_PODF_SHIFT) + 1U);
60006dd6:	f7ff ffef 	bl	60006db8 <CLOCK_GetAhbFreq>
60006dda:	4b04      	ldr	r3, [pc, #16]	; (60006dec <CLOCK_GetIpgFreq+0x18>)
60006ddc:	695b      	ldr	r3, [r3, #20]
60006dde:	f3c3 2301 	ubfx	r3, r3, #8, #2
60006de2:	3301      	adds	r3, #1
}
60006de4:	fbb0 f0f3 	udiv	r0, r0, r3
60006de8:	bd08      	pop	{r3, pc}
60006dea:	bf00      	nop
60006dec:	400fc000 	.word	0x400fc000

60006df0 <CLOCK_GetPerClkFreq>:
{
60006df0:	b510      	push	{r4, lr}
    if ((CCM->CSCMR1 & CCM_CSCMR1_PERCLK_CLK_SEL_MASK) != 0UL)
60006df2:	4c08      	ldr	r4, [pc, #32]	; (60006e14 <CLOCK_GetPerClkFreq+0x24>)
60006df4:	69e3      	ldr	r3, [r4, #28]
60006df6:	065b      	lsls	r3, r3, #25
60006df8:	d508      	bpl.n	60006e0c <CLOCK_GetPerClkFreq+0x1c>
        freq = CLOCK_GetOscFreq();
60006dfa:	f7ff fe31 	bl	60006a60 <CLOCK_GetOscFreq>
    freq /= (((CCM->CSCMR1 & CCM_CSCMR1_PERCLK_PODF_MASK) >> CCM_CSCMR1_PERCLK_PODF_SHIFT) + 1U);
60006dfe:	69e3      	ldr	r3, [r4, #28]
60006e00:	f003 033f 	and.w	r3, r3, #63	; 0x3f
60006e04:	3301      	adds	r3, #1
}
60006e06:	fbb0 f0f3 	udiv	r0, r0, r3
60006e0a:	bd10      	pop	{r4, pc}
        freq = CLOCK_GetIpgFreq();
60006e0c:	f7ff ffe2 	bl	60006dd4 <CLOCK_GetIpgFreq>
60006e10:	e7f5      	b.n	60006dfe <CLOCK_GetPerClkFreq+0xe>
60006e12:	bf00      	nop
60006e14:	400fc000 	.word	0x400fc000

60006e18 <CLOCK_GetSemcFreq>:
{
60006e18:	b510      	push	{r4, lr}
    if ((CCM->CBCDR & CCM_CBCDR_SEMC_CLK_SEL_MASK) != 0UL)
60006e1a:	4c0c      	ldr	r4, [pc, #48]	; (60006e4c <CLOCK_GetSemcFreq+0x34>)
60006e1c:	6963      	ldr	r3, [r4, #20]
60006e1e:	065a      	lsls	r2, r3, #25
60006e20:	d510      	bpl.n	60006e44 <CLOCK_GetSemcFreq+0x2c>
        if ((CCM->CBCDR & CCM_CBCDR_SEMC_ALT_CLK_SEL_MASK) != 0UL)
60006e22:	6963      	ldr	r3, [r4, #20]
60006e24:	061b      	lsls	r3, r3, #24
60006e26:	d509      	bpl.n	60006e3c <CLOCK_GetSemcFreq+0x24>
            freq = CLOCK_GetUsb1PfdFreq(kCLOCK_Pfd1);
60006e28:	2001      	movs	r0, #1
60006e2a:	f7ff ff4d 	bl	60006cc8 <CLOCK_GetUsb1PfdFreq>
    freq /= (((CCM->CBCDR & CCM_CBCDR_SEMC_PODF_MASK) >> CCM_CBCDR_SEMC_PODF_SHIFT) + 1U);
60006e2e:	6963      	ldr	r3, [r4, #20]
60006e30:	f3c3 4302 	ubfx	r3, r3, #16, #3
60006e34:	3301      	adds	r3, #1
}
60006e36:	fbb0 f0f3 	udiv	r0, r0, r3
60006e3a:	bd10      	pop	{r4, pc}
            freq = CLOCK_GetSysPfdFreq(kCLOCK_Pfd2);
60006e3c:	2002      	movs	r0, #2
60006e3e:	f7ff ff15 	bl	60006c6c <CLOCK_GetSysPfdFreq>
60006e42:	e7f4      	b.n	60006e2e <CLOCK_GetSemcFreq+0x16>
        freq = CLOCK_GetPeriphClkFreq();
60006e44:	f7ff ff6e 	bl	60006d24 <CLOCK_GetPeriphClkFreq>
60006e48:	e7f1      	b.n	60006e2e <CLOCK_GetSemcFreq+0x16>
60006e4a:	bf00      	nop
60006e4c:	400fc000 	.word	0x400fc000

60006e50 <CLOCK_GetFreq>:
{
60006e50:	b508      	push	{r3, lr}
    switch (name)
60006e52:	281b      	cmp	r0, #27
60006e54:	d859      	bhi.n	60006f0a <CLOCK_GetFreq+0xba>
60006e56:	e8df f000 	tbb	[pc, r0]
60006e5a:	1111      	.short	0x1111
60006e5c:	211d1915 	.word	0x211d1915
60006e60:	2f2a250e 	.word	0x2f2a250e
60006e64:	45433331 	.word	0x45433331
60006e68:	504e4c4a 	.word	0x504e4c4a
60006e6c:	35565452 	.word	0x35565452
60006e70:	58585839 	.word	0x58585839
60006e74:	3d58      	.short	0x3d58
            freq = CLOCK_GetRtcFreq();
60006e76:	f44f 4000 	mov.w	r0, #32768	; 0x8000
}
60006e7a:	bd08      	pop	{r3, pc}
60006e7c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetAhbFreq();
60006e80:	f7ff bf9a 	b.w	60006db8 <CLOCK_GetAhbFreq>
}
60006e84:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetSemcFreq();
60006e88:	f7ff bfc6 	b.w	60006e18 <CLOCK_GetSemcFreq>
}
60006e8c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetIpgFreq();
60006e90:	f7ff bfa0 	b.w	60006dd4 <CLOCK_GetIpgFreq>
}
60006e94:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetPerClkFreq();
60006e98:	f7ff bfaa 	b.w	60006df0 <CLOCK_GetPerClkFreq>
}
60006e9c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetOscFreq();
60006ea0:	f7ff bdde 	b.w	60006a60 <CLOCK_GetOscFreq>
            freq = CLOCK_GetPllFreq(kCLOCK_PllUsb1);
60006ea4:	481a      	ldr	r0, [pc, #104]	; (60006f10 <CLOCK_GetFreq+0xc0>)
}
60006ea6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetPllFreq(kCLOCK_PllAudio);
60006eaa:	f7ff be1d 	b.w	60006ae8 <CLOCK_GetPllFreq>
            freq = CLOCK_GetUsb1PfdFreq(kCLOCK_Pfd0);
60006eae:	2000      	movs	r0, #0
}
60006eb0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetUsb1PfdFreq(kCLOCK_Pfd1);
60006eb4:	f7ff bf08 	b.w	60006cc8 <CLOCK_GetUsb1PfdFreq>
60006eb8:	2001      	movs	r0, #1
60006eba:	e7f9      	b.n	60006eb0 <CLOCK_GetFreq+0x60>
            freq = CLOCK_GetUsb1PfdFreq(kCLOCK_Pfd2);
60006ebc:	2002      	movs	r0, #2
60006ebe:	e7f7      	b.n	60006eb0 <CLOCK_GetFreq+0x60>
            freq = CLOCK_GetUsb1PfdFreq(kCLOCK_Pfd3);
60006ec0:	2003      	movs	r0, #3
60006ec2:	e7f5      	b.n	60006eb0 <CLOCK_GetFreq+0x60>
}
60006ec4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetPllUsb1SWFreq();
60006ec8:	f7ff bec0 	b.w	60006c4c <CLOCK_GetPllUsb1SWFreq>
            freq = CLOCK_GetPllUsb1SWFreq() / 8UL;
60006ecc:	f7ff febe 	bl	60006c4c <CLOCK_GetPllUsb1SWFreq>
60006ed0:	08c0      	lsrs	r0, r0, #3
            break;
60006ed2:	e7d2      	b.n	60006e7a <CLOCK_GetFreq+0x2a>
            freq = CLOCK_GetPllUsb1SWFreq() / 6UL;
60006ed4:	f7ff feba 	bl	60006c4c <CLOCK_GetPllUsb1SWFreq>
60006ed8:	2306      	movs	r3, #6
60006eda:	fbb0 f0f3 	udiv	r0, r0, r3
            break;
60006ede:	e7cc      	b.n	60006e7a <CLOCK_GetFreq+0x2a>
            freq = CLOCK_GetPllFreq(kCLOCK_PllSys);
60006ee0:	480c      	ldr	r0, [pc, #48]	; (60006f14 <CLOCK_GetFreq+0xc4>)
60006ee2:	e7e0      	b.n	60006ea6 <CLOCK_GetFreq+0x56>
            freq = CLOCK_GetSysPfdFreq(kCLOCK_Pfd0);
60006ee4:	2000      	movs	r0, #0
}
60006ee6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetSysPfdFreq(kCLOCK_Pfd3);
60006eea:	f7ff bebf 	b.w	60006c6c <CLOCK_GetSysPfdFreq>
            freq = CLOCK_GetSysPfdFreq(kCLOCK_Pfd1);
60006eee:	2001      	movs	r0, #1
60006ef0:	e7f9      	b.n	60006ee6 <CLOCK_GetFreq+0x96>
            freq = CLOCK_GetSysPfdFreq(kCLOCK_Pfd2);
60006ef2:	2002      	movs	r0, #2
60006ef4:	e7f7      	b.n	60006ee6 <CLOCK_GetFreq+0x96>
            freq = CLOCK_GetSysPfdFreq(kCLOCK_Pfd3);
60006ef6:	2003      	movs	r0, #3
60006ef8:	e7f5      	b.n	60006ee6 <CLOCK_GetFreq+0x96>
            freq = CLOCK_GetPllFreq(kCLOCK_PllEnet);
60006efa:	4807      	ldr	r0, [pc, #28]	; (60006f18 <CLOCK_GetFreq+0xc8>)
60006efc:	e7d3      	b.n	60006ea6 <CLOCK_GetFreq+0x56>
            freq = CLOCK_GetPllFreq(kCLOCK_PllEnet25M);
60006efe:	4807      	ldr	r0, [pc, #28]	; (60006f1c <CLOCK_GetFreq+0xcc>)
60006f00:	e7d1      	b.n	60006ea6 <CLOCK_GetFreq+0x56>
            freq = CLOCK_GetPllFreq(kCLOCK_PllEnet500M);
60006f02:	4807      	ldr	r0, [pc, #28]	; (60006f20 <CLOCK_GetFreq+0xd0>)
60006f04:	e7cf      	b.n	60006ea6 <CLOCK_GetFreq+0x56>
            freq = CLOCK_GetPllFreq(kCLOCK_PllAudio);
60006f06:	4807      	ldr	r0, [pc, #28]	; (60006f24 <CLOCK_GetFreq+0xd4>)
60006f08:	e7cd      	b.n	60006ea6 <CLOCK_GetFreq+0x56>
    switch (name)
60006f0a:	2000      	movs	r0, #0
    return freq;
60006f0c:	e7b5      	b.n	60006e7a <CLOCK_GetFreq+0x2a>
60006f0e:	bf00      	nop
60006f10:	0010000d 	.word	0x0010000d
60006f14:	0030000d 	.word	0x0030000d
60006f18:	00e0000d 	.word	0x00e0000d
60006f1c:	00e00015 	.word	0x00e00015
60006f20:	00e00016 	.word	0x00e00016
60006f24:	0070000d 	.word	0x0070000d

60006f28 <SystemInit>:
    extern uint32_t g_pfnVectors[];  // Vector table defined in startup code
    SCB->VTOR = (uint32_t)g_pfnVectors;
#endif

/* Disable Watchdog Power Down Counter */
    WDOG1->WMCR &= ~(uint16_t) WDOG_WMCR_PDE_MASK;
60006f28:	492d      	ldr	r1, [pc, #180]	; (60006fe0 <SystemInit+0xb8>)
    WDOG2->WMCR &= ~(uint16_t) WDOG_WMCR_PDE_MASK;
60006f2a:	4a2e      	ldr	r2, [pc, #184]	; (60006fe4 <SystemInit+0xbc>)
void SystemInit (void) {
60006f2c:	b508      	push	{r3, lr}
    WDOG1->WMCR &= ~(uint16_t) WDOG_WMCR_PDE_MASK;
60006f2e:	890b      	ldrh	r3, [r1, #8]
60006f30:	f023 0301 	bic.w	r3, r3, #1
60006f34:	041b      	lsls	r3, r3, #16
60006f36:	0c1b      	lsrs	r3, r3, #16
60006f38:	810b      	strh	r3, [r1, #8]
    WDOG2->WMCR &= ~(uint16_t) WDOG_WMCR_PDE_MASK;
60006f3a:	8913      	ldrh	r3, [r2, #8]
60006f3c:	f023 0301 	bic.w	r3, r3, #1
60006f40:	041b      	lsls	r3, r3, #16
60006f42:	0c1b      	lsrs	r3, r3, #16
60006f44:	8113      	strh	r3, [r2, #8]

/* Watchdog disable */

#if (DISABLE_WDOG)
    if ((WDOG1->WCR & WDOG_WCR_WDE_MASK) != 0U)
60006f46:	880b      	ldrh	r3, [r1, #0]
60006f48:	0758      	lsls	r0, r3, #29
60006f4a:	d505      	bpl.n	60006f58 <SystemInit+0x30>
    {
        WDOG1->WCR &= ~(uint16_t) WDOG_WCR_WDE_MASK;
60006f4c:	880b      	ldrh	r3, [r1, #0]
60006f4e:	f023 0304 	bic.w	r3, r3, #4
60006f52:	041b      	lsls	r3, r3, #16
60006f54:	0c1b      	lsrs	r3, r3, #16
60006f56:	800b      	strh	r3, [r1, #0]
    }
    if ((WDOG2->WCR & WDOG_WCR_WDE_MASK) != 0U)
60006f58:	8813      	ldrh	r3, [r2, #0]
60006f5a:	075b      	lsls	r3, r3, #29
60006f5c:	d505      	bpl.n	60006f6a <SystemInit+0x42>
    {
        WDOG2->WCR &= ~(uint16_t) WDOG_WCR_WDE_MASK;
60006f5e:	8813      	ldrh	r3, [r2, #0]
60006f60:	f023 0304 	bic.w	r3, r3, #4
60006f64:	041b      	lsls	r3, r3, #16
60006f66:	0c1b      	lsrs	r3, r3, #16
60006f68:	8013      	strh	r3, [r2, #0]
    }
    if ((RTWDOG->CS & RTWDOG_CS_CMD32EN_MASK) != 0U)
60006f6a:	4b1f      	ldr	r3, [pc, #124]	; (60006fe8 <SystemInit+0xc0>)
60006f6c:	681a      	ldr	r2, [r3, #0]
60006f6e:	0490      	lsls	r0, r2, #18
60006f70:	d530      	bpl.n	60006fd4 <SystemInit+0xac>
    {
        RTWDOG->CNT = 0xD928C520U; /* 0xD928C520U is the update key */
60006f72:	4a1e      	ldr	r2, [pc, #120]	; (60006fec <SystemInit+0xc4>)
    }
    else
    {
        RTWDOG->CNT = 0xC520U;
        RTWDOG->CNT = 0xD928U;
60006f74:	605a      	str	r2, [r3, #4]
    }
    RTWDOG->TOVAL = 0xFFFF;
60006f76:	f64f 72ff 	movw	r2, #65535	; 0xffff
60006f7a:	609a      	str	r2, [r3, #8]
    RTWDOG->CS = (uint32_t) ((RTWDOG->CS) & ~RTWDOG_CS_EN_MASK) | RTWDOG_CS_UPDATE_MASK;
60006f7c:	681a      	ldr	r2, [r3, #0]
60006f7e:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
60006f82:	f042 0220 	orr.w	r2, r2, #32
60006f86:	601a      	str	r2, [r3, #0]
#endif /* (DISABLE_WDOG) */

    /* Disable Systick which might be enabled by bootrom */
    if ((SysTick->CTRL & SysTick_CTRL_ENABLE_Msk) != 0U)
60006f88:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
60006f8c:	691a      	ldr	r2, [r3, #16]
60006f8e:	07d1      	lsls	r1, r2, #31
60006f90:	d503      	bpl.n	60006f9a <SystemInit+0x72>
    {
        SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
60006f92:	691a      	ldr	r2, [r3, #16]
60006f94:	f022 0201 	bic.w	r2, r2, #1
60006f98:	611a      	str	r2, [r3, #16]
    }

/* Enable instruction and data caches */
#if defined(__ICACHE_PRESENT) && __ICACHE_PRESENT
    if (SCB_CCR_IC_Msk != (SCB_CCR_IC_Msk & SCB->CCR)) {
60006f9a:	4b15      	ldr	r3, [pc, #84]	; (60006ff0 <SystemInit+0xc8>)
60006f9c:	695a      	ldr	r2, [r3, #20]
60006f9e:	0392      	lsls	r2, r2, #14
60006fa0:	d415      	bmi.n	60006fce <SystemInit+0xa6>
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
60006fa2:	695a      	ldr	r2, [r3, #20]
60006fa4:	f412 3200 	ands.w	r2, r2, #131072	; 0x20000
60006fa8:	d111      	bne.n	60006fce <SystemInit+0xa6>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
60006faa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60006fae:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
60006fb2:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
60006fb6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60006fba:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
60006fbe:	695a      	ldr	r2, [r3, #20]
60006fc0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
60006fc4:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
60006fc6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60006fca:	f3bf 8f6f 	isb	sy
        SCB_EnableICache();
    }
#endif

  SystemInitHook();
60006fce:	f004 fa2e 	bl	6000b42e <SystemInitHook>
}
60006fd2:	bd08      	pop	{r3, pc}
        RTWDOG->CNT = 0xC520U;
60006fd4:	f24c 5220 	movw	r2, #50464	; 0xc520
60006fd8:	605a      	str	r2, [r3, #4]
        RTWDOG->CNT = 0xD928U;
60006fda:	f64d 1228 	movw	r2, #55592	; 0xd928
60006fde:	e7c9      	b.n	60006f74 <SystemInit+0x4c>
60006fe0:	400b8000 	.word	0x400b8000
60006fe4:	400d0000 	.word	0x400d0000
60006fe8:	400bc000 	.word	0x400bc000
60006fec:	d928c520 	.word	0xd928c520
60006ff0:	e000ed00 	.word	0xe000ed00

60006ff4 <EDMA_GetInstance>:
/*******************************************************************************
 * Code
 ******************************************************************************/

static uint32_t EDMA_GetInstance(DMA_Type *base)
{
60006ff4:	b508      	push	{r3, lr}
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < ARRAY_SIZE(s_edmaBases); instance++)
    {
        if (s_edmaBases[instance] == base)
60006ff6:	4b07      	ldr	r3, [pc, #28]	; (60007014 <EDMA_GetInstance+0x20>)
60006ff8:	4298      	cmp	r0, r3
60006ffa:	d009      	beq.n	60007010 <EDMA_GetInstance+0x1c>
        {
            break;
        }
    }

    assert(instance < ARRAY_SIZE(s_edmaBases));
60006ffc:	4906      	ldr	r1, [pc, #24]	; (60007018 <EDMA_GetInstance+0x24>)
60006ffe:	234c      	movs	r3, #76	; 0x4c
60007000:	4806      	ldr	r0, [pc, #24]	; (6000701c <EDMA_GetInstance+0x28>)
60007002:	4a07      	ldr	r2, [pc, #28]	; (60007020 <EDMA_GetInstance+0x2c>)
60007004:	f003 fd5c 	bl	6000aac0 <assert_print>
60007008:	214c      	movs	r1, #76	; 0x4c
6000700a:	4805      	ldr	r0, [pc, #20]	; (60007020 <EDMA_GetInstance+0x2c>)
6000700c:	f003 fd51 	bl	6000aab2 <assert_post_action>

    return instance;
}
60007010:	2000      	movs	r0, #0
60007012:	bd08      	pop	{r3, pc}
60007014:	400e8000 	.word	0x400e8000
60007018:	6000d715 	.word	0x6000d715
6000701c:	6000c68a 	.word	0x6000c68a
60007020:	6000d6d3 	.word	0x6000d6d3

60007024 <EDMA_TransferWidthMapping>:
static edma_transfer_size_t EDMA_TransferWidthMapping(uint32_t width)
{
    edma_transfer_size_t transferSize = kEDMA_TransferSize1Bytes;

    /* map width to register value */
    switch (width)
60007024:	2808      	cmp	r0, #8
{
60007026:	b508      	push	{r3, lr}
    switch (width)
60007028:	d80b      	bhi.n	60007042 <EDMA_TransferWidthMapping+0x1e>
6000702a:	b160      	cbz	r0, 60007046 <EDMA_TransferWidthMapping+0x22>
6000702c:	3801      	subs	r0, #1
6000702e:	2807      	cmp	r0, #7
60007030:	d809      	bhi.n	60007046 <EDMA_TransferWidthMapping+0x22>
60007032:	e8df f000 	tbb	[pc, r0]
60007036:	1816      	.short	0x1816
60007038:	08080408 	.word	0x08080408
6000703c:	1408      	.short	0x1408
        case 2U:
            transferSize = kEDMA_TransferSize2Bytes;
            break;
        /* width 32bit */
        case 4U:
            transferSize = kEDMA_TransferSize4Bytes;
6000703e:	2002      	movs	r0, #2
            assert(false);
            break;
    }

    return transferSize;
}
60007040:	bd08      	pop	{r3, pc}
    switch (width)
60007042:	2820      	cmp	r0, #32
60007044:	d011      	beq.n	6000706a <EDMA_TransferWidthMapping+0x46>
            assert(false);
60007046:	490a      	ldr	r1, [pc, #40]	; (60007070 <EDMA_TransferWidthMapping+0x4c>)
60007048:	f240 33cd 	movw	r3, #973	; 0x3cd
6000704c:	4809      	ldr	r0, [pc, #36]	; (60007074 <EDMA_TransferWidthMapping+0x50>)
6000704e:	4a0a      	ldr	r2, [pc, #40]	; (60007078 <EDMA_TransferWidthMapping+0x54>)
60007050:	f003 fd36 	bl	6000aac0 <assert_print>
60007054:	f240 31cd 	movw	r1, #973	; 0x3cd
60007058:	4807      	ldr	r0, [pc, #28]	; (60007078 <EDMA_TransferWidthMapping+0x54>)
6000705a:	f003 fd2a 	bl	6000aab2 <assert_post_action>
            transferSize = kEDMA_TransferSize8Bytes;
6000705e:	2003      	movs	r0, #3
            break;
60007060:	e7ee      	b.n	60007040 <EDMA_TransferWidthMapping+0x1c>
            transferSize = kEDMA_TransferSize1Bytes;
60007062:	2000      	movs	r0, #0
60007064:	e7ec      	b.n	60007040 <EDMA_TransferWidthMapping+0x1c>
    switch (width)
60007066:	2001      	movs	r0, #1
60007068:	e7ea      	b.n	60007040 <EDMA_TransferWidthMapping+0x1c>
            transferSize = kEDMA_TransferSize32Bytes;
6000706a:	2005      	movs	r0, #5
6000706c:	e7e8      	b.n	60007040 <EDMA_TransferWidthMapping+0x1c>
6000706e:	bf00      	nop
60007070:	6000d5b3 	.word	0x6000d5b3
60007074:	6000c68a 	.word	0x6000c68a
60007078:	6000d6d3 	.word	0x6000d6d3

6000707c <EDMA_InstallTCD>:
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
6000707c:	291f      	cmp	r1, #31
{
6000707e:	b538      	push	{r3, r4, r5, lr}
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
60007080:	d909      	bls.n	60007096 <EDMA_InstallTCD+0x1a>
60007082:	4928      	ldr	r1, [pc, #160]	; (60007124 <EDMA_InstallTCD+0xa8>)
60007084:	235a      	movs	r3, #90	; 0x5a
60007086:	4a28      	ldr	r2, [pc, #160]	; (60007128 <EDMA_InstallTCD+0xac>)
60007088:	4828      	ldr	r0, [pc, #160]	; (6000712c <EDMA_InstallTCD+0xb0>)
6000708a:	f003 fd19 	bl	6000aac0 <assert_print>
6000708e:	215a      	movs	r1, #90	; 0x5a
    assert(tcd != NULL);
60007090:	4825      	ldr	r0, [pc, #148]	; (60007128 <EDMA_InstallTCD+0xac>)
60007092:	f003 fd0e 	bl	6000aab2 <assert_post_action>
60007096:	b93a      	cbnz	r2, 600070a8 <EDMA_InstallTCD+0x2c>
60007098:	4925      	ldr	r1, [pc, #148]	; (60007130 <EDMA_InstallTCD+0xb4>)
6000709a:	235b      	movs	r3, #91	; 0x5b
6000709c:	4a22      	ldr	r2, [pc, #136]	; (60007128 <EDMA_InstallTCD+0xac>)
6000709e:	4823      	ldr	r0, [pc, #140]	; (6000712c <EDMA_InstallTCD+0xb0>)
600070a0:	f003 fd0e 	bl	6000aac0 <assert_print>
600070a4:	215b      	movs	r1, #91	; 0x5b
600070a6:	e7f3      	b.n	60007090 <EDMA_InstallTCD+0x14>
    assert(((uint32_t)tcd & 0x1FU) == 0U);
600070a8:	f012 041f 	ands.w	r4, r2, #31
600070ac:	d007      	beq.n	600070be <EDMA_InstallTCD+0x42>
600070ae:	4921      	ldr	r1, [pc, #132]	; (60007134 <EDMA_InstallTCD+0xb8>)
600070b0:	235c      	movs	r3, #92	; 0x5c
600070b2:	4a1d      	ldr	r2, [pc, #116]	; (60007128 <EDMA_InstallTCD+0xac>)
600070b4:	481d      	ldr	r0, [pc, #116]	; (6000712c <EDMA_InstallTCD+0xb0>)
600070b6:	f003 fd03 	bl	6000aac0 <assert_print>
600070ba:	215c      	movs	r1, #92	; 0x5c
600070bc:	e7e8      	b.n	60007090 <EDMA_InstallTCD+0x14>
    base->TCD[channel].SADDR         = tcd->SADDR;
600070be:	eb00 1041 	add.w	r0, r0, r1, lsl #5
600070c2:	6815      	ldr	r5, [r2, #0]
600070c4:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
600070c8:	601d      	str	r5, [r3, #0]
    base->TCD[channel].SOFF          = tcd->SOFF;
600070ca:	8891      	ldrh	r1, [r2, #4]
600070cc:	b289      	uxth	r1, r1
600070ce:	8099      	strh	r1, [r3, #4]
    base->TCD[channel].ATTR          = tcd->ATTR;
600070d0:	88d1      	ldrh	r1, [r2, #6]
600070d2:	b289      	uxth	r1, r1
600070d4:	80d9      	strh	r1, [r3, #6]
    base->TCD[channel].NBYTES_MLNO   = tcd->NBYTES;
600070d6:	f241 0308 	movw	r3, #4104	; 0x1008
600070da:	6891      	ldr	r1, [r2, #8]
600070dc:	50c1      	str	r1, [r0, r3]
    base->TCD[channel].SLAST         = (int32_t)tcd->SLAST;
600070de:	f241 030c 	movw	r3, #4108	; 0x100c
600070e2:	68d1      	ldr	r1, [r2, #12]
600070e4:	50c1      	str	r1, [r0, r3]
    base->TCD[channel].DADDR         = tcd->DADDR;
600070e6:	f241 0310 	movw	r3, #4112	; 0x1010
600070ea:	6911      	ldr	r1, [r2, #16]
600070ec:	50c1      	str	r1, [r0, r3]
    base->TCD[channel].DOFF          = tcd->DOFF;
600070ee:	f241 0114 	movw	r1, #4116	; 0x1014
600070f2:	8a93      	ldrh	r3, [r2, #20]
600070f4:	b29b      	uxth	r3, r3
600070f6:	5243      	strh	r3, [r0, r1]
    base->TCD[channel].CITER_ELINKNO = tcd->CITER;
600070f8:	f241 0116 	movw	r1, #4118	; 0x1016
600070fc:	8ad3      	ldrh	r3, [r2, #22]
600070fe:	b29b      	uxth	r3, r3
60007100:	5243      	strh	r3, [r0, r1]
    base->TCD[channel].DLAST_SGA     = (int32_t)tcd->DLAST_SGA;
60007102:	f241 0318 	movw	r3, #4120	; 0x1018
60007106:	6991      	ldr	r1, [r2, #24]
60007108:	50c1      	str	r1, [r0, r3]
    base->TCD[channel].CSR           = 0;
6000710a:	f241 011c 	movw	r1, #4124	; 0x101c
6000710e:	5244      	strh	r4, [r0, r1]
    base->TCD[channel].CSR           = tcd->CSR;
60007110:	8b93      	ldrh	r3, [r2, #28]
60007112:	b29b      	uxth	r3, r3
60007114:	5243      	strh	r3, [r0, r1]
    base->TCD[channel].BITER_ELINKNO = tcd->BITER;
60007116:	8bd3      	ldrh	r3, [r2, #30]
60007118:	f241 021e 	movw	r2, #4126	; 0x101e
6000711c:	b29b      	uxth	r3, r3
6000711e:	5283      	strh	r3, [r0, r2]
}
60007120:	bd38      	pop	{r3, r4, r5, pc}
60007122:	bf00      	nop
60007124:	6000d219 	.word	0x6000d219
60007128:	6000d6d3 	.word	0x6000d6d3
6000712c:	6000c68a 	.word	0x6000c68a
60007130:	6000d7db 	.word	0x6000d7db
60007134:	6000d7ee 	.word	0x6000d7ee

60007138 <EDMA_Init>:
{
60007138:	b538      	push	{r3, r4, r5, lr}
6000713a:	4604      	mov	r4, r0
    assert(config != NULL);
6000713c:	460d      	mov	r5, r1
6000713e:	b949      	cbnz	r1, 60007154 <EDMA_Init+0x1c>
60007140:	4918      	ldr	r1, [pc, #96]	; (600071a4 <EDMA_Init+0x6c>)
60007142:	237a      	movs	r3, #122	; 0x7a
60007144:	4818      	ldr	r0, [pc, #96]	; (600071a8 <EDMA_Init+0x70>)
60007146:	4a19      	ldr	r2, [pc, #100]	; (600071ac <EDMA_Init+0x74>)
60007148:	f003 fcba 	bl	6000aac0 <assert_print>
6000714c:	217a      	movs	r1, #122	; 0x7a
6000714e:	4817      	ldr	r0, [pc, #92]	; (600071ac <EDMA_Init+0x74>)
60007150:	f003 fcaf 	bl	6000aab2 <assert_post_action>
    CLOCK_EnableClock(s_edmaClockName[EDMA_GetInstance(base)]);
60007154:	f7ff ff4e 	bl	60006ff4 <EDMA_GetInstance>
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
60007158:	4915      	ldr	r1, [pc, #84]	; (600071b0 <EDMA_Init+0x78>)
6000715a:	f101 037c 	add.w	r3, r1, #124	; 0x7c
6000715e:	e853 3f00 	ldrex	r3, [r3]

static inline void _SDK_AtomicLocalClearAndSet4Byte(volatile uint32_t *addr, uint32_t clearBits, uint32_t setBits)
{
    uint32_t s_val;

    _SDK_ATOMIC_LOCAL_OPS_4BYTE(addr, s_val, s_val = (s_val & ~clearBits) | setBits);
60007162:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
60007166:	f101 007c 	add.w	r0, r1, #124	; 0x7c
6000716a:	e840 3200 	strex	r2, r3, [r0]
6000716e:	2a00      	cmp	r2, #0
60007170:	d1f3      	bne.n	6000715a <EDMA_Init+0x22>
    base->INT = 0xFFFFFFFFU;
60007172:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    base->ERQ = 0U;
60007176:	60e2      	str	r2, [r4, #12]
    base->INT = 0xFFFFFFFFU;
60007178:	6263      	str	r3, [r4, #36]	; 0x24
    base->ERR = 0xFFFFFFFFU;
6000717a:	62e3      	str	r3, [r4, #44]	; 0x2c
               DMA_CR_CLM(config->enableContinuousLinkMode) | DMA_CR_EDBG(config->enableDebugMode) | DMA_CR_EMLM(1U));
6000717c:	78eb      	ldrb	r3, [r5, #3]
    tmpreg = base->CR;
6000717e:	6822      	ldr	r2, [r4, #0]
    tmpreg |= (DMA_CR_ERCA(config->enableRoundRobinArbitration) | DMA_CR_HOE(config->enableHaltOnError) |
60007180:	78a9      	ldrb	r1, [r5, #2]
               DMA_CR_CLM(config->enableContinuousLinkMode) | DMA_CR_EDBG(config->enableDebugMode) | DMA_CR_EMLM(1U));
60007182:	005b      	lsls	r3, r3, #1
    tmpreg &= ~(DMA_CR_ERCA_MASK | DMA_CR_HOE_MASK | DMA_CR_CLM_MASK | DMA_CR_EDBG_MASK);
60007184:	f022 0256 	bic.w	r2, r2, #86	; 0x56
    tmpreg |= (DMA_CR_ERCA(config->enableRoundRobinArbitration) | DMA_CR_HOE(config->enableHaltOnError) |
60007188:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
6000718c:	4313      	orrs	r3, r2
6000718e:	786a      	ldrb	r2, [r5, #1]
60007190:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
               DMA_CR_CLM(config->enableContinuousLinkMode) | DMA_CR_EDBG(config->enableDebugMode) | DMA_CR_EMLM(1U));
60007194:	782a      	ldrb	r2, [r5, #0]
    tmpreg |= (DMA_CR_ERCA(config->enableRoundRobinArbitration) | DMA_CR_HOE(config->enableHaltOnError) |
60007196:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
6000719a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    base->CR = tmpreg;
6000719e:	6023      	str	r3, [r4, #0]
}
600071a0:	bd38      	pop	{r3, r4, r5, pc}
600071a2:	bf00      	nop
600071a4:	6000d80c 	.word	0x6000d80c
600071a8:	6000c68a 	.word	0x6000c68a
600071ac:	6000d6d3 	.word	0x6000d6d3
600071b0:	400fc000 	.word	0x400fc000

600071b4 <EDMA_GetDefaultConfig>:
{
600071b4:	b510      	push	{r4, lr}
    assert(config != NULL);
600071b6:	4604      	mov	r4, r0
600071b8:	b948      	cbnz	r0, 600071ce <EDMA_GetDefaultConfig+0x1a>
600071ba:	490a      	ldr	r1, [pc, #40]	; (600071e4 <EDMA_GetDefaultConfig+0x30>)
600071bc:	23ae      	movs	r3, #174	; 0xae
600071be:	480a      	ldr	r0, [pc, #40]	; (600071e8 <EDMA_GetDefaultConfig+0x34>)
600071c0:	4a0a      	ldr	r2, [pc, #40]	; (600071ec <EDMA_GetDefaultConfig+0x38>)
600071c2:	f003 fc7d 	bl	6000aac0 <assert_print>
600071c6:	21ae      	movs	r1, #174	; 0xae
600071c8:	4808      	ldr	r0, [pc, #32]	; (600071ec <EDMA_GetDefaultConfig+0x38>)
600071ca:	f003 fc72 	bl	6000aab2 <assert_post_action>
    (void)memset(config, 0, sizeof(*config));
600071ce:	2204      	movs	r2, #4
600071d0:	2100      	movs	r1, #0
600071d2:	f003 fcdc 	bl	6000ab8e <memset>
    config->enableRoundRobinArbitration = false;
600071d6:	2300      	movs	r3, #0
    config->enableHaltOnError           = true;
600071d8:	2201      	movs	r2, #1
    config->enableRoundRobinArbitration = false;
600071da:	70a3      	strb	r3, [r4, #2]
    config->enableHaltOnError           = true;
600071dc:	7062      	strb	r2, [r4, #1]
    config->enableContinuousLinkMode    = false;
600071de:	7023      	strb	r3, [r4, #0]
    config->enableDebugMode             = false;
600071e0:	70e3      	strb	r3, [r4, #3]
}
600071e2:	bd10      	pop	{r4, pc}
600071e4:	6000d80c 	.word	0x6000d80c
600071e8:	6000c68a 	.word	0x6000c68a
600071ec:	6000d6d3 	.word	0x6000d6d3

600071f0 <EDMA_EnableChannelInterrupts>:
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
600071f0:	291f      	cmp	r1, #31
{
600071f2:	b538      	push	{r3, r4, r5, lr}
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
600071f4:	d90b      	bls.n	6000720e <EDMA_EnableChannelInterrupts+0x1e>
600071f6:	4915      	ldr	r1, [pc, #84]	; (6000724c <EDMA_EnableChannelInterrupts+0x5c>)
600071f8:	f240 1381 	movw	r3, #385	; 0x181
600071fc:	4814      	ldr	r0, [pc, #80]	; (60007250 <EDMA_EnableChannelInterrupts+0x60>)
600071fe:	4a15      	ldr	r2, [pc, #84]	; (60007254 <EDMA_EnableChannelInterrupts+0x64>)
60007200:	f003 fc5e 	bl	6000aac0 <assert_print>
60007204:	f240 1181 	movw	r1, #385	; 0x181
60007208:	4812      	ldr	r0, [pc, #72]	; (60007254 <EDMA_EnableChannelInterrupts+0x64>)
6000720a:	f003 fc52 	bl	6000aab2 <assert_post_action>
    if (0U != (mask & (uint32_t)kEDMA_ErrorInterruptEnable))
6000720e:	07d5      	lsls	r5, r2, #31
60007210:	d504      	bpl.n	6000721c <EDMA_EnableChannelInterrupts+0x2c>
        base->EEI |= ((uint32_t)0x1U << channel);
60007212:	2301      	movs	r3, #1
60007214:	6944      	ldr	r4, [r0, #20]
60007216:	408b      	lsls	r3, r1
60007218:	4323      	orrs	r3, r4
6000721a:	6143      	str	r3, [r0, #20]
    if (0U != (mask & (uint32_t)kEDMA_MajorInterruptEnable))
6000721c:	0794      	lsls	r4, r2, #30
6000721e:	d508      	bpl.n	60007232 <EDMA_EnableChannelInterrupts+0x42>
        base->TCD[channel].CSR |= DMA_CSR_INTMAJOR_MASK;
60007220:	eb00 1441 	add.w	r4, r0, r1, lsl #5
60007224:	f241 051c 	movw	r5, #4124	; 0x101c
60007228:	5b63      	ldrh	r3, [r4, r5]
6000722a:	b29b      	uxth	r3, r3
6000722c:	f043 0302 	orr.w	r3, r3, #2
60007230:	5363      	strh	r3, [r4, r5]
    if (0U != (mask & (uint32_t)kEDMA_HalfInterruptEnable))
60007232:	0753      	lsls	r3, r2, #29
60007234:	d508      	bpl.n	60007248 <EDMA_EnableChannelInterrupts+0x58>
        base->TCD[channel].CSR |= DMA_CSR_INTHALF_MASK;
60007236:	eb00 1041 	add.w	r0, r0, r1, lsl #5
6000723a:	f241 021c 	movw	r2, #4124	; 0x101c
6000723e:	5a83      	ldrh	r3, [r0, r2]
60007240:	b29b      	uxth	r3, r3
60007242:	f043 0304 	orr.w	r3, r3, #4
60007246:	5283      	strh	r3, [r0, r2]
}
60007248:	bd38      	pop	{r3, r4, r5, pc}
6000724a:	bf00      	nop
6000724c:	6000d219 	.word	0x6000d219
60007250:	6000c68a 	.word	0x6000c68a
60007254:	6000d6d3 	.word	0x6000d6d3

60007258 <EDMA_TcdReset>:
{
60007258:	b508      	push	{r3, lr}
    assert(tcd != NULL);
6000725a:	b958      	cbnz	r0, 60007274 <EDMA_TcdReset+0x1c>
6000725c:	4912      	ldr	r1, [pc, #72]	; (600072a8 <EDMA_TcdReset+0x50>)
6000725e:	f240 13bf 	movw	r3, #447	; 0x1bf
60007262:	4a12      	ldr	r2, [pc, #72]	; (600072ac <EDMA_TcdReset+0x54>)
60007264:	4812      	ldr	r0, [pc, #72]	; (600072b0 <EDMA_TcdReset+0x58>)
60007266:	f003 fc2b 	bl	6000aac0 <assert_print>
6000726a:	f240 11bf 	movw	r1, #447	; 0x1bf
    assert(((uint32_t)tcd & 0x1FU) == 0U);
6000726e:	480f      	ldr	r0, [pc, #60]	; (600072ac <EDMA_TcdReset+0x54>)
60007270:	f003 fc1f 	bl	6000aab2 <assert_post_action>
60007274:	f010 031f 	ands.w	r3, r0, #31
60007278:	d009      	beq.n	6000728e <EDMA_TcdReset+0x36>
6000727a:	490e      	ldr	r1, [pc, #56]	; (600072b4 <EDMA_TcdReset+0x5c>)
6000727c:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
60007280:	4a0a      	ldr	r2, [pc, #40]	; (600072ac <EDMA_TcdReset+0x54>)
60007282:	480b      	ldr	r0, [pc, #44]	; (600072b0 <EDMA_TcdReset+0x58>)
60007284:	f003 fc1c 	bl	6000aac0 <assert_print>
60007288:	f44f 71e0 	mov.w	r1, #448	; 0x1c0
6000728c:	e7ef      	b.n	6000726e <EDMA_TcdReset+0x16>
    tcd->CSR   = DMA_CSR_DREQ(1U);
6000728e:	2208      	movs	r2, #8
    tcd->SADDR     = 0U;
60007290:	6003      	str	r3, [r0, #0]
    tcd->SOFF      = 0U;
60007292:	8083      	strh	r3, [r0, #4]
    tcd->ATTR      = 0U;
60007294:	80c3      	strh	r3, [r0, #6]
    tcd->NBYTES    = 0U;
60007296:	6083      	str	r3, [r0, #8]
    tcd->SLAST     = 0U;
60007298:	60c3      	str	r3, [r0, #12]
    tcd->DADDR     = 0U;
6000729a:	6103      	str	r3, [r0, #16]
    tcd->DOFF      = 0U;
6000729c:	8283      	strh	r3, [r0, #20]
    tcd->CITER     = 0U;
6000729e:	82c3      	strh	r3, [r0, #22]
    tcd->DLAST_SGA = 0U;
600072a0:	6183      	str	r3, [r0, #24]
    tcd->CSR   = DMA_CSR_DREQ(1U);
600072a2:	8382      	strh	r2, [r0, #28]
    tcd->BITER = 0U;
600072a4:	83c3      	strh	r3, [r0, #30]
}
600072a6:	bd08      	pop	{r3, pc}
600072a8:	6000d7db 	.word	0x6000d7db
600072ac:	6000d6d3 	.word	0x6000d6d3
600072b0:	6000c68a 	.word	0x6000c68a
600072b4:	6000d7ee 	.word	0x6000d7ee

600072b8 <EDMA_ResetChannel>:
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
600072b8:	291f      	cmp	r1, #31
{
600072ba:	b508      	push	{r3, lr}
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
600072bc:	d909      	bls.n	600072d2 <EDMA_ResetChannel+0x1a>
600072be:	4908      	ldr	r1, [pc, #32]	; (600072e0 <EDMA_ResetChannel+0x28>)
600072c0:	23c6      	movs	r3, #198	; 0xc6
600072c2:	4808      	ldr	r0, [pc, #32]	; (600072e4 <EDMA_ResetChannel+0x2c>)
600072c4:	4a08      	ldr	r2, [pc, #32]	; (600072e8 <EDMA_ResetChannel+0x30>)
600072c6:	f003 fbfb 	bl	6000aac0 <assert_print>
600072ca:	21c6      	movs	r1, #198	; 0xc6
600072cc:	4806      	ldr	r0, [pc, #24]	; (600072e8 <EDMA_ResetChannel+0x30>)
600072ce:	f003 fbf0 	bl	6000aab2 <assert_post_action>
    EDMA_TcdReset((edma_tcd_t *)(uint32_t)&base->TCD[channel]);
600072d2:	3180      	adds	r1, #128	; 0x80
}
600072d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    EDMA_TcdReset((edma_tcd_t *)(uint32_t)&base->TCD[channel]);
600072d8:	eb00 1041 	add.w	r0, r0, r1, lsl #5
600072dc:	f7ff bfbc 	b.w	60007258 <EDMA_TcdReset>
600072e0:	6000d219 	.word	0x6000d219
600072e4:	6000c68a 	.word	0x6000c68a
600072e8:	6000d6d3 	.word	0x6000d6d3

600072ec <EDMA_TcdSetTransferConfig>:
{
600072ec:	b538      	push	{r3, r4, r5, lr}
    assert(tcd != NULL);
600072ee:	b958      	cbnz	r0, 60007308 <EDMA_TcdSetTransferConfig+0x1c>
600072f0:	4938      	ldr	r1, [pc, #224]	; (600073d4 <EDMA_TcdSetTransferConfig+0xe8>)
600072f2:	f44f 73f7 	mov.w	r3, #494	; 0x1ee
600072f6:	4a38      	ldr	r2, [pc, #224]	; (600073d8 <EDMA_TcdSetTransferConfig+0xec>)
600072f8:	4838      	ldr	r0, [pc, #224]	; (600073dc <EDMA_TcdSetTransferConfig+0xf0>)
600072fa:	f003 fbe1 	bl	6000aac0 <assert_print>
600072fe:	f44f 71f7 	mov.w	r1, #494	; 0x1ee
    assert(((uint32_t)tcd & 0x1FU) == 0U);
60007302:	4835      	ldr	r0, [pc, #212]	; (600073d8 <EDMA_TcdSetTransferConfig+0xec>)
60007304:	f003 fbd5 	bl	6000aab2 <assert_post_action>
60007308:	06c4      	lsls	r4, r0, #27
6000730a:	d009      	beq.n	60007320 <EDMA_TcdSetTransferConfig+0x34>
6000730c:	4934      	ldr	r1, [pc, #208]	; (600073e0 <EDMA_TcdSetTransferConfig+0xf4>)
6000730e:	f240 13ef 	movw	r3, #495	; 0x1ef
60007312:	4a31      	ldr	r2, [pc, #196]	; (600073d8 <EDMA_TcdSetTransferConfig+0xec>)
60007314:	4831      	ldr	r0, [pc, #196]	; (600073dc <EDMA_TcdSetTransferConfig+0xf0>)
60007316:	f003 fbd3 	bl	6000aac0 <assert_print>
6000731a:	f240 11ef 	movw	r1, #495	; 0x1ef
6000731e:	e7f0      	b.n	60007302 <EDMA_TcdSetTransferConfig+0x16>
    assert(config != NULL);
60007320:	b949      	cbnz	r1, 60007336 <EDMA_TcdSetTransferConfig+0x4a>
60007322:	4930      	ldr	r1, [pc, #192]	; (600073e4 <EDMA_TcdSetTransferConfig+0xf8>)
60007324:	f44f 73f8 	mov.w	r3, #496	; 0x1f0
60007328:	4a2b      	ldr	r2, [pc, #172]	; (600073d8 <EDMA_TcdSetTransferConfig+0xec>)
6000732a:	482c      	ldr	r0, [pc, #176]	; (600073dc <EDMA_TcdSetTransferConfig+0xf0>)
6000732c:	f003 fbc8 	bl	6000aac0 <assert_print>
60007330:	f44f 71f8 	mov.w	r1, #496	; 0x1f0
60007334:	e7e5      	b.n	60007302 <EDMA_TcdSetTransferConfig+0x16>
    assert(((uint32_t)nextTcd & 0x1FU) == 0U);
60007336:	06d3      	lsls	r3, r2, #27
60007338:	d009      	beq.n	6000734e <EDMA_TcdSetTransferConfig+0x62>
6000733a:	492b      	ldr	r1, [pc, #172]	; (600073e8 <EDMA_TcdSetTransferConfig+0xfc>)
6000733c:	f240 13f1 	movw	r3, #497	; 0x1f1
60007340:	4a25      	ldr	r2, [pc, #148]	; (600073d8 <EDMA_TcdSetTransferConfig+0xec>)
60007342:	4826      	ldr	r0, [pc, #152]	; (600073dc <EDMA_TcdSetTransferConfig+0xf0>)
60007344:	f003 fbbc 	bl	6000aac0 <assert_print>
60007348:	f240 11f1 	movw	r1, #497	; 0x1f1
6000734c:	e7d9      	b.n	60007302 <EDMA_TcdSetTransferConfig+0x16>
    assert((config->srcAddr % (1UL << (uint32_t)config->srcTransferSize)) == 0U);
6000734e:	7a0c      	ldrb	r4, [r1, #8]
60007350:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60007354:	680d      	ldr	r5, [r1, #0]
60007356:	fa03 f404 	lsl.w	r4, r3, r4
6000735a:	ea35 0404 	bics.w	r4, r5, r4
6000735e:	d009      	beq.n	60007374 <EDMA_TcdSetTransferConfig+0x88>
60007360:	4922      	ldr	r1, [pc, #136]	; (600073ec <EDMA_TcdSetTransferConfig+0x100>)
60007362:	f44f 73f9 	mov.w	r3, #498	; 0x1f2
60007366:	4a1c      	ldr	r2, [pc, #112]	; (600073d8 <EDMA_TcdSetTransferConfig+0xec>)
60007368:	481c      	ldr	r0, [pc, #112]	; (600073dc <EDMA_TcdSetTransferConfig+0xf0>)
6000736a:	f003 fba9 	bl	6000aac0 <assert_print>
6000736e:	f44f 71f9 	mov.w	r1, #498	; 0x1f2
60007372:	e7c6      	b.n	60007302 <EDMA_TcdSetTransferConfig+0x16>
    assert((config->destAddr % (1UL << (uint32_t)config->destTransferSize)) == 0U);
60007374:	7a4c      	ldrb	r4, [r1, #9]
60007376:	40a3      	lsls	r3, r4
60007378:	684c      	ldr	r4, [r1, #4]
6000737a:	439c      	bics	r4, r3
6000737c:	d009      	beq.n	60007392 <EDMA_TcdSetTransferConfig+0xa6>
6000737e:	491c      	ldr	r1, [pc, #112]	; (600073f0 <EDMA_TcdSetTransferConfig+0x104>)
60007380:	f240 13f3 	movw	r3, #499	; 0x1f3
60007384:	4a14      	ldr	r2, [pc, #80]	; (600073d8 <EDMA_TcdSetTransferConfig+0xec>)
60007386:	4815      	ldr	r0, [pc, #84]	; (600073dc <EDMA_TcdSetTransferConfig+0xf0>)
60007388:	f003 fb9a 	bl	6000aac0 <assert_print>
6000738c:	f240 11f3 	movw	r1, #499	; 0x1f3
60007390:	e7b7      	b.n	60007302 <EDMA_TcdSetTransferConfig+0x16>
    tcd->SADDR = config->srcAddr;
60007392:	6005      	str	r5, [r0, #0]
    tcd->DADDR = config->destAddr;
60007394:	684b      	ldr	r3, [r1, #4]
60007396:	6103      	str	r3, [r0, #16]
    tcd->ATTR = DMA_ATTR_SSIZE(config->srcTransferSize) | DMA_ATTR_DSIZE(config->destTransferSize);
60007398:	7a0c      	ldrb	r4, [r1, #8]
6000739a:	7a4b      	ldrb	r3, [r1, #9]
6000739c:	0224      	lsls	r4, r4, #8
6000739e:	f003 0307 	and.w	r3, r3, #7
600073a2:	f404 64e0 	and.w	r4, r4, #1792	; 0x700
600073a6:	4323      	orrs	r3, r4
600073a8:	80c3      	strh	r3, [r0, #6]
    tcd->SOFF = (uint16_t)config->srcOffset;
600073aa:	894b      	ldrh	r3, [r1, #10]
600073ac:	8083      	strh	r3, [r0, #4]
    tcd->DOFF = (uint16_t)config->destOffset;
600073ae:	898b      	ldrh	r3, [r1, #12]
600073b0:	8283      	strh	r3, [r0, #20]
    tcd->NBYTES = config->minorLoopBytes;
600073b2:	690b      	ldr	r3, [r1, #16]
600073b4:	6083      	str	r3, [r0, #8]
    tcd->CITER = (uint16_t)config->majorLoopCounts;
600073b6:	8a8b      	ldrh	r3, [r1, #20]
600073b8:	82c3      	strh	r3, [r0, #22]
    tcd->BITER = (uint16_t)config->majorLoopCounts;
600073ba:	8a8b      	ldrh	r3, [r1, #20]
600073bc:	83c3      	strh	r3, [r0, #30]
    if (nextTcd != NULL)
600073be:	b13a      	cbz	r2, 600073d0 <EDMA_TcdSetTransferConfig+0xe4>
        tcd->DLAST_SGA = (uint32_t)nextTcd;
600073c0:	6182      	str	r2, [r0, #24]
        tcd->CSR = (tcd->CSR | (uint16_t)DMA_CSR_ESG_MASK) & ~(uint16_t)DMA_CSR_DREQ_MASK;
600073c2:	8b83      	ldrh	r3, [r0, #28]
600073c4:	b29b      	uxth	r3, r3
600073c6:	f023 0308 	bic.w	r3, r3, #8
600073ca:	f043 0310 	orr.w	r3, r3, #16
600073ce:	8383      	strh	r3, [r0, #28]
}
600073d0:	bd38      	pop	{r3, r4, r5, pc}
600073d2:	bf00      	nop
600073d4:	6000d7db 	.word	0x6000d7db
600073d8:	6000d6d3 	.word	0x6000d6d3
600073dc:	6000c68a 	.word	0x6000c68a
600073e0:	6000d7ee 	.word	0x6000d7ee
600073e4:	6000d80c 	.word	0x6000d80c
600073e8:	6000d822 	.word	0x6000d822
600073ec:	6000d844 	.word	0x6000d844
600073f0:	6000d889 	.word	0x6000d889

600073f4 <EDMA_SetTransferConfig>:
{
600073f4:	b510      	push	{r4, lr}
600073f6:	460c      	mov	r4, r1
600073f8:	4611      	mov	r1, r2
600073fa:	461a      	mov	r2, r3
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
600073fc:	2c1f      	cmp	r4, #31
600073fe:	d909      	bls.n	60007414 <EDMA_SetTransferConfig+0x20>
60007400:	4911      	ldr	r1, [pc, #68]	; (60007448 <EDMA_SetTransferConfig+0x54>)
60007402:	23e6      	movs	r3, #230	; 0xe6
60007404:	4a11      	ldr	r2, [pc, #68]	; (6000744c <EDMA_SetTransferConfig+0x58>)
60007406:	4812      	ldr	r0, [pc, #72]	; (60007450 <EDMA_SetTransferConfig+0x5c>)
60007408:	f003 fb5a 	bl	6000aac0 <assert_print>
6000740c:	21e6      	movs	r1, #230	; 0xe6
    assert(config != NULL);
6000740e:	480f      	ldr	r0, [pc, #60]	; (6000744c <EDMA_SetTransferConfig+0x58>)
60007410:	f003 fb4f 	bl	6000aab2 <assert_post_action>
60007414:	b939      	cbnz	r1, 60007426 <EDMA_SetTransferConfig+0x32>
60007416:	490f      	ldr	r1, [pc, #60]	; (60007454 <EDMA_SetTransferConfig+0x60>)
60007418:	23e7      	movs	r3, #231	; 0xe7
6000741a:	4a0c      	ldr	r2, [pc, #48]	; (6000744c <EDMA_SetTransferConfig+0x58>)
6000741c:	480c      	ldr	r0, [pc, #48]	; (60007450 <EDMA_SetTransferConfig+0x5c>)
6000741e:	f003 fb4f 	bl	6000aac0 <assert_print>
60007422:	21e7      	movs	r1, #231	; 0xe7
60007424:	e7f3      	b.n	6000740e <EDMA_SetTransferConfig+0x1a>
    assert(((uint32_t)nextTcd & 0x1FU) == 0U);
60007426:	06d3      	lsls	r3, r2, #27
60007428:	d007      	beq.n	6000743a <EDMA_SetTransferConfig+0x46>
6000742a:	490b      	ldr	r1, [pc, #44]	; (60007458 <EDMA_SetTransferConfig+0x64>)
6000742c:	23e8      	movs	r3, #232	; 0xe8
6000742e:	4a07      	ldr	r2, [pc, #28]	; (6000744c <EDMA_SetTransferConfig+0x58>)
60007430:	4807      	ldr	r0, [pc, #28]	; (60007450 <EDMA_SetTransferConfig+0x5c>)
60007432:	f003 fb45 	bl	6000aac0 <assert_print>
60007436:	21e8      	movs	r1, #232	; 0xe8
60007438:	e7e9      	b.n	6000740e <EDMA_SetTransferConfig+0x1a>
    EDMA_TcdSetTransferConfig((edma_tcd_t *)(uint32_t)&base->TCD[channel], config, nextTcd);
6000743a:	3480      	adds	r4, #128	; 0x80
6000743c:	eb00 1044 	add.w	r0, r0, r4, lsl #5
}
60007440:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    EDMA_TcdSetTransferConfig((edma_tcd_t *)(uint32_t)&base->TCD[channel], config, nextTcd);
60007444:	f7ff bf52 	b.w	600072ec <EDMA_TcdSetTransferConfig>
60007448:	6000d219 	.word	0x6000d219
6000744c:	6000d6d3 	.word	0x6000d6d3
60007450:	6000c68a 	.word	0x6000c68a
60007454:	6000d80c 	.word	0x6000d80c
60007458:	6000d822 	.word	0x6000d822

6000745c <EDMA_TcdSetChannelLink>:
{
6000745c:	b508      	push	{r3, lr}
    assert(tcd != NULL);
6000745e:	b958      	cbnz	r0, 60007478 <EDMA_TcdSetChannelLink+0x1c>
60007460:	4931      	ldr	r1, [pc, #196]	; (60007528 <EDMA_TcdSetChannelLink+0xcc>)
60007462:	f240 235b 	movw	r3, #603	; 0x25b
60007466:	4a31      	ldr	r2, [pc, #196]	; (6000752c <EDMA_TcdSetChannelLink+0xd0>)
60007468:	4831      	ldr	r0, [pc, #196]	; (60007530 <EDMA_TcdSetChannelLink+0xd4>)
6000746a:	f003 fb29 	bl	6000aac0 <assert_print>
6000746e:	f240 215b 	movw	r1, #603	; 0x25b
    assert(((uint32_t)tcd & 0x1FU) == 0U);
60007472:	482e      	ldr	r0, [pc, #184]	; (6000752c <EDMA_TcdSetChannelLink+0xd0>)
60007474:	f003 fb1d 	bl	6000aab2 <assert_post_action>
60007478:	06c3      	lsls	r3, r0, #27
6000747a:	d009      	beq.n	60007490 <EDMA_TcdSetChannelLink+0x34>
6000747c:	492d      	ldr	r1, [pc, #180]	; (60007534 <EDMA_TcdSetChannelLink+0xd8>)
6000747e:	f44f 7317 	mov.w	r3, #604	; 0x25c
60007482:	4a2a      	ldr	r2, [pc, #168]	; (6000752c <EDMA_TcdSetChannelLink+0xd0>)
60007484:	482a      	ldr	r0, [pc, #168]	; (60007530 <EDMA_TcdSetChannelLink+0xd4>)
60007486:	f003 fb1b 	bl	6000aac0 <assert_print>
6000748a:	f44f 7117 	mov.w	r1, #604	; 0x25c
6000748e:	e7f0      	b.n	60007472 <EDMA_TcdSetChannelLink+0x16>
    assert(linkedChannel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
60007490:	2a1f      	cmp	r2, #31
60007492:	d909      	bls.n	600074a8 <EDMA_TcdSetChannelLink+0x4c>
60007494:	4928      	ldr	r1, [pc, #160]	; (60007538 <EDMA_TcdSetChannelLink+0xdc>)
60007496:	f240 235d 	movw	r3, #605	; 0x25d
6000749a:	4a24      	ldr	r2, [pc, #144]	; (6000752c <EDMA_TcdSetChannelLink+0xd0>)
6000749c:	4824      	ldr	r0, [pc, #144]	; (60007530 <EDMA_TcdSetChannelLink+0xd4>)
6000749e:	f003 fb0f 	bl	6000aac0 <assert_print>
600074a2:	f240 215d 	movw	r1, #605	; 0x25d
600074a6:	e7e4      	b.n	60007472 <EDMA_TcdSetChannelLink+0x16>
    if (linkType == kEDMA_MinorLink) /* Minor link config */
600074a8:	2901      	cmp	r1, #1
600074aa:	d11e      	bne.n	600074ea <EDMA_TcdSetChannelLink+0x8e>
        tcd->CITER |= DMA_CITER_ELINKYES_ELINK_MASK;
600074ac:	8ac3      	ldrh	r3, [r0, #22]
        tmpreg |= DMA_CITER_ELINKYES_LINKCH(linkedChannel);
600074ae:	0252      	lsls	r2, r2, #9
        tcd->CITER |= DMA_CITER_ELINKYES_ELINK_MASK;
600074b0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
        tmpreg |= DMA_CITER_ELINKYES_LINKCH(linkedChannel);
600074b4:	b292      	uxth	r2, r2
        tcd->CITER |= DMA_CITER_ELINKYES_ELINK_MASK;
600074b6:	ea6f 4353 	mvn.w	r3, r3, lsr #17
600074ba:	b29b      	uxth	r3, r3
600074bc:	82c3      	strh	r3, [r0, #22]
        tcd->BITER |= DMA_BITER_ELINKYES_ELINK_MASK;
600074be:	8bc3      	ldrh	r3, [r0, #30]
600074c0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
600074c4:	ea6f 4353 	mvn.w	r3, r3, lsr #17
600074c8:	b29b      	uxth	r3, r3
600074ca:	83c3      	strh	r3, [r0, #30]
        tmpreg = tcd->CITER & (~(uint16_t)DMA_CITER_ELINKYES_LINKCH_MASK);
600074cc:	8ac3      	ldrh	r3, [r0, #22]
600074ce:	f423 5378 	bic.w	r3, r3, #15872	; 0x3e00
600074d2:	041b      	lsls	r3, r3, #16
600074d4:	0c1b      	lsrs	r3, r3, #16
        tmpreg |= DMA_CITER_ELINKYES_LINKCH(linkedChannel);
600074d6:	4313      	orrs	r3, r2
        tcd->CITER = tmpreg;
600074d8:	82c3      	strh	r3, [r0, #22]
        tmpreg     = tcd->BITER & (~(uint16_t)DMA_BITER_ELINKYES_LINKCH_MASK);
600074da:	8bc3      	ldrh	r3, [r0, #30]
600074dc:	f423 5378 	bic.w	r3, r3, #15872	; 0x3e00
600074e0:	041b      	lsls	r3, r3, #16
600074e2:	0c1b      	lsrs	r3, r3, #16
        tmpreg |= DMA_BITER_ELINKYES_LINKCH(linkedChannel);
600074e4:	431a      	orrs	r2, r3
        tcd->BITER = tmpreg;
600074e6:	83c2      	strh	r2, [r0, #30]
}
600074e8:	bd08      	pop	{r3, pc}
    else if (linkType == kEDMA_MajorLink) /* Major link config */
600074ea:	2902      	cmp	r1, #2
600074ec:	d10d      	bne.n	6000750a <EDMA_TcdSetChannelLink+0xae>
        tcd->CSR |= DMA_CSR_MAJORELINK_MASK;
600074ee:	8b83      	ldrh	r3, [r0, #28]
600074f0:	b29b      	uxth	r3, r3
600074f2:	f043 0320 	orr.w	r3, r3, #32
600074f6:	8383      	strh	r3, [r0, #28]
        tmpreg   = tcd->CSR & (~(uint16_t)DMA_CSR_MAJORLINKCH_MASK);
600074f8:	8b83      	ldrh	r3, [r0, #28]
600074fa:	b29b      	uxth	r3, r3
600074fc:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
        tcd->CSR = tmpreg | DMA_CSR_MAJORLINKCH(linkedChannel);
60007500:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
60007504:	b29b      	uxth	r3, r3
        tcd->CSR &= ~(uint16_t)DMA_CSR_MAJORELINK_MASK;
60007506:	8383      	strh	r3, [r0, #28]
}
60007508:	e7ee      	b.n	600074e8 <EDMA_TcdSetChannelLink+0x8c>
        tcd->CITER &= ~(uint16_t)DMA_CITER_ELINKYES_ELINK_MASK;
6000750a:	8ac3      	ldrh	r3, [r0, #22]
6000750c:	f3c3 030e 	ubfx	r3, r3, #0, #15
60007510:	82c3      	strh	r3, [r0, #22]
        tcd->BITER &= ~(uint16_t)DMA_BITER_ELINKYES_ELINK_MASK;
60007512:	8bc3      	ldrh	r3, [r0, #30]
60007514:	f3c3 030e 	ubfx	r3, r3, #0, #15
60007518:	83c3      	strh	r3, [r0, #30]
        tcd->CSR &= ~(uint16_t)DMA_CSR_MAJORELINK_MASK;
6000751a:	8b83      	ldrh	r3, [r0, #28]
6000751c:	f023 0320 	bic.w	r3, r3, #32
60007520:	041b      	lsls	r3, r3, #16
60007522:	0c1b      	lsrs	r3, r3, #16
60007524:	e7ef      	b.n	60007506 <EDMA_TcdSetChannelLink+0xaa>
60007526:	bf00      	nop
60007528:	6000d7db 	.word	0x6000d7db
6000752c:	6000d6d3 	.word	0x6000d6d3
60007530:	6000c68a 	.word	0x6000c68a
60007534:	6000d7ee 	.word	0x6000d7ee
60007538:	6000d8d0 	.word	0x6000d8d0

6000753c <EDMA_SetChannelLink>:
{
6000753c:	b510      	push	{r4, lr}
6000753e:	460c      	mov	r4, r1
60007540:	4611      	mov	r1, r2
60007542:	461a      	mov	r2, r3
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
60007544:	2c1f      	cmp	r4, #31
60007546:	d90b      	bls.n	60007560 <EDMA_SetChannelLink+0x24>
60007548:	490f      	ldr	r1, [pc, #60]	; (60007588 <EDMA_SetChannelLink+0x4c>)
6000754a:	f44f 73a3 	mov.w	r3, #326	; 0x146
6000754e:	4a0f      	ldr	r2, [pc, #60]	; (6000758c <EDMA_SetChannelLink+0x50>)
60007550:	480f      	ldr	r0, [pc, #60]	; (60007590 <EDMA_SetChannelLink+0x54>)
60007552:	f003 fab5 	bl	6000aac0 <assert_print>
60007556:	f44f 71a3 	mov.w	r1, #326	; 0x146
    assert(linkedChannel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
6000755a:	480c      	ldr	r0, [pc, #48]	; (6000758c <EDMA_SetChannelLink+0x50>)
6000755c:	f003 faa9 	bl	6000aab2 <assert_post_action>
60007560:	2b1f      	cmp	r3, #31
60007562:	d909      	bls.n	60007578 <EDMA_SetChannelLink+0x3c>
60007564:	490b      	ldr	r1, [pc, #44]	; (60007594 <EDMA_SetChannelLink+0x58>)
60007566:	f240 1347 	movw	r3, #327	; 0x147
6000756a:	4a08      	ldr	r2, [pc, #32]	; (6000758c <EDMA_SetChannelLink+0x50>)
6000756c:	4808      	ldr	r0, [pc, #32]	; (60007590 <EDMA_SetChannelLink+0x54>)
6000756e:	f003 faa7 	bl	6000aac0 <assert_print>
60007572:	f240 1147 	movw	r1, #327	; 0x147
60007576:	e7f0      	b.n	6000755a <EDMA_SetChannelLink+0x1e>
    EDMA_TcdSetChannelLink((edma_tcd_t *)(uint32_t)&base->TCD[channel], linkType, linkedChannel);
60007578:	3480      	adds	r4, #128	; 0x80
6000757a:	eb00 1044 	add.w	r0, r0, r4, lsl #5
}
6000757e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    EDMA_TcdSetChannelLink((edma_tcd_t *)(uint32_t)&base->TCD[channel], linkType, linkedChannel);
60007582:	f7ff bf6b 	b.w	6000745c <EDMA_TcdSetChannelLink>
60007586:	bf00      	nop
60007588:	6000d219 	.word	0x6000d219
6000758c:	6000d6d3 	.word	0x6000d6d3
60007590:	6000c68a 	.word	0x6000c68a
60007594:	6000d8d0 	.word	0x6000d8d0

60007598 <EDMA_GetRemainingMajorLoopCount>:
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
60007598:	291f      	cmp	r1, #31
{
6000759a:	b508      	push	{r3, lr}
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
6000759c:	d90b      	bls.n	600075b6 <EDMA_GetRemainingMajorLoopCount+0x1e>
6000759e:	4910      	ldr	r1, [pc, #64]	; (600075e0 <EDMA_GetRemainingMajorLoopCount+0x48>)
600075a0:	f240 23dd 	movw	r3, #733	; 0x2dd
600075a4:	480f      	ldr	r0, [pc, #60]	; (600075e4 <EDMA_GetRemainingMajorLoopCount+0x4c>)
600075a6:	4a10      	ldr	r2, [pc, #64]	; (600075e8 <EDMA_GetRemainingMajorLoopCount+0x50>)
600075a8:	f003 fa8a 	bl	6000aac0 <assert_print>
600075ac:	f240 21dd 	movw	r1, #733	; 0x2dd
600075b0:	480d      	ldr	r0, [pc, #52]	; (600075e8 <EDMA_GetRemainingMajorLoopCount+0x50>)
600075b2:	f003 fa7e 	bl	6000aab2 <assert_post_action>
    if (0U != (DMA_CSR_DONE_MASK & base->TCD[channel].CSR))
600075b6:	eb00 1041 	add.w	r0, r0, r1, lsl #5
600075ba:	f241 031c 	movw	r3, #4124	; 0x101c
600075be:	5ac3      	ldrh	r3, [r0, r3]
600075c0:	061a      	lsls	r2, r3, #24
600075c2:	d40a      	bmi.n	600075da <EDMA_GetRemainingMajorLoopCount+0x42>
        if (0U != (base->TCD[channel].CITER_ELINKNO & DMA_CITER_ELINKNO_ELINK_MASK))
600075c4:	f241 0316 	movw	r3, #4118	; 0x1016
600075c8:	5ac2      	ldrh	r2, [r0, r3]
            remainingCount = (((uint32_t)base->TCD[channel].CITER_ELINKYES & DMA_CITER_ELINKYES_CITER_MASK) >>
600075ca:	5ac0      	ldrh	r0, [r0, r3]
        if (0U != (base->TCD[channel].CITER_ELINKNO & DMA_CITER_ELINKNO_ELINK_MASK))
600075cc:	0413      	lsls	r3, r2, #16
            remainingCount = (((uint32_t)base->TCD[channel].CITER_ELINKYES & DMA_CITER_ELINKYES_CITER_MASK) >>
600075ce:	bf4c      	ite	mi
600075d0:	f3c0 0008 	ubfxmi	r0, r0, #0, #9
            remainingCount = (((uint32_t)base->TCD[channel].CITER_ELINKNO & DMA_CITER_ELINKNO_CITER_MASK) >>
600075d4:	f3c0 000e 	ubfxpl	r0, r0, #0, #15
}
600075d8:	bd08      	pop	{r3, pc}
        remainingCount = 0;
600075da:	2000      	movs	r0, #0
    return remainingCount;
600075dc:	e7fc      	b.n	600075d8 <EDMA_GetRemainingMajorLoopCount+0x40>
600075de:	bf00      	nop
600075e0:	6000d219 	.word	0x6000d219
600075e4:	6000c68a 	.word	0x6000c68a
600075e8:	6000d6d3 	.word	0x6000d6d3

600075ec <EDMA_GetChannelStatusFlags>:
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
600075ec:	291f      	cmp	r1, #31
{
600075ee:	b510      	push	{r4, lr}
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
600075f0:	d90b      	bls.n	6000760a <EDMA_GetChannelStatusFlags+0x1e>
600075f2:	4910      	ldr	r1, [pc, #64]	; (60007634 <EDMA_GetChannelStatusFlags+0x48>)
600075f4:	f240 3301 	movw	r3, #769	; 0x301
600075f8:	480f      	ldr	r0, [pc, #60]	; (60007638 <EDMA_GetChannelStatusFlags+0x4c>)
600075fa:	4a10      	ldr	r2, [pc, #64]	; (6000763c <EDMA_GetChannelStatusFlags+0x50>)
600075fc:	f003 fa60 	bl	6000aac0 <assert_print>
60007600:	f240 3101 	movw	r1, #769	; 0x301
60007604:	480d      	ldr	r0, [pc, #52]	; (6000763c <EDMA_GetChannelStatusFlags+0x50>)
60007606:	f003 fa54 	bl	6000aab2 <assert_post_action>
    retval |= (((uint32_t)base->TCD[channel].CSR & DMA_CSR_DONE_MASK) >> DMA_CSR_DONE_SHIFT);
6000760a:	eb00 1241 	add.w	r2, r0, r1, lsl #5
6000760e:	f241 031c 	movw	r3, #4124	; 0x101c
60007612:	5ad4      	ldrh	r4, [r2, r3]
    retval |= ((((uint32_t)base->ERR >> channel) & 0x1U) << 1U);
60007614:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    retval |= ((((uint32_t)base->INT >> channel) & 0x1U) << 2U);
60007616:	6a42      	ldr	r2, [r0, #36]	; 0x24
    retval |= (((uint32_t)base->TCD[channel].CSR & DMA_CSR_DONE_MASK) >> DMA_CSR_DONE_SHIFT);
60007618:	f3c4 10c0 	ubfx	r0, r4, #7, #1
    retval |= ((((uint32_t)base->ERR >> channel) & 0x1U) << 1U);
6000761c:	40cb      	lsrs	r3, r1
    retval |= ((((uint32_t)base->INT >> channel) & 0x1U) << 2U);
6000761e:	40ca      	lsrs	r2, r1
    retval |= ((((uint32_t)base->ERR >> channel) & 0x1U) << 1U);
60007620:	005b      	lsls	r3, r3, #1
    retval |= ((((uint32_t)base->INT >> channel) & 0x1U) << 2U);
60007622:	0092      	lsls	r2, r2, #2
    retval |= ((((uint32_t)base->ERR >> channel) & 0x1U) << 1U);
60007624:	f003 0302 	and.w	r3, r3, #2
    retval |= ((((uint32_t)base->INT >> channel) & 0x1U) << 2U);
60007628:	f002 0204 	and.w	r2, r2, #4
6000762c:	4313      	orrs	r3, r2
}
6000762e:	4318      	orrs	r0, r3
60007630:	bd10      	pop	{r4, pc}
60007632:	bf00      	nop
60007634:	6000d219 	.word	0x6000d219
60007638:	6000c68a 	.word	0x6000c68a
6000763c:	6000d6d3 	.word	0x6000d6d3

60007640 <EDMA_ClearChannelStatusFlags>:
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
60007640:	291f      	cmp	r1, #31
{
60007642:	b508      	push	{r3, lr}
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
60007644:	d90b      	bls.n	6000765e <EDMA_ClearChannelStatusFlags+0x1e>
60007646:	490c      	ldr	r1, [pc, #48]	; (60007678 <EDMA_ClearChannelStatusFlags+0x38>)
60007648:	f240 3319 	movw	r3, #793	; 0x319
6000764c:	480b      	ldr	r0, [pc, #44]	; (6000767c <EDMA_ClearChannelStatusFlags+0x3c>)
6000764e:	4a0c      	ldr	r2, [pc, #48]	; (60007680 <EDMA_ClearChannelStatusFlags+0x40>)
60007650:	f003 fa36 	bl	6000aac0 <assert_print>
60007654:	f240 3119 	movw	r1, #793	; 0x319
60007658:	4809      	ldr	r0, [pc, #36]	; (60007680 <EDMA_ClearChannelStatusFlags+0x40>)
6000765a:	f003 fa2a 	bl	6000aab2 <assert_post_action>
    if (0U != (mask & (uint32_t)kEDMA_DoneFlag))
6000765e:	07d3      	lsls	r3, r2, #31
60007660:	d501      	bpl.n	60007666 <EDMA_ClearChannelStatusFlags+0x26>
        base->CDNE = (uint8_t)channel;
60007662:	b2cb      	uxtb	r3, r1
60007664:	7703      	strb	r3, [r0, #28]
    if (0U != (mask & (uint32_t)kEDMA_ErrorFlag))
60007666:	0793      	lsls	r3, r2, #30
60007668:	d501      	bpl.n	6000766e <EDMA_ClearChannelStatusFlags+0x2e>
        base->CERR = (uint8_t)channel;
6000766a:	b2cb      	uxtb	r3, r1
6000766c:	7783      	strb	r3, [r0, #30]
    if (0U != (mask & (uint32_t)kEDMA_InterruptFlag))
6000766e:	0753      	lsls	r3, r2, #29
60007670:	d501      	bpl.n	60007676 <EDMA_ClearChannelStatusFlags+0x36>
        base->CINT = (uint8_t)channel;
60007672:	b2c9      	uxtb	r1, r1
60007674:	77c1      	strb	r1, [r0, #31]
}
60007676:	bd08      	pop	{r3, pc}
60007678:	6000d219 	.word	0x6000d219
6000767c:	6000c68a 	.word	0x6000c68a
60007680:	6000d6d3 	.word	0x6000d6d3

60007684 <EDMA_CreateHandle>:
{
60007684:	b570      	push	{r4, r5, r6, lr}
60007686:	460e      	mov	r6, r1
60007688:	4615      	mov	r5, r2
    assert(handle != NULL);
6000768a:	4604      	mov	r4, r0
6000768c:	b958      	cbnz	r0, 600076a6 <EDMA_CreateHandle+0x22>
6000768e:	492d      	ldr	r1, [pc, #180]	; (60007744 <EDMA_CreateHandle+0xc0>)
60007690:	f44f 7353 	mov.w	r3, #844	; 0x34c
60007694:	4a2c      	ldr	r2, [pc, #176]	; (60007748 <EDMA_CreateHandle+0xc4>)
60007696:	482d      	ldr	r0, [pc, #180]	; (6000774c <EDMA_CreateHandle+0xc8>)
60007698:	f003 fa12 	bl	6000aac0 <assert_print>
6000769c:	f44f 7153 	mov.w	r1, #844	; 0x34c
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
600076a0:	4829      	ldr	r0, [pc, #164]	; (60007748 <EDMA_CreateHandle+0xc4>)
600076a2:	f003 fa06 	bl	6000aab2 <assert_post_action>
600076a6:	2a1f      	cmp	r2, #31
600076a8:	d909      	bls.n	600076be <EDMA_CreateHandle+0x3a>
600076aa:	4929      	ldr	r1, [pc, #164]	; (60007750 <EDMA_CreateHandle+0xcc>)
600076ac:	f240 334d 	movw	r3, #845	; 0x34d
600076b0:	4a25      	ldr	r2, [pc, #148]	; (60007748 <EDMA_CreateHandle+0xc4>)
600076b2:	4826      	ldr	r0, [pc, #152]	; (6000774c <EDMA_CreateHandle+0xc8>)
600076b4:	f003 fa04 	bl	6000aac0 <assert_print>
600076b8:	f240 314d 	movw	r1, #845	; 0x34d
600076bc:	e7f0      	b.n	600076a0 <EDMA_CreateHandle+0x1c>
    (void)memset(handle, 0, sizeof(*handle));
600076be:	2218      	movs	r2, #24
600076c0:	2100      	movs	r1, #0
600076c2:	f003 fa64 	bl	6000ab8e <memset>
    edmaInstance = EDMA_GetInstance(base);
600076c6:	4630      	mov	r0, r6
    handle->base    = base;
600076c8:	60a6      	str	r6, [r4, #8]
    handle->channel = (uint8_t)channel;
600076ca:	7425      	strb	r5, [r4, #16]
    edmaInstance = EDMA_GetInstance(base);
600076cc:	f7ff fc92 	bl	60006ff4 <EDMA_GetInstance>
600076d0:	4606      	mov	r6, r0
    startInstanceNum = (uint8_t)EDMA_GetInstance(DMA0);
600076d2:	4820      	ldr	r0, [pc, #128]	; (60007754 <EDMA_CreateHandle+0xd0>)
600076d4:	f7ff fc8e 	bl	60006ff4 <EDMA_GetInstance>
    assert(startInstanceNum <= instance);
600076d8:	b2c3      	uxtb	r3, r0
600076da:	429e      	cmp	r6, r3
600076dc:	d209      	bcs.n	600076f2 <EDMA_CreateHandle+0x6e>
600076de:	491e      	ldr	r1, [pc, #120]	; (60007758 <EDMA_CreateHandle+0xd4>)
600076e0:	f240 333a 	movw	r3, #826	; 0x33a
600076e4:	4a18      	ldr	r2, [pc, #96]	; (60007748 <EDMA_CreateHandle+0xc4>)
600076e6:	4819      	ldr	r0, [pc, #100]	; (6000774c <EDMA_CreateHandle+0xc8>)
600076e8:	f003 f9ea 	bl	6000aac0 <assert_print>
600076ec:	f240 313a 	movw	r1, #826	; 0x33a
600076f0:	e7d6      	b.n	600076a0 <EDMA_CreateHandle+0x1c>
    return instance - startInstanceNum;
600076f2:	1af3      	subs	r3, r6, r3
    s_EDMAHandle[channelIndex] = handle;
600076f4:	4a19      	ldr	r2, [pc, #100]	; (6000775c <EDMA_CreateHandle+0xd8>)
600076f6:	eb05 1343 	add.w	r3, r5, r3, lsl #5
    (void)EnableIRQ(s_edmaIRQNumber[edmaInstance][channel]);
600076fa:	eb05 1546 	add.w	r5, r5, r6, lsl #5
    s_EDMAHandle[channelIndex] = handle;
600076fe:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
    (void)EnableIRQ(s_edmaIRQNumber[edmaInstance][channel]);
60007702:	4b17      	ldr	r3, [pc, #92]	; (60007760 <EDMA_CreateHandle+0xdc>)
60007704:	f933 3015 	ldrsh.w	r3, [r3, r5, lsl #1]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
60007708:	2b00      	cmp	r3, #0
6000770a:	db08      	blt.n	6000771e <EDMA_CreateHandle+0x9a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
6000770c:	2201      	movs	r2, #1
6000770e:	0959      	lsrs	r1, r3, #5
60007710:	f003 031f 	and.w	r3, r3, #31
60007714:	fa02 f303 	lsl.w	r3, r2, r3
60007718:	4a12      	ldr	r2, [pc, #72]	; (60007764 <EDMA_CreateHandle+0xe0>)
6000771a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    tcdRegs            = (edma_tcd_t *)(uint32_t)&handle->base->TCD[handle->channel];
6000771e:	7c23      	ldrb	r3, [r4, #16]
    tcdRegs->SADDR     = 0;
60007720:	2200      	movs	r2, #0
    tcdRegs            = (edma_tcd_t *)(uint32_t)&handle->base->TCD[handle->channel];
60007722:	68a1      	ldr	r1, [r4, #8]
60007724:	3380      	adds	r3, #128	; 0x80
60007726:	0158      	lsls	r0, r3, #5
60007728:	eb01 1343 	add.w	r3, r1, r3, lsl #5
    tcdRegs->SADDR     = 0;
6000772c:	500a      	str	r2, [r1, r0]
    tcdRegs->SOFF      = 0;
6000772e:	809a      	strh	r2, [r3, #4]
    tcdRegs->ATTR      = 0;
60007730:	80da      	strh	r2, [r3, #6]
    tcdRegs->NBYTES    = 0;
60007732:	609a      	str	r2, [r3, #8]
    tcdRegs->SLAST     = 0;
60007734:	60da      	str	r2, [r3, #12]
    tcdRegs->DADDR     = 0;
60007736:	611a      	str	r2, [r3, #16]
    tcdRegs->DOFF      = 0;
60007738:	829a      	strh	r2, [r3, #20]
    tcdRegs->CITER     = 0;
6000773a:	82da      	strh	r2, [r3, #22]
    tcdRegs->DLAST_SGA = 0;
6000773c:	619a      	str	r2, [r3, #24]
    tcdRegs->CSR       = 0;
6000773e:	839a      	strh	r2, [r3, #28]
    tcdRegs->BITER     = 0;
60007740:	83da      	strh	r2, [r3, #30]
}
60007742:	bd70      	pop	{r4, r5, r6, pc}
60007744:	6000d8ef 	.word	0x6000d8ef
60007748:	6000d6d3 	.word	0x6000d6d3
6000774c:	6000c68a 	.word	0x6000c68a
60007750:	6000d219 	.word	0x6000d219
60007754:	400e8000 	.word	0x400e8000
60007758:	6000d905 	.word	0x6000d905
6000775c:	80001630 	.word	0x80001630
60007760:	6000c508 	.word	0x6000c508
60007764:	e000e100 	.word	0xe000e100

60007768 <EDMA_InstallTCDMemory>:
{
60007768:	b510      	push	{r4, lr}
    assert(handle != NULL);
6000776a:	b958      	cbnz	r0, 60007784 <EDMA_InstallTCDMemory+0x1c>
6000776c:	4910      	ldr	r1, [pc, #64]	; (600077b0 <EDMA_InstallTCDMemory+0x48>)
6000776e:	f240 3382 	movw	r3, #898	; 0x382
60007772:	4a10      	ldr	r2, [pc, #64]	; (600077b4 <EDMA_InstallTCDMemory+0x4c>)
60007774:	4810      	ldr	r0, [pc, #64]	; (600077b8 <EDMA_InstallTCDMemory+0x50>)
60007776:	f003 f9a3 	bl	6000aac0 <assert_print>
6000777a:	f240 3182 	movw	r1, #898	; 0x382
    assert(((uint32_t)tcdPool & 0x1FU) == 0U);
6000777e:	480d      	ldr	r0, [pc, #52]	; (600077b4 <EDMA_InstallTCDMemory+0x4c>)
60007780:	f003 f997 	bl	6000aab2 <assert_post_action>
60007784:	f011 031f 	ands.w	r3, r1, #31
60007788:	d009      	beq.n	6000779e <EDMA_InstallTCDMemory+0x36>
6000778a:	490c      	ldr	r1, [pc, #48]	; (600077bc <EDMA_InstallTCDMemory+0x54>)
6000778c:	f240 3383 	movw	r3, #899	; 0x383
60007790:	4a08      	ldr	r2, [pc, #32]	; (600077b4 <EDMA_InstallTCDMemory+0x4c>)
60007792:	4809      	ldr	r0, [pc, #36]	; (600077b8 <EDMA_InstallTCDMemory+0x50>)
60007794:	f003 f994 	bl	6000aac0 <assert_print>
60007798:	f240 3183 	movw	r1, #899	; 0x383
6000779c:	e7ef      	b.n	6000777e <EDMA_InstallTCDMemory+0x16>
    handle->header  = 1;
6000779e:	2401      	movs	r4, #1
    handle->tcdSize = (int8_t)tcdSize;
600077a0:	b252      	sxtb	r2, r2
    handle->flags   = 0;
600077a2:	7543      	strb	r3, [r0, #21]
    handle->header  = 1;
600077a4:	7444      	strb	r4, [r0, #17]
    handle->tcdPool = tcdPool;
600077a6:	60c1      	str	r1, [r0, #12]
    handle->tcdUsed = 0;
600077a8:	74c3      	strb	r3, [r0, #19]
    handle->tcdSize = (int8_t)tcdSize;
600077aa:	7502      	strb	r2, [r0, #20]
}
600077ac:	bd10      	pop	{r4, pc}
600077ae:	bf00      	nop
600077b0:	6000d8ef 	.word	0x6000d8ef
600077b4:	6000d6d3 	.word	0x6000d6d3
600077b8:	6000c68a 	.word	0x6000c68a
600077bc:	6000d922 	.word	0x6000d922

600077c0 <EDMA_SetCallback>:
{
600077c0:	b508      	push	{r3, lr}
    assert(handle != NULL);
600077c2:	b958      	cbnz	r0, 600077dc <EDMA_SetCallback+0x1c>
600077c4:	4907      	ldr	r1, [pc, #28]	; (600077e4 <EDMA_SetCallback+0x24>)
600077c6:	f240 33a2 	movw	r3, #930	; 0x3a2
600077ca:	4807      	ldr	r0, [pc, #28]	; (600077e8 <EDMA_SetCallback+0x28>)
600077cc:	4a07      	ldr	r2, [pc, #28]	; (600077ec <EDMA_SetCallback+0x2c>)
600077ce:	f003 f977 	bl	6000aac0 <assert_print>
600077d2:	f240 31a2 	movw	r1, #930	; 0x3a2
600077d6:	4805      	ldr	r0, [pc, #20]	; (600077ec <EDMA_SetCallback+0x2c>)
600077d8:	f003 f96b 	bl	6000aab2 <assert_post_action>
    handle->userData = userData;
600077dc:	e9c0 1200 	strd	r1, r2, [r0]
}
600077e0:	bd08      	pop	{r3, pc}
600077e2:	bf00      	nop
600077e4:	6000d8ef 	.word	0x6000d8ef
600077e8:	6000c68a 	.word	0x6000c68a
600077ec:	6000d6d3 	.word	0x6000d6d3

600077f0 <EDMA_PrepareTransferConfig>:
                                void *destAddr,
                                uint32_t destWidth,
                                int16_t destOffset,
                                uint32_t bytesEachRequest,
                                uint32_t transferBytes)
{
600077f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
600077f4:	4615      	mov	r5, r2
600077f6:	460e      	mov	r6, r1
600077f8:	4699      	mov	r9, r3
    assert(config != NULL);
600077fa:	4604      	mov	r4, r0
{
600077fc:	e9dd 870a 	ldrd	r8, r7, [sp, #40]	; 0x28
60007800:	e9dd a20d 	ldrd	sl, r2, [sp, #52]	; 0x34
    assert(config != NULL);
60007804:	b958      	cbnz	r0, 6000781e <EDMA_PrepareTransferConfig+0x2e>
60007806:	4943      	ldr	r1, [pc, #268]	; (60007914 <EDMA_PrepareTransferConfig+0x124>)
60007808:	f44f 737c 	mov.w	r3, #1008	; 0x3f0
6000780c:	4a42      	ldr	r2, [pc, #264]	; (60007918 <EDMA_PrepareTransferConfig+0x128>)
6000780e:	4843      	ldr	r0, [pc, #268]	; (6000791c <EDMA_PrepareTransferConfig+0x12c>)
60007810:	f003 f956 	bl	6000aac0 <assert_print>
60007814:	f44f 717c 	mov.w	r1, #1008	; 0x3f0
    assert(srcAddr != NULL);
60007818:	483f      	ldr	r0, [pc, #252]	; (60007918 <EDMA_PrepareTransferConfig+0x128>)
6000781a:	f003 f94a 	bl	6000aab2 <assert_post_action>
6000781e:	b949      	cbnz	r1, 60007834 <EDMA_PrepareTransferConfig+0x44>
60007820:	493f      	ldr	r1, [pc, #252]	; (60007920 <EDMA_PrepareTransferConfig+0x130>)
60007822:	f240 33f1 	movw	r3, #1009	; 0x3f1
60007826:	4a3c      	ldr	r2, [pc, #240]	; (60007918 <EDMA_PrepareTransferConfig+0x128>)
60007828:	483c      	ldr	r0, [pc, #240]	; (6000791c <EDMA_PrepareTransferConfig+0x12c>)
6000782a:	f003 f949 	bl	6000aac0 <assert_print>
6000782e:	f240 31f1 	movw	r1, #1009	; 0x3f1
60007832:	e7f1      	b.n	60007818 <EDMA_PrepareTransferConfig+0x28>
    assert(destAddr != NULL);
60007834:	f1b8 0f00 	cmp.w	r8, #0
60007838:	d109      	bne.n	6000784e <EDMA_PrepareTransferConfig+0x5e>
6000783a:	493a      	ldr	r1, [pc, #232]	; (60007924 <EDMA_PrepareTransferConfig+0x134>)
6000783c:	f240 33f2 	movw	r3, #1010	; 0x3f2
60007840:	4a35      	ldr	r2, [pc, #212]	; (60007918 <EDMA_PrepareTransferConfig+0x128>)
60007842:	4836      	ldr	r0, [pc, #216]	; (6000791c <EDMA_PrepareTransferConfig+0x12c>)
60007844:	f003 f93c 	bl	6000aac0 <assert_print>
60007848:	f240 31f2 	movw	r1, #1010	; 0x3f2
6000784c:	e7e4      	b.n	60007818 <EDMA_PrepareTransferConfig+0x28>
    assert((srcWidth != 0U) && (srcWidth <= 32U) && ((srcWidth & (srcWidth - 1U)) == 0U));
6000784e:	1e6b      	subs	r3, r5, #1
60007850:	2b1f      	cmp	r3, #31
60007852:	d801      	bhi.n	60007858 <EDMA_PrepareTransferConfig+0x68>
60007854:	422b      	tst	r3, r5
60007856:	d009      	beq.n	6000786c <EDMA_PrepareTransferConfig+0x7c>
60007858:	4933      	ldr	r1, [pc, #204]	; (60007928 <EDMA_PrepareTransferConfig+0x138>)
6000785a:	f240 33f3 	movw	r3, #1011	; 0x3f3
6000785e:	4a2e      	ldr	r2, [pc, #184]	; (60007918 <EDMA_PrepareTransferConfig+0x128>)
60007860:	482e      	ldr	r0, [pc, #184]	; (6000791c <EDMA_PrepareTransferConfig+0x12c>)
60007862:	f003 f92d 	bl	6000aac0 <assert_print>
60007866:	f240 31f3 	movw	r1, #1011	; 0x3f3
6000786a:	e7d5      	b.n	60007818 <EDMA_PrepareTransferConfig+0x28>
    assert((destWidth != 0U) && (destWidth <= 32U) && ((destWidth & (destWidth - 1U)) == 0U));
6000786c:	1e7b      	subs	r3, r7, #1
6000786e:	2b1f      	cmp	r3, #31
60007870:	d801      	bhi.n	60007876 <EDMA_PrepareTransferConfig+0x86>
60007872:	423b      	tst	r3, r7
60007874:	d009      	beq.n	6000788a <EDMA_PrepareTransferConfig+0x9a>
60007876:	492d      	ldr	r1, [pc, #180]	; (6000792c <EDMA_PrepareTransferConfig+0x13c>)
60007878:	f44f 737d 	mov.w	r3, #1012	; 0x3f4
6000787c:	4a26      	ldr	r2, [pc, #152]	; (60007918 <EDMA_PrepareTransferConfig+0x128>)
6000787e:	4827      	ldr	r0, [pc, #156]	; (6000791c <EDMA_PrepareTransferConfig+0x12c>)
60007880:	f003 f91e 	bl	6000aac0 <assert_print>
60007884:	f44f 717d 	mov.w	r1, #1012	; 0x3f4
60007888:	e7c6      	b.n	60007818 <EDMA_PrepareTransferConfig+0x28>
    assert((transferBytes % bytesEachRequest) == 0U);
6000788a:	fbb2 fbfa 	udiv	fp, r2, sl
6000788e:	fb0a 221b 	mls	r2, sl, fp, r2
60007892:	b14a      	cbz	r2, 600078a8 <EDMA_PrepareTransferConfig+0xb8>
60007894:	4926      	ldr	r1, [pc, #152]	; (60007930 <EDMA_PrepareTransferConfig+0x140>)
60007896:	f240 33f5 	movw	r3, #1013	; 0x3f5
6000789a:	4a1f      	ldr	r2, [pc, #124]	; (60007918 <EDMA_PrepareTransferConfig+0x128>)
6000789c:	481f      	ldr	r0, [pc, #124]	; (6000791c <EDMA_PrepareTransferConfig+0x12c>)
6000789e:	f003 f90f 	bl	6000aac0 <assert_print>
600078a2:	f240 31f5 	movw	r1, #1013	; 0x3f5
600078a6:	e7b7      	b.n	60007818 <EDMA_PrepareTransferConfig+0x28>
    assert((((uint32_t)(uint32_t *)srcAddr) % srcWidth) == 0U);
600078a8:	fbb1 f3f5 	udiv	r3, r1, r5
600078ac:	fb05 1313 	mls	r3, r5, r3, r1
600078b0:	b14b      	cbz	r3, 600078c6 <EDMA_PrepareTransferConfig+0xd6>
600078b2:	4920      	ldr	r1, [pc, #128]	; (60007934 <EDMA_PrepareTransferConfig+0x144>)
600078b4:	f240 33f6 	movw	r3, #1014	; 0x3f6
600078b8:	4a17      	ldr	r2, [pc, #92]	; (60007918 <EDMA_PrepareTransferConfig+0x128>)
600078ba:	4818      	ldr	r0, [pc, #96]	; (6000791c <EDMA_PrepareTransferConfig+0x12c>)
600078bc:	f003 f900 	bl	6000aac0 <assert_print>
600078c0:	f240 31f6 	movw	r1, #1014	; 0x3f6
600078c4:	e7a8      	b.n	60007818 <EDMA_PrepareTransferConfig+0x28>
    assert((((uint32_t)(uint32_t *)destAddr) % destWidth) == 0U);
600078c6:	fbb8 f3f7 	udiv	r3, r8, r7
600078ca:	fb07 8313 	mls	r3, r7, r3, r8
600078ce:	b14b      	cbz	r3, 600078e4 <EDMA_PrepareTransferConfig+0xf4>
600078d0:	4919      	ldr	r1, [pc, #100]	; (60007938 <EDMA_PrepareTransferConfig+0x148>)
600078d2:	f240 33f7 	movw	r3, #1015	; 0x3f7
600078d6:	4a10      	ldr	r2, [pc, #64]	; (60007918 <EDMA_PrepareTransferConfig+0x128>)
600078d8:	4810      	ldr	r0, [pc, #64]	; (6000791c <EDMA_PrepareTransferConfig+0x12c>)
600078da:	f003 f8f1 	bl	6000aac0 <assert_print>
600078de:	f240 31f7 	movw	r1, #1015	; 0x3f7
600078e2:	e799      	b.n	60007818 <EDMA_PrepareTransferConfig+0x28>

    /* Initializes the configure structure to zero. */
    (void)memset(config, 0, sizeof(*config));
600078e4:	2218      	movs	r2, #24
600078e6:	2100      	movs	r1, #0
600078e8:	f003 f951 	bl	6000ab8e <memset>
    config->destAddr = (uint32_t)(uint32_t *)destAddr;
    config->srcAddr  = (uint32_t)(uint32_t *)srcAddr;
#endif /* FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET */
    config->minorLoopBytes   = bytesEachRequest;
    config->majorLoopCounts  = transferBytes / bytesEachRequest;
    config->srcTransferSize  = EDMA_TransferWidthMapping(srcWidth);
600078ec:	4628      	mov	r0, r5
    config->srcAddr  = (uint32_t)(uint32_t *)srcAddr;
600078ee:	e9c4 6800 	strd	r6, r8, [r4]
    config->majorLoopCounts  = transferBytes / bytesEachRequest;
600078f2:	e9c4 ab04 	strd	sl, fp, [r4, #16]
    config->srcTransferSize  = EDMA_TransferWidthMapping(srcWidth);
600078f6:	f7ff fb95 	bl	60007024 <EDMA_TransferWidthMapping>
600078fa:	7220      	strb	r0, [r4, #8]
    config->destTransferSize = EDMA_TransferWidthMapping(destWidth);
600078fc:	4638      	mov	r0, r7
600078fe:	f7ff fb91 	bl	60007024 <EDMA_TransferWidthMapping>
    config->destOffset       = destOffset;
60007902:	f9bd 3030 	ldrsh.w	r3, [sp, #48]	; 0x30
    config->destTransferSize = EDMA_TransferWidthMapping(destWidth);
60007906:	7260      	strb	r0, [r4, #9]
    config->destOffset       = destOffset;
60007908:	81a3      	strh	r3, [r4, #12]
    config->srcOffset        = srcOffset;
6000790a:	f8a4 900a 	strh.w	r9, [r4, #10]
}
6000790e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
60007912:	bf00      	nop
60007914:	6000d80c 	.word	0x6000d80c
60007918:	6000d6d3 	.word	0x6000d6d3
6000791c:	6000c68a 	.word	0x6000c68a
60007920:	6000d944 	.word	0x6000d944
60007924:	6000d95b 	.word	0x6000d95b
60007928:	6000d973 	.word	0x6000d973
6000792c:	6000d9c1 	.word	0x6000d9c1
60007930:	6000da13 	.word	0x6000da13
60007934:	6000da3c 	.word	0x6000da3c
60007938:	6000da6f 	.word	0x6000da6f

6000793c <EDMA_PrepareTransfer>:
                          void *destAddr,
                          uint32_t destWidth,
                          uint32_t bytesEachRequest,
                          uint32_t transferBytes,
                          edma_transfer_type_t transferType)
{
6000793c:	b5f0      	push	{r4, r5, r6, r7, lr}
6000793e:	b087      	sub	sp, #28
60007940:	461d      	mov	r5, r3
60007942:	9e0c      	ldr	r6, [sp, #48]	; 0x30
60007944:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
    assert(config != NULL);
60007948:	b958      	cbnz	r0, 60007962 <EDMA_PrepareTransfer+0x26>
6000794a:	4919      	ldr	r1, [pc, #100]	; (600079b0 <EDMA_PrepareTransfer+0x74>)
6000794c:	f240 4325 	movw	r3, #1061	; 0x425
60007950:	4a18      	ldr	r2, [pc, #96]	; (600079b4 <EDMA_PrepareTransfer+0x78>)
60007952:	4819      	ldr	r0, [pc, #100]	; (600079b8 <EDMA_PrepareTransfer+0x7c>)
60007954:	f003 f8b4 	bl	6000aac0 <assert_print>
60007958:	f240 4125 	movw	r1, #1061	; 0x425
            destOffset = 0;
            srcOffset  = 0;
            break;
        default:
            /* All the cases have been listed above, the default clause should not be reached. */
            assert(false);
6000795c:	4815      	ldr	r0, [pc, #84]	; (600079b4 <EDMA_PrepareTransfer+0x78>)
6000795e:	f003 f8a8 	bl	6000aab2 <assert_post_action>
    switch (transferType)
60007962:	2b03      	cmp	r3, #3
60007964:	d816      	bhi.n	60007994 <EDMA_PrepareTransfer+0x58>
60007966:	e8df f003 	tbb	[pc, r3]
6000796a:	1202      	.short	0x1202
6000796c:	1f0f      	.short	0x1f0f
            destOffset = (int16_t)destWidth;
6000796e:	b234      	sxth	r4, r6
            srcOffset  = (int16_t)srcWidth;
60007970:	b213      	sxth	r3, r2
            break;
    }

    EDMA_PrepareTransferConfig(config, srcAddr, srcWidth, srcOffset, destAddr, destWidth, destOffset, bytesEachRequest,
60007972:	9f0e      	ldr	r7, [sp, #56]	; 0x38
60007974:	9704      	str	r7, [sp, #16]
60007976:	9f0d      	ldr	r7, [sp, #52]	; 0x34
60007978:	e9cd 5600 	strd	r5, r6, [sp]
6000797c:	e9cd 4702 	strd	r4, r7, [sp, #8]
60007980:	f7ff ff36 	bl	600077f0 <EDMA_PrepareTransferConfig>
                               transferBytes);
}
60007984:	b007      	add	sp, #28
60007986:	bdf0      	pop	{r4, r5, r6, r7, pc}
            srcOffset  = (int16_t)srcWidth;
60007988:	b213      	sxth	r3, r2
            destOffset = 0;
6000798a:	2400      	movs	r4, #0
            break;
6000798c:	e7f1      	b.n	60007972 <EDMA_PrepareTransfer+0x36>
            destOffset = (int16_t)destWidth;
6000798e:	b234      	sxth	r4, r6
            srcOffset  = 0;
60007990:	2300      	movs	r3, #0
            break;
60007992:	e7ee      	b.n	60007972 <EDMA_PrepareTransfer+0x36>
            assert(false);
60007994:	4909      	ldr	r1, [pc, #36]	; (600079bc <EDMA_PrepareTransfer+0x80>)
60007996:	f240 433d 	movw	r3, #1085	; 0x43d
6000799a:	4a06      	ldr	r2, [pc, #24]	; (600079b4 <EDMA_PrepareTransfer+0x78>)
6000799c:	4806      	ldr	r0, [pc, #24]	; (600079b8 <EDMA_PrepareTransfer+0x7c>)
6000799e:	f003 f88f 	bl	6000aac0 <assert_print>
600079a2:	f240 413d 	movw	r1, #1085	; 0x43d
600079a6:	e7d9      	b.n	6000795c <EDMA_PrepareTransfer+0x20>
    switch (transferType)
600079a8:	2400      	movs	r4, #0
600079aa:	4623      	mov	r3, r4
600079ac:	e7e1      	b.n	60007972 <EDMA_PrepareTransfer+0x36>
600079ae:	bf00      	nop
600079b0:	6000d80c 	.word	0x6000d80c
600079b4:	6000d6d3 	.word	0x6000d6d3
600079b8:	6000c68a 	.word	0x6000c68a
600079bc:	6000d5b3 	.word	0x6000d5b3

600079c0 <EDMA_SubmitTransfer>:
 * retval kStatus_EDMA_Success It means submit transfer request succeed.
 * retval kStatus_EDMA_QueueFull It means TCD queue is full. Submit transfer request is not allowed.
 * retval kStatus_EDMA_Busy It means the given channel is busy, need to submit request later.
 */
status_t EDMA_SubmitTransfer(edma_handle_t *handle, const edma_transfer_config_t *config)
{
600079c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
600079c4:	4689      	mov	r9, r1
    assert(handle != NULL);
600079c6:	4604      	mov	r4, r0
600079c8:	b958      	cbnz	r0, 600079e2 <EDMA_SubmitTransfer+0x22>
600079ca:	4969      	ldr	r1, [pc, #420]	; (60007b70 <EDMA_SubmitTransfer+0x1b0>)
600079cc:	f240 4354 	movw	r3, #1108	; 0x454
600079d0:	4a68      	ldr	r2, [pc, #416]	; (60007b74 <EDMA_SubmitTransfer+0x1b4>)
600079d2:	4869      	ldr	r0, [pc, #420]	; (60007b78 <EDMA_SubmitTransfer+0x1b8>)
600079d4:	f003 f874 	bl	6000aac0 <assert_print>
600079d8:	f240 4154 	movw	r1, #1108	; 0x454
    assert(config != NULL);
600079dc:	4865      	ldr	r0, [pc, #404]	; (60007b74 <EDMA_SubmitTransfer+0x1b4>)
600079de:	f003 f868 	bl	6000aab2 <assert_post_action>
600079e2:	b949      	cbnz	r1, 600079f8 <EDMA_SubmitTransfer+0x38>
600079e4:	4965      	ldr	r1, [pc, #404]	; (60007b7c <EDMA_SubmitTransfer+0x1bc>)
600079e6:	f240 4355 	movw	r3, #1109	; 0x455
600079ea:	4a62      	ldr	r2, [pc, #392]	; (60007b74 <EDMA_SubmitTransfer+0x1b4>)
600079ec:	4862      	ldr	r0, [pc, #392]	; (60007b78 <EDMA_SubmitTransfer+0x1b8>)
600079ee:	f003 f867 	bl	6000aac0 <assert_print>
600079f2:	f240 4155 	movw	r1, #1109	; 0x455
600079f6:	e7f1      	b.n	600079dc <EDMA_SubmitTransfer+0x1c>

    edma_tcd_t *tcdRegs = (edma_tcd_t *)(uint32_t)&handle->base->TCD[handle->channel];

    if (handle->tcdPool == NULL)
600079f8:	68c3      	ldr	r3, [r0, #12]
    edma_tcd_t *tcdRegs = (edma_tcd_t *)(uint32_t)&handle->base->TCD[handle->channel];
600079fa:	f8d0 a008 	ldr.w	sl, [r0, #8]
600079fe:	7c05      	ldrb	r5, [r0, #16]
    if (handle->tcdPool == NULL)
60007a00:	bb63      	cbnz	r3, 60007a5c <EDMA_SubmitTransfer+0x9c>
         *    When transfer request is submitted, but no request from peripheral, that is to say channel sevice doesn't
         *    begin, if application would like to submit another transfer , then the TCD will be overwritten, since the
         *    ACTIVE is 0 and BITER = CITER, for such case, it is a scatter gather(link TCD) case actually, so
         *    application should enabled TCD pool for dynamic scatter gather mode by calling EDMA_InstallTCDMemory.
         */
        if (((handle->base->TCD[handle->channel].CSR & DMA_CSR_ACTIVE_MASK) != 0U) ||
60007a02:	eb0a 1345 	add.w	r3, sl, r5, lsl #5
60007a06:	f241 061c 	movw	r6, #4124	; 0x101c
60007a0a:	5b9a      	ldrh	r2, [r3, r6]
60007a0c:	0652      	lsls	r2, r2, #25
60007a0e:	f100 80ac 	bmi.w	60007b6a <EDMA_SubmitTransfer+0x1aa>
            (((handle->base->TCD[handle->channel].CITER_ELINKNO & DMA_CITER_ELINKNO_CITER_MASK) !=
60007a12:	f241 0216 	movw	r2, #4118	; 0x1016
              (handle->base->TCD[handle->channel].BITER_ELINKNO & DMA_BITER_ELINKNO_BITER_MASK))))
60007a16:	f241 011e 	movw	r1, #4126	; 0x101e
            (((handle->base->TCD[handle->channel].CITER_ELINKNO & DMA_CITER_ELINKNO_CITER_MASK) !=
60007a1a:	5a9a      	ldrh	r2, [r3, r2]
              (handle->base->TCD[handle->channel].BITER_ELINKNO & DMA_BITER_ELINKNO_BITER_MASK))))
60007a1c:	5a5b      	ldrh	r3, [r3, r1]
60007a1e:	4053      	eors	r3, r2
        if (((handle->base->TCD[handle->channel].CSR & DMA_CSR_ACTIVE_MASK) != 0U) ||
60007a20:	f3c3 030e 	ubfx	r3, r3, #0, #15
60007a24:	2b00      	cmp	r3, #0
60007a26:	f040 80a0 	bne.w	60007b6a <EDMA_SubmitTransfer+0x1aa>
        {
            return kStatus_EDMA_Busy;
        }
        else
        {
            EDMA_SetTransferConfig(handle->base, handle->channel, config, NULL);
60007a2a:	464a      	mov	r2, r9
60007a2c:	4629      	mov	r1, r5
60007a2e:	4650      	mov	r0, sl
60007a30:	f7ff fce0 	bl	600073f4 <EDMA_SetTransferConfig>
            /* Enable auto disable request feature */
            handle->base->TCD[handle->channel].CSR |= DMA_CSR_DREQ_MASK;
60007a34:	7c23      	ldrb	r3, [r4, #16]
60007a36:	68a2      	ldr	r2, [r4, #8]
60007a38:	eb02 1243 	add.w	r2, r2, r3, lsl #5
60007a3c:	5b93      	ldrh	r3, [r2, r6]
60007a3e:	b29b      	uxth	r3, r3
60007a40:	f043 0308 	orr.w	r3, r3, #8
60007a44:	5393      	strh	r3, [r2, r6]
            /* Enable major interrupt */
            handle->base->TCD[handle->channel].CSR |= DMA_CSR_INTMAJOR_MASK;
60007a46:	7c23      	ldrb	r3, [r4, #16]
60007a48:	68a2      	ldr	r2, [r4, #8]
60007a4a:	eb02 1243 	add.w	r2, r2, r3, lsl #5
60007a4e:	5b93      	ldrh	r3, [r2, r6]
60007a50:	b29b      	uxth	r3, r3
60007a52:	f043 0302 	orr.w	r3, r3, #2
60007a56:	5393      	strh	r3, [r2, r6]

            return kStatus_Success;
60007a58:	2000      	movs	r0, #0
60007a5a:	e00c      	b.n	60007a76 <EDMA_SubmitTransfer+0xb6>
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
60007a5c:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
60007a60:	b672      	cpsid	i
        int8_t tmpTcdUsed;
        int8_t tmpTcdSize;

        /* Check if tcd pool is full. */
        primask    = DisableGlobalIRQ();
        tmpTcdUsed = handle->tcdUsed;
60007a62:	7cc1      	ldrb	r1, [r0, #19]
        tmpTcdSize = handle->tcdSize;
60007a64:	7d03      	ldrb	r3, [r0, #20]
        tmpTcdUsed = handle->tcdUsed;
60007a66:	b249      	sxtb	r1, r1
        tmpTcdSize = handle->tcdSize;
60007a68:	b25b      	sxtb	r3, r3
        if (tmpTcdUsed >= tmpTcdSize)
60007a6a:	4299      	cmp	r1, r3
60007a6c:	db05      	blt.n	60007a7a <EDMA_SubmitTransfer+0xba>
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
60007a6e:	f382 8810 	msr	PRIMASK, r2
        {
            EnableGlobalIRQ(primask);

            return kStatus_EDMA_QueueFull;
60007a72:	f241 30ec 	movw	r0, #5100	; 0x13ec
            handle->base->SERQ = DMA_SERQ_SERQ(handle->channel);
        }

        return kStatus_Success;
    }
}
60007a76:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        currentTcd = handle->tail;
60007a7a:	7c86      	ldrb	r6, [r0, #18]
        handle->tcdUsed++;
60007a7c:	7cc3      	ldrb	r3, [r0, #19]
        nextTcd = currentTcd + 1;
60007a7e:	1c77      	adds	r7, r6, #1
        currentTcd = handle->tail;
60007a80:	fa4f fb86 	sxtb.w	fp, r6
        handle->tcdUsed++;
60007a84:	3301      	adds	r3, #1
        nextTcd = currentTcd + 1;
60007a86:	b27f      	sxtb	r7, r7
        handle->tcdUsed++;
60007a88:	b25b      	sxtb	r3, r3
60007a8a:	74c3      	strb	r3, [r0, #19]
        if (nextTcd == handle->tcdSize)
60007a8c:	7d03      	ldrb	r3, [r0, #20]
60007a8e:	b25b      	sxtb	r3, r3
            nextTcd = 0;
60007a90:	42bb      	cmp	r3, r7
60007a92:	bf08      	it	eq
60007a94:	2700      	moveq	r7, #0
        handle->tail = nextTcd;
60007a96:	7487      	strb	r7, [r0, #18]
60007a98:	f382 8810 	msr	PRIMASK, r2
        previousTcd = currentTcd != 0 ? currentTcd - 1 : (handle->tcdSize - 1);
60007a9c:	f1bb 0f00 	cmp.w	fp, #0
60007aa0:	d02f      	beq.n	60007b02 <EDMA_SubmitTransfer+0x142>
        EDMA_TcdReset(&handle->tcdPool[currentTcd]);
60007aa2:	68e0      	ldr	r0, [r4, #12]
60007aa4:	ea4f 184b 	mov.w	r8, fp, lsl #5
        previousTcd = currentTcd != 0 ? currentTcd - 1 : (handle->tcdSize - 1);
60007aa8:	3e01      	subs	r6, #1
        EDMA_TcdReset(&handle->tcdPool[currentTcd]);
60007aaa:	eb00 104b 	add.w	r0, r0, fp, lsl #5
60007aae:	f7ff fbd3 	bl	60007258 <EDMA_TcdReset>
        EDMA_TcdSetTransferConfig(&handle->tcdPool[currentTcd], config, NULL);
60007ab2:	68e0      	ldr	r0, [r4, #12]
60007ab4:	2200      	movs	r2, #0
60007ab6:	4649      	mov	r1, r9
60007ab8:	4440      	add	r0, r8
        previousTcd = currentTcd != 0 ? currentTcd - 1 : (handle->tcdSize - 1);
60007aba:	b276      	sxtb	r6, r6
        EDMA_TcdSetTransferConfig(&handle->tcdPool[currentTcd], config, NULL);
60007abc:	f7ff fc16 	bl	600072ec <EDMA_TcdSetTransferConfig>
        handle->tcdPool[currentTcd].CSR |= DMA_CSR_INTMAJOR_MASK;
60007ac0:	68e2      	ldr	r2, [r4, #12]
        if (currentTcd != previousTcd)
60007ac2:	455e      	cmp	r6, fp
        handle->tcdPool[currentTcd].CSR |= DMA_CSR_INTMAJOR_MASK;
60007ac4:	4442      	add	r2, r8
60007ac6:	8b93      	ldrh	r3, [r2, #28]
60007ac8:	b29b      	uxth	r3, r3
60007aca:	f043 0302 	orr.w	r3, r3, #2
60007ace:	8393      	strh	r3, [r2, #28]
        handle->tcdPool[currentTcd].DLAST_SGA = (uint32_t)&handle->tcdPool[nextTcd];
60007ad0:	ea4f 1247 	mov.w	r2, r7, lsl #5
60007ad4:	68e3      	ldr	r3, [r4, #12]
60007ad6:	eb03 0108 	add.w	r1, r3, r8
60007ada:	eb03 1347 	add.w	r3, r3, r7, lsl #5
60007ade:	618b      	str	r3, [r1, #24]
        if (currentTcd != previousTcd)
60007ae0:	d111      	bne.n	60007b06 <EDMA_SubmitTransfer+0x146>
        EDMA_InstallTCD(handle->base, handle->channel, &handle->tcdPool[currentTcd]);
60007ae2:	68e2      	ldr	r2, [r4, #12]
60007ae4:	7c21      	ldrb	r1, [r4, #16]
60007ae6:	4442      	add	r2, r8
60007ae8:	68a0      	ldr	r0, [r4, #8]
60007aea:	f7ff fac7 	bl	6000707c <EDMA_InstallTCD>
        if (0U != (handle->flags & EDMA_TRANSFER_ENABLED_MASK))
60007aee:	f994 3015 	ldrsb.w	r3, [r4, #21]
60007af2:	2b00      	cmp	r3, #0
60007af4:	dab0      	bge.n	60007a58 <EDMA_SubmitTransfer+0x98>
            handle->base->SERQ = DMA_SERQ_SERQ(handle->channel);
60007af6:	7c23      	ldrb	r3, [r4, #16]
60007af8:	68a2      	ldr	r2, [r4, #8]
60007afa:	f003 031f 	and.w	r3, r3, #31
60007afe:	76d3      	strb	r3, [r2, #27]
60007b00:	e7aa      	b.n	60007a58 <EDMA_SubmitTransfer+0x98>
        previousTcd = currentTcd != 0 ? currentTcd - 1 : (handle->tcdSize - 1);
60007b02:	7d06      	ldrb	r6, [r0, #20]
60007b04:	e7cd      	b.n	60007aa2 <EDMA_SubmitTransfer+0xe2>
            csr = handle->tcdPool[previousTcd].CSR | ((uint16_t)DMA_CSR_ESG_MASK);
60007b06:	68e1      	ldr	r1, [r4, #12]
    edma_tcd_t *tcdRegs = (edma_tcd_t *)(uint32_t)&handle->base->TCD[handle->channel];
60007b08:	f105 0080 	add.w	r0, r5, #128	; 0x80
            csr = handle->tcdPool[previousTcd].CSR | ((uint16_t)DMA_CSR_ESG_MASK);
60007b0c:	eb01 1146 	add.w	r1, r1, r6, lsl #5
    edma_tcd_t *tcdRegs = (edma_tcd_t *)(uint32_t)&handle->base->TCD[handle->channel];
60007b10:	eb0a 1040 	add.w	r0, sl, r0, lsl #5
            csr = handle->tcdPool[previousTcd].CSR | ((uint16_t)DMA_CSR_ESG_MASK);
60007b14:	8b8b      	ldrh	r3, [r1, #28]
60007b16:	b29b      	uxth	r3, r3
            csr &= ~((uint16_t)DMA_CSR_DREQ_MASK);
60007b18:	f023 0308 	bic.w	r3, r3, #8
60007b1c:	f043 0310 	orr.w	r3, r3, #16
            handle->tcdPool[previousTcd].CSR = csr;
60007b20:	838b      	strh	r3, [r1, #28]
            if (tcdRegs->DLAST_SGA == (uint32_t)&handle->tcdPool[currentTcd])
60007b22:	68e3      	ldr	r3, [r4, #12]
60007b24:	6981      	ldr	r1, [r0, #24]
60007b26:	4443      	add	r3, r8
60007b28:	4299      	cmp	r1, r3
60007b2a:	d119      	bne.n	60007b60 <EDMA_SubmitTransfer+0x1a0>
                tcdRegs->CSR |= DMA_CSR_DREQ_MASK;
60007b2c:	8b83      	ldrh	r3, [r0, #28]
60007b2e:	b29b      	uxth	r3, r3
60007b30:	f043 0308 	orr.w	r3, r3, #8
60007b34:	8383      	strh	r3, [r0, #28]
                csr = tcdRegs->CSR | DMA_CSR_ESG_MASK;
60007b36:	8b83      	ldrh	r3, [r0, #28]
60007b38:	b29b      	uxth	r3, r3
60007b3a:	f043 0310 	orr.w	r3, r3, #16
                tcdRegs->CSR = csr;
60007b3e:	8383      	strh	r3, [r0, #28]
                if (0U != (tcdRegs->CSR & DMA_CSR_ESG_MASK))
60007b40:	8b83      	ldrh	r3, [r0, #28]
60007b42:	06db      	lsls	r3, r3, #27
60007b44:	d506      	bpl.n	60007b54 <EDMA_SubmitTransfer+0x194>
                    tcdRegs->CSR &= ~(uint16_t)DMA_CSR_DREQ_MASK;
60007b46:	8b83      	ldrh	r3, [r0, #28]
60007b48:	f023 0308 	bic.w	r3, r3, #8
60007b4c:	041b      	lsls	r3, r3, #16
60007b4e:	0c1b      	lsrs	r3, r3, #16
60007b50:	8383      	strh	r3, [r0, #28]
                    return kStatus_Success;
60007b52:	e781      	b.n	60007a58 <EDMA_SubmitTransfer+0x98>
                if (tcdRegs->DLAST_SGA == (uint32_t)&handle->tcdPool[nextTcd])
60007b54:	68e3      	ldr	r3, [r4, #12]
60007b56:	6981      	ldr	r1, [r0, #24]
60007b58:	4413      	add	r3, r2
60007b5a:	4299      	cmp	r1, r3
60007b5c:	d1c1      	bne.n	60007ae2 <EDMA_SubmitTransfer+0x122>
60007b5e:	e77b      	b.n	60007a58 <EDMA_SubmitTransfer+0x98>
            else if (tcdRegs->DLAST_SGA != 0UL)
60007b60:	6983      	ldr	r3, [r0, #24]
60007b62:	2b00      	cmp	r3, #0
60007b64:	f47f af78 	bne.w	60007a58 <EDMA_SubmitTransfer+0x98>
60007b68:	e7bb      	b.n	60007ae2 <EDMA_SubmitTransfer+0x122>
            return kStatus_EDMA_Busy;
60007b6a:	f241 30ed 	movw	r0, #5101	; 0x13ed
60007b6e:	e782      	b.n	60007a76 <EDMA_SubmitTransfer+0xb6>
60007b70:	6000d8ef 	.word	0x6000d8ef
60007b74:	6000d6d3 	.word	0x6000d6d3
60007b78:	6000c68a 	.word	0x6000c68a
60007b7c:	6000d80c 	.word	0x6000d80c

60007b80 <EDMA_StartTransfer>:
 * or before submitting the transfer request.
 *
 * param handle eDMA handle pointer.
 */
void EDMA_StartTransfer(edma_handle_t *handle)
{
60007b80:	b570      	push	{r4, r5, r6, lr}
    assert(handle != NULL);
60007b82:	b958      	cbnz	r0, 60007b9c <EDMA_StartTransfer+0x1c>
60007b84:	4919      	ldr	r1, [pc, #100]	; (60007bec <EDMA_StartTransfer+0x6c>)
60007b86:	f240 5304 	movw	r3, #1284	; 0x504
60007b8a:	4819      	ldr	r0, [pc, #100]	; (60007bf0 <EDMA_StartTransfer+0x70>)
60007b8c:	4a19      	ldr	r2, [pc, #100]	; (60007bf4 <EDMA_StartTransfer+0x74>)
60007b8e:	f002 ff97 	bl	6000aac0 <assert_print>
60007b92:	f240 5104 	movw	r1, #1284	; 0x504
60007b96:	4817      	ldr	r0, [pc, #92]	; (60007bf4 <EDMA_StartTransfer+0x74>)
60007b98:	f002 ff8b 	bl	6000aab2 <assert_post_action>
    uint32_t tmpCSR = 0;

    if (handle->tcdPool == NULL)
60007b9c:	68c1      	ldr	r1, [r0, #12]
    {
        handle->base->SERQ = DMA_SERQ_SERQ(handle->channel);
60007b9e:	6882      	ldr	r2, [r0, #8]
60007ba0:	7c03      	ldrb	r3, [r0, #16]
    if (handle->tcdPool == NULL)
60007ba2:	b919      	cbnz	r1, 60007bac <EDMA_StartTransfer+0x2c>
        handle->base->SERQ = DMA_SERQ_SERQ(handle->channel);
60007ba4:	f003 031f 	and.w	r3, r3, #31
60007ba8:	76d3      	strb	r3, [r2, #27]
                }
            }
            EnableGlobalIRQ(primask);
        }
    }
}
60007baa:	bd70      	pop	{r4, r5, r6, pc}
        edma_tcd_t *tcdRegs = (edma_tcd_t *)(uint32_t)&handle->base->TCD[handle->channel];
60007bac:	3380      	adds	r3, #128	; 0x80
60007bae:	eb02 1343 	add.w	r3, r2, r3, lsl #5
        handle->flags |= EDMA_TRANSFER_ENABLED_MASK;
60007bb2:	7d42      	ldrb	r2, [r0, #21]
60007bb4:	f062 027f 	orn	r2, r2, #127	; 0x7f
60007bb8:	7542      	strb	r2, [r0, #21]
        if (tcdRegs->DLAST_SGA != 0U)
60007bba:	699a      	ldr	r2, [r3, #24]
60007bbc:	2a00      	cmp	r2, #0
60007bbe:	d0f4      	beq.n	60007baa <EDMA_StartTransfer+0x2a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
60007bc0:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
60007bc4:	b672      	cpsid	i
            if ((handle->base->ERQ & ((uint32_t)1U << handle->channel)) == 0U)
60007bc6:	2101      	movs	r1, #1
60007bc8:	6884      	ldr	r4, [r0, #8]
60007bca:	7c02      	ldrb	r2, [r0, #16]
60007bcc:	68e6      	ldr	r6, [r4, #12]
60007bce:	4091      	lsls	r1, r2
60007bd0:	4231      	tst	r1, r6
60007bd2:	d107      	bne.n	60007be4 <EDMA_StartTransfer+0x64>
                tmpCSR = tcdRegs->CSR;
60007bd4:	8b9b      	ldrh	r3, [r3, #28]
                if ((0U == (tmpCSR & DMA_CSR_DONE_MASK)) || (0U != (tmpCSR & DMA_CSR_ESG_MASK)))
60007bd6:	f003 0390 	and.w	r3, r3, #144	; 0x90
60007bda:	2b80      	cmp	r3, #128	; 0x80
60007bdc:	d002      	beq.n	60007be4 <EDMA_StartTransfer+0x64>
                    handle->base->SERQ = DMA_SERQ_SERQ(handle->channel);
60007bde:	f002 021f 	and.w	r2, r2, #31
60007be2:	76e2      	strb	r2, [r4, #27]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
60007be4:	f385 8810 	msr	PRIMASK, r5
}
60007be8:	e7df      	b.n	60007baa <EDMA_StartTransfer+0x2a>
60007bea:	bf00      	nop
60007bec:	6000d8ef 	.word	0x6000d8ef
60007bf0:	6000c68a 	.word	0x6000c68a
60007bf4:	6000d6d3 	.word	0x6000d6d3

60007bf8 <EDMA_StopTransfer>:
 * again to resume the transfer.
 *
 * param handle eDMA handle pointer.
 */
void EDMA_StopTransfer(edma_handle_t *handle)
{
60007bf8:	b508      	push	{r3, lr}
    assert(handle != NULL);
60007bfa:	b958      	cbnz	r0, 60007c14 <EDMA_StopTransfer+0x1c>
60007bfc:	490a      	ldr	r1, [pc, #40]	; (60007c28 <EDMA_StopTransfer+0x30>)
60007bfe:	f240 5333 	movw	r3, #1331	; 0x533
60007c02:	480a      	ldr	r0, [pc, #40]	; (60007c2c <EDMA_StopTransfer+0x34>)
60007c04:	4a0a      	ldr	r2, [pc, #40]	; (60007c30 <EDMA_StopTransfer+0x38>)
60007c06:	f002 ff5b 	bl	6000aac0 <assert_print>
60007c0a:	f240 5133 	movw	r1, #1331	; 0x533
60007c0e:	4808      	ldr	r0, [pc, #32]	; (60007c30 <EDMA_StopTransfer+0x38>)
60007c10:	f002 ff4f 	bl	6000aab2 <assert_post_action>

    handle->flags &= (~(uint8_t)EDMA_TRANSFER_ENABLED_MASK);
60007c14:	7d43      	ldrb	r3, [r0, #21]
    handle->base->CERQ = DMA_CERQ_CERQ(handle->channel);
60007c16:	6882      	ldr	r2, [r0, #8]
    handle->flags &= (~(uint8_t)EDMA_TRANSFER_ENABLED_MASK);
60007c18:	f003 037f 	and.w	r3, r3, #127	; 0x7f
60007c1c:	7543      	strb	r3, [r0, #21]
    handle->base->CERQ = DMA_CERQ_CERQ(handle->channel);
60007c1e:	7c03      	ldrb	r3, [r0, #16]
60007c20:	f003 031f 	and.w	r3, r3, #31
60007c24:	7693      	strb	r3, [r2, #26]
}
60007c26:	bd08      	pop	{r3, pc}
60007c28:	6000d8ef 	.word	0x6000d8ef
60007c2c:	6000c68a 	.word	0x6000c68a
60007c30:	6000d6d3 	.word	0x6000d6d3

60007c34 <EDMA_HandleIRQ>:
 * further details.
 *
 * param handle eDMA handle pointer.
 */
void EDMA_HandleIRQ(edma_handle_t *handle)
{
60007c34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    assert(handle != NULL);
60007c38:	4604      	mov	r4, r0
60007c3a:	b958      	cbnz	r0, 60007c54 <EDMA_HandleIRQ+0x20>
60007c3c:	4934      	ldr	r1, [pc, #208]	; (60007d10 <EDMA_HandleIRQ+0xdc>)
60007c3e:	f44f 63af 	mov.w	r3, #1400	; 0x578
60007c42:	4834      	ldr	r0, [pc, #208]	; (60007d14 <EDMA_HandleIRQ+0xe0>)
60007c44:	4a34      	ldr	r2, [pc, #208]	; (60007d18 <EDMA_HandleIRQ+0xe4>)
60007c46:	f002 ff3b 	bl	6000aac0 <assert_print>
60007c4a:	f44f 61af 	mov.w	r1, #1400	; 0x578
60007c4e:	4832      	ldr	r0, [pc, #200]	; (60007d18 <EDMA_HandleIRQ+0xe4>)
60007c50:	f002 ff2f 	bl	6000aab2 <assert_post_action>

    bool transfer_done;

    /* Clear EDMA interrupt flag */
    handle->base->CINT = handle->channel;
60007c54:	6883      	ldr	r3, [r0, #8]
    /* Check if transfer is already finished. */
    transfer_done = ((handle->base->TCD[handle->channel].CSR & DMA_CSR_DONE_MASK) != 0U);
60007c56:	f241 0e1c 	movw	lr, #4124	; 0x101c
    handle->base->CINT = handle->channel;
60007c5a:	7c06      	ldrb	r6, [r0, #16]
60007c5c:	77de      	strb	r6, [r3, #31]
    transfer_done = ((handle->base->TCD[handle->channel].CSR & DMA_CSR_DONE_MASK) != 0U);
60007c5e:	6887      	ldr	r7, [r0, #8]

    if (handle->tcdPool == NULL)
60007c60:	68c3      	ldr	r3, [r0, #12]
    transfer_done = ((handle->base->TCD[handle->channel].CSR & DMA_CSR_DONE_MASK) != 0U);
60007c62:	eb07 1c46 	add.w	ip, r7, r6, lsl #5
60007c66:	f83c 200e 	ldrh.w	r2, [ip, lr]
60007c6a:	f002 0580 	and.w	r5, r2, #128	; 0x80
60007c6e:	f3c2 12c0 	ubfx	r2, r2, #7, #1
    if (handle->tcdPool == NULL)
60007c72:	b93b      	cbnz	r3, 60007c84 <EDMA_HandleIRQ+0x50>
    {
        if (handle->callback != NULL)
60007c74:	6805      	ldr	r5, [r0, #0]
60007c76:	2d00      	cmp	r5, #0
60007c78:	d032      	beq.n	60007ce0 <EDMA_HandleIRQ+0xac>
        {
            (handle->callback)(handle, handle->userData, transfer_done, 0);
60007c7a:	46ac      	mov	ip, r5
60007c7c:	6841      	ldr	r1, [r0, #4]
            {
                handle->base->CDNE = handle->channel;
            }
        }
    }
}
60007c7e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            (handle->callback)(handle, handle->userData, transfer_done, 0);
60007c82:	4760      	bx	ip
        uint32_t sga = (uint32_t)handle->base->TCD[handle->channel].DLAST_SGA;
60007c84:	f241 0118 	movw	r1, #4120	; 0x1018
60007c88:	f85c 1001 	ldr.w	r1, [ip, r1]
        bool esg = ((handle->base->TCD[handle->channel].CSR & DMA_CSR_ESG_MASK) != 0U);
60007c8c:	f83c 000e 	ldrh.w	r0, [ip, lr]
        sga -= (uint32_t)handle->tcdPool;
60007c90:	1ac9      	subs	r1, r1, r3
        bool esg = ((handle->base->TCD[handle->channel].CSR & DMA_CSR_ESG_MASK) != 0U);
60007c92:	b280      	uxth	r0, r0
        sga_index = sga / sizeof(edma_tcd_t);
60007c94:	094b      	lsrs	r3, r1, #5
        if (transfer_done)
60007c96:	b32d      	cbz	r5, 60007ce4 <EDMA_HandleIRQ+0xb0>
            new_header = sga_index != 0U ? (uint8_t)sga_index - 1U : (uint8_t)handle->tcdSize - 1U;
60007c98:	b2db      	uxtb	r3, r3
        if (new_header == (uint8_t)handle->header)
60007c9a:	7c61      	ldrb	r1, [r4, #17]
60007c9c:	fa4f fc83 	sxtb.w	ip, r3
60007ca0:	428b      	cmp	r3, r1
60007ca2:	d128      	bne.n	60007cf6 <EDMA_HandleIRQ+0xc2>
            int8_t tmpTcdUsed = handle->tcdUsed;
60007ca4:	7ce3      	ldrb	r3, [r4, #19]
            int8_t tmpTcdSize = handle->tcdSize;
60007ca6:	7d21      	ldrb	r1, [r4, #20]
            if ((tmpTcdUsed == tmpTcdSize) || (!esg))
60007ca8:	4299      	cmp	r1, r3
60007caa:	d001      	beq.n	60007cb0 <EDMA_HandleIRQ+0x7c>
60007cac:	06c0      	lsls	r0, r0, #27
60007cae:	d42d      	bmi.n	60007d0c <EDMA_HandleIRQ+0xd8>
                tcds_done = handle->tcdUsed;
60007cb0:	7ce3      	ldrb	r3, [r4, #19]
60007cb2:	b25b      	sxtb	r3, r3
        handle->header = (int8_t)new_header;
60007cb4:	f884 c011 	strb.w	ip, [r4, #17]
        handle->tcdUsed -= (int8_t)tcds_done;
60007cb8:	7ce1      	ldrb	r1, [r4, #19]
        if (NULL != handle->callback)
60007cba:	6826      	ldr	r6, [r4, #0]
        handle->tcdUsed -= (int8_t)tcds_done;
60007cbc:	1ac9      	subs	r1, r1, r3
60007cbe:	b249      	sxtb	r1, r1
60007cc0:	74e1      	strb	r1, [r4, #19]
        if (NULL != handle->callback)
60007cc2:	b116      	cbz	r6, 60007cca <EDMA_HandleIRQ+0x96>
            (handle->callback)(handle, handle->userData, transfer_done, tcds_done);
60007cc4:	6861      	ldr	r1, [r4, #4]
60007cc6:	4620      	mov	r0, r4
60007cc8:	47b0      	blx	r6
        if (transfer_done)
60007cca:	b14d      	cbz	r5, 60007ce0 <EDMA_HandleIRQ+0xac>
            if ((handle->base->TCD[handle->channel].CSR & DMA_CSR_ESG_MASK) != 0U)
60007ccc:	68a3      	ldr	r3, [r4, #8]
60007cce:	f241 011c 	movw	r1, #4124	; 0x101c
60007cd2:	7c22      	ldrb	r2, [r4, #16]
60007cd4:	eb03 1042 	add.w	r0, r3, r2, lsl #5
60007cd8:	5a41      	ldrh	r1, [r0, r1]
60007cda:	06c9      	lsls	r1, r1, #27
60007cdc:	d500      	bpl.n	60007ce0 <EDMA_HandleIRQ+0xac>
                handle->base->CDNE = handle->channel;
60007cde:	771a      	strb	r2, [r3, #28]
}
60007ce0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            new_header = sga_index != 0U ? (uint8_t)sga_index - 1U : (uint8_t)handle->tcdSize - 1U;
60007ce4:	291f      	cmp	r1, #31
60007ce6:	d901      	bls.n	60007cec <EDMA_HandleIRQ+0xb8>
60007ce8:	3b01      	subs	r3, #1
60007cea:	e7d5      	b.n	60007c98 <EDMA_HandleIRQ+0x64>
60007cec:	7d23      	ldrb	r3, [r4, #20]
60007cee:	3b01      	subs	r3, #1
60007cf0:	f003 03ff 	and.w	r3, r3, #255	; 0xff
60007cf4:	e7d1      	b.n	60007c9a <EDMA_HandleIRQ+0x66>
            tcds_done = (int32_t)new_header - (int32_t)handle->header;
60007cf6:	7c61      	ldrb	r1, [r4, #17]
60007cf8:	b249      	sxtb	r1, r1
            if (tcds_done < 0)
60007cfa:	1a5b      	subs	r3, r3, r1
60007cfc:	d502      	bpl.n	60007d04 <EDMA_HandleIRQ+0xd0>
                tcds_done += handle->tcdSize;
60007cfe:	7d21      	ldrb	r1, [r4, #20]
60007d00:	fa43 f381 	sxtab	r3, r3, r1
            if (transfer_done)
60007d04:	2d00      	cmp	r5, #0
60007d06:	d0d5      	beq.n	60007cb4 <EDMA_HandleIRQ+0x80>
                handle->base->CDNE = handle->channel;
60007d08:	773e      	strb	r6, [r7, #28]
60007d0a:	e7d3      	b.n	60007cb4 <EDMA_HandleIRQ+0x80>
                tcds_done = 0;
60007d0c:	2300      	movs	r3, #0
60007d0e:	e7d1      	b.n	60007cb4 <EDMA_HandleIRQ+0x80>
60007d10:	6000d8ef 	.word	0x6000d8ef
60007d14:	6000c68a 	.word	0x6000c68a
60007d18:	6000d6d3 	.word	0x6000d6d3

60007d1c <DMAMUX_GetInstance.isra.0>:
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

/*******************************************************************************
 * Code
 ******************************************************************************/
static uint32_t DMAMUX_GetInstance(DMAMUX_Type *base)
60007d1c:	b508      	push	{r3, lr}
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < ARRAY_SIZE(s_dmamuxBases); instance++)
    {
        if (s_dmamuxBases[instance] == base)
60007d1e:	4b07      	ldr	r3, [pc, #28]	; (60007d3c <DMAMUX_GetInstance.isra.0+0x20>)
60007d20:	4298      	cmp	r0, r3
60007d22:	d009      	beq.n	60007d38 <DMAMUX_GetInstance.isra.0+0x1c>
        {
            break;
        }
    }

    assert(instance < ARRAY_SIZE(s_dmamuxBases));
60007d24:	4906      	ldr	r1, [pc, #24]	; (60007d40 <DMAMUX_GetInstance.isra.0+0x24>)
60007d26:	233b      	movs	r3, #59	; 0x3b
60007d28:	4806      	ldr	r0, [pc, #24]	; (60007d44 <DMAMUX_GetInstance.isra.0+0x28>)
60007d2a:	4a07      	ldr	r2, [pc, #28]	; (60007d48 <DMAMUX_GetInstance.isra.0+0x2c>)
60007d2c:	f002 fec8 	bl	6000aac0 <assert_print>
60007d30:	213b      	movs	r1, #59	; 0x3b
60007d32:	4805      	ldr	r0, [pc, #20]	; (60007d48 <DMAMUX_GetInstance.isra.0+0x2c>)
60007d34:	f002 febd 	bl	6000aab2 <assert_post_action>

    return instance;
}
60007d38:	bd08      	pop	{r3, pc}
60007d3a:	bf00      	nop
60007d3c:	400ec000 	.word	0x400ec000
60007d40:	6000daea 	.word	0x6000daea
60007d44:	6000c68a 	.word	0x6000c68a
60007d48:	6000daa4 	.word	0x6000daa4

60007d4c <DMAMUX_Init>:
 *
 * param base DMAMUX peripheral base address.
 *
 */
void DMAMUX_Init(DMAMUX_Type *base)
{
60007d4c:	b508      	push	{r3, lr}
#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    CLOCK_EnableClock(s_dmamuxClockName[DMAMUX_GetInstance(base)]);
60007d4e:	f7ff ffe5 	bl	60007d1c <DMAMUX_GetInstance.isra.0>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
60007d52:	4a07      	ldr	r2, [pc, #28]	; (60007d70 <DMAMUX_Init+0x24>)
60007d54:	f102 037c 	add.w	r3, r2, #124	; 0x7c
60007d58:	e853 3f00 	ldrex	r3, [r3]
60007d5c:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
60007d60:	f102 007c 	add.w	r0, r2, #124	; 0x7c
60007d64:	e840 3100 	strex	r1, r3, [r0]
60007d68:	2900      	cmp	r1, #0
60007d6a:	d1f3      	bne.n	60007d54 <DMAMUX_Init+0x8>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
}
60007d6c:	bd08      	pop	{r3, pc}
60007d6e:	bf00      	nop
60007d70:	400fc000 	.word	0x400fc000

60007d74 <LPSPI_CombineWriteData>:
        handle->errorCount++;
    }
}

static uint32_t LPSPI_CombineWriteData(uint8_t *txData, uint8_t bytesEachWrite, bool isByteSwap)
{
60007d74:	b510      	push	{r4, lr}
    assert(txData != NULL);
60007d76:	b958      	cbnz	r0, 60007d90 <LPSPI_CombineWriteData+0x1c>
60007d78:	491b      	ldr	r1, [pc, #108]	; (60007de8 <LPSPI_CombineWriteData+0x74>)
60007d7a:	f240 73ce 	movw	r3, #1998	; 0x7ce
60007d7e:	4a1b      	ldr	r2, [pc, #108]	; (60007dec <LPSPI_CombineWriteData+0x78>)
60007d80:	481b      	ldr	r0, [pc, #108]	; (60007df0 <LPSPI_CombineWriteData+0x7c>)
60007d82:	f002 fe9d 	bl	6000aac0 <assert_print>
60007d86:	f240 71ce 	movw	r1, #1998	; 0x7ce
                ++txData;
            }
            break;

        default:
            assert(false);
60007d8a:	4818      	ldr	r0, [pc, #96]	; (60007dec <LPSPI_CombineWriteData+0x78>)
60007d8c:	f002 fe91 	bl	6000aab2 <assert_post_action>
    switch (bytesEachWrite)
60007d90:	3901      	subs	r1, #1
60007d92:	2903      	cmp	r1, #3
60007d94:	d81d      	bhi.n	60007dd2 <LPSPI_CombineWriteData+0x5e>
60007d96:	e8df f001 	tbb	[pc, r1]
60007d9a:	0402      	.short	0x0402
60007d9c:	170a      	.short	0x170a
            wordToSend = *txData;
60007d9e:	7800      	ldrb	r0, [r0, #0]
            break;
    }
    return wordToSend;
}
60007da0:	bd10      	pop	{r4, pc}
            if (!isByteSwap)
60007da2:	8800      	ldrh	r0, [r0, #0]
60007da4:	2a00      	cmp	r2, #0
60007da6:	d0fb      	beq.n	60007da0 <LPSPI_CombineWriteData+0x2c>
                wordToSend |= *txData;
60007da8:	ba40      	rev16	r0, r0
60007daa:	b280      	uxth	r0, r0
                ++txData;
60007dac:	e7f8      	b.n	60007da0 <LPSPI_CombineWriteData+0x2c>
                wordToSend |= (unsigned)(*txData) << 8U;
60007dae:	7843      	ldrb	r3, [r0, #1]
                wordToSend = *txData;
60007db0:	7804      	ldrb	r4, [r0, #0]
                wordToSend |= (unsigned)(*txData) << 8U;
60007db2:	021b      	lsls	r3, r3, #8
                wordToSend |= (unsigned)(*txData) << 16U;
60007db4:	7881      	ldrb	r1, [r0, #2]
            if (!isByteSwap)
60007db6:	b91a      	cbnz	r2, 60007dc0 <LPSPI_CombineWriteData+0x4c>
                wordToSend |= (unsigned)(*txData) << 16U;
60007db8:	ea43 4001 	orr.w	r0, r3, r1, lsl #16
60007dbc:	4320      	orrs	r0, r4
                ++txData;
60007dbe:	e7ef      	b.n	60007da0 <LPSPI_CombineWriteData+0x2c>
                wordToSend |= (unsigned)(*txData) << 8U;
60007dc0:	ea43 4004 	orr.w	r0, r3, r4, lsl #16
                wordToSend |= *txData;
60007dc4:	4308      	orrs	r0, r1
                ++txData;
60007dc6:	e7eb      	b.n	60007da0 <LPSPI_CombineWriteData+0x2c>
                wordToSend |= (unsigned)(*txData) << 24U;
60007dc8:	6800      	ldr	r0, [r0, #0]
            if (!isByteSwap)
60007dca:	2a00      	cmp	r2, #0
60007dcc:	d0e8      	beq.n	60007da0 <LPSPI_CombineWriteData+0x2c>
                wordToSend |= (unsigned)(*txData) << 8U;
60007dce:	ba00      	rev	r0, r0
                ++txData;
60007dd0:	e7e6      	b.n	60007da0 <LPSPI_CombineWriteData+0x2c>
            assert(false);
60007dd2:	4908      	ldr	r1, [pc, #32]	; (60007df4 <LPSPI_CombineWriteData+0x80>)
60007dd4:	f640 031a 	movw	r3, #2074	; 0x81a
60007dd8:	4a04      	ldr	r2, [pc, #16]	; (60007dec <LPSPI_CombineWriteData+0x78>)
60007dda:	4805      	ldr	r0, [pc, #20]	; (60007df0 <LPSPI_CombineWriteData+0x7c>)
60007ddc:	f002 fe70 	bl	6000aac0 <assert_print>
60007de0:	f640 011a 	movw	r1, #2074	; 0x81a
60007de4:	e7d1      	b.n	60007d8a <LPSPI_CombineWriteData+0x16>
60007de6:	bf00      	nop
60007de8:	6000dbfc 	.word	0x6000dbfc
60007dec:	6000dbb8 	.word	0x6000dbb8
60007df0:	6000c68a 	.word	0x6000c68a
60007df4:	6000d5b3 	.word	0x6000d5b3

60007df8 <LPSPI_SeparateReadData>:

static void LPSPI_SeparateReadData(uint8_t *rxData, uint32_t readData, uint8_t bytesEachRead, bool isByteSwap)
{
60007df8:	b538      	push	{r3, r4, r5, lr}
    assert(rxData != NULL);
60007dfa:	b958      	cbnz	r0, 60007e14 <LPSPI_SeparateReadData+0x1c>
60007dfc:	4923      	ldr	r1, [pc, #140]	; (60007e8c <LPSPI_SeparateReadData+0x94>)
60007dfe:	f640 0322 	movw	r3, #2082	; 0x822
60007e02:	4a23      	ldr	r2, [pc, #140]	; (60007e90 <LPSPI_SeparateReadData+0x98>)
60007e04:	4823      	ldr	r0, [pc, #140]	; (60007e94 <LPSPI_SeparateReadData+0x9c>)
60007e06:	f002 fe5b 	bl	6000aac0 <assert_print>
60007e0a:	f640 0122 	movw	r1, #2082	; 0x822
                ++rxData;
            }
            break;

        default:
            assert(false);
60007e0e:	4820      	ldr	r0, [pc, #128]	; (60007e90 <LPSPI_SeparateReadData+0x98>)
60007e10:	f002 fe4f 	bl	6000aab2 <assert_post_action>
    switch (bytesEachRead)
60007e14:	3a01      	subs	r2, #1
60007e16:	2a03      	cmp	r2, #3
60007e18:	d82e      	bhi.n	60007e78 <LPSPI_SeparateReadData+0x80>
60007e1a:	e8df f002 	tbb	[pc, r2]
60007e1e:	0402      	.short	0x0402
60007e20:	1c0e      	.short	0x1c0e
            *rxData = (uint8_t)readData;
60007e22:	7001      	strb	r1, [r0, #0]
            break;
    }
}
60007e24:	bd38      	pop	{r3, r4, r5, pc}
                *rxData = (uint8_t)(readData >> 8);
60007e26:	f3c1 2207 	ubfx	r2, r1, #8, #8
            *rxData = (uint8_t)readData;
60007e2a:	b2c9      	uxtb	r1, r1
            if (!isByteSwap)
60007e2c:	b913      	cbnz	r3, 60007e34 <LPSPI_SeparateReadData+0x3c>
                *rxData = (uint8_t)readData;
60007e2e:	7001      	strb	r1, [r0, #0]
                *rxData = (uint8_t)(readData >> 8);
60007e30:	7042      	strb	r2, [r0, #1]
                ++rxData;
60007e32:	e7f7      	b.n	60007e24 <LPSPI_SeparateReadData+0x2c>
                *rxData = (uint8_t)(readData >> 8);
60007e34:	7002      	strb	r2, [r0, #0]
                *rxData = (uint8_t)readData;
60007e36:	7041      	strb	r1, [r0, #1]
                ++rxData;
60007e38:	e7f4      	b.n	60007e24 <LPSPI_SeparateReadData+0x2c>
                *rxData = (uint8_t)(readData >> 16);
60007e3a:	f3c1 4407 	ubfx	r4, r1, #16, #8
                *rxData = (uint8_t)(readData >> 8);
60007e3e:	f3c1 2207 	ubfx	r2, r1, #8, #8
            *rxData = (uint8_t)readData;
60007e42:	b2c9      	uxtb	r1, r1
            if (!isByteSwap)
60007e44:	b91b      	cbnz	r3, 60007e4e <LPSPI_SeparateReadData+0x56>
                *rxData = (uint8_t)readData;
60007e46:	7001      	strb	r1, [r0, #0]
                *rxData = (uint8_t)(readData >> 8);
60007e48:	7042      	strb	r2, [r0, #1]
                *rxData = (uint8_t)(readData >> 16);
60007e4a:	7084      	strb	r4, [r0, #2]
                ++rxData;
60007e4c:	e7ea      	b.n	60007e24 <LPSPI_SeparateReadData+0x2c>
                *rxData = (uint8_t)(readData >> 16);
60007e4e:	7004      	strb	r4, [r0, #0]
                *rxData = (uint8_t)(readData >> 8);
60007e50:	7042      	strb	r2, [r0, #1]
                *rxData = (uint8_t)readData;
60007e52:	7081      	strb	r1, [r0, #2]
                ++rxData;
60007e54:	e7e6      	b.n	60007e24 <LPSPI_SeparateReadData+0x2c>
                *rxData = (uint8_t)(readData >> 24);
60007e56:	0e0d      	lsrs	r5, r1, #24
                *rxData = (uint8_t)(readData >> 16);
60007e58:	f3c1 4407 	ubfx	r4, r1, #16, #8
                *rxData = (uint8_t)(readData >> 8);
60007e5c:	f3c1 2207 	ubfx	r2, r1, #8, #8
            *rxData = (uint8_t)readData;
60007e60:	b2c9      	uxtb	r1, r1
            if (!isByteSwap)
60007e62:	b923      	cbnz	r3, 60007e6e <LPSPI_SeparateReadData+0x76>
                *rxData = (uint8_t)readData;
60007e64:	7001      	strb	r1, [r0, #0]
                *rxData = (uint8_t)(readData >> 8);
60007e66:	7042      	strb	r2, [r0, #1]
                *rxData = (uint8_t)(readData >> 16);
60007e68:	7084      	strb	r4, [r0, #2]
                *rxData = (uint8_t)(readData >> 24);
60007e6a:	70c5      	strb	r5, [r0, #3]
                ++rxData;
60007e6c:	e7da      	b.n	60007e24 <LPSPI_SeparateReadData+0x2c>
                *rxData = (uint8_t)(readData >> 24);
60007e6e:	7005      	strb	r5, [r0, #0]
                *rxData = (uint8_t)(readData >> 16);
60007e70:	7044      	strb	r4, [r0, #1]
                *rxData = (uint8_t)(readData >> 8);
60007e72:	7082      	strb	r2, [r0, #2]
                *rxData = (uint8_t)readData;
60007e74:	70c1      	strb	r1, [r0, #3]
                ++rxData;
60007e76:	e7d5      	b.n	60007e24 <LPSPI_SeparateReadData+0x2c>
            assert(false);
60007e78:	4907      	ldr	r1, [pc, #28]	; (60007e98 <LPSPI_SeparateReadData+0xa0>)
60007e7a:	f640 036b 	movw	r3, #2155	; 0x86b
60007e7e:	4a04      	ldr	r2, [pc, #16]	; (60007e90 <LPSPI_SeparateReadData+0x98>)
60007e80:	4804      	ldr	r0, [pc, #16]	; (60007e94 <LPSPI_SeparateReadData+0x9c>)
60007e82:	f002 fe1d 	bl	6000aac0 <assert_print>
60007e86:	f640 016b 	movw	r1, #2155	; 0x86b
60007e8a:	e7c0      	b.n	60007e0e <LPSPI_SeparateReadData+0x16>
60007e8c:	6000dc12 	.word	0x6000dc12
60007e90:	6000dbb8 	.word	0x6000dbb8
60007e94:	6000c68a 	.word	0x6000c68a
60007e98:	6000d5b3 	.word	0x6000d5b3

60007e9c <LPSPI_MasterTransferFillUpTxFifo>:
{
60007e9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
60007ea0:	4606      	mov	r6, r0
    assert(handle != NULL);
60007ea2:	460c      	mov	r4, r1
60007ea4:	b959      	cbnz	r1, 60007ebe <LPSPI_MasterTransferFillUpTxFifo+0x22>
60007ea6:	4929      	ldr	r1, [pc, #164]	; (60007f4c <LPSPI_MasterTransferFillUpTxFifo+0xb0>)
60007ea8:	f240 5312 	movw	r3, #1298	; 0x512
60007eac:	4828      	ldr	r0, [pc, #160]	; (60007f50 <LPSPI_MasterTransferFillUpTxFifo+0xb4>)
60007eae:	4a29      	ldr	r2, [pc, #164]	; (60007f54 <LPSPI_MasterTransferFillUpTxFifo+0xb8>)
60007eb0:	f002 fe06 	bl	6000aac0 <assert_print>
60007eb4:	f240 5112 	movw	r1, #1298	; 0x512
60007eb8:	4826      	ldr	r0, [pc, #152]	; (60007f54 <LPSPI_MasterTransferFillUpTxFifo+0xb8>)
60007eba:	f002 fdfa 	bl	6000aab2 <assert_post_action>
    uint8_t fifoSize                = handle->fifoSize;
60007ebe:	798f      	ldrb	r7, [r1, #6]
    uint32_t writeRegRemainingTimes = handle->writeRegRemainingTimes;
60007ec0:	69c9      	ldr	r1, [r1, #28]
    uint32_t readRegRemainingTimes  = handle->readRegRemainingTimes;
60007ec2:	f8d4 9020 	ldr.w	r9, [r4, #32]
    uint8_t fifoSize                = handle->fifoSize;
60007ec6:	b2ff      	uxtb	r7, r7
    size_t txRemainingByteCount     = handle->txRemainingByteCount;
60007ec8:	6963      	ldr	r3, [r4, #20]
    uint8_t bytesEachWrite          = handle->bytesEachWrite;
60007eca:	7a25      	ldrb	r5, [r4, #8]
    bool isByteSwap                 = handle->isByteSwap;
60007ecc:	f894 8002 	ldrb.w	r8, [r4, #2]
    uint8_t bytesEachWrite          = handle->bytesEachWrite;
60007ed0:	b2ed      	uxtb	r5, r5
    bool isByteSwap                 = handle->isByteSwap;
60007ed2:	fa5f f888 	uxtb.w	r8, r8
    return ((base->FSR & LPSPI_FSR_TXCOUNT_MASK) >> LPSPI_FSR_TXCOUNT_SHIFT);
60007ed6:	6df2      	ldr	r2, [r6, #92]	; 0x5c
60007ed8:	f002 021f 	and.w	r2, r2, #31
    while ((LPSPI_GetTxFifoCount(base) < fifoSize) &&
60007edc:	4297      	cmp	r7, r2
60007ede:	d92d      	bls.n	60007f3c <LPSPI_MasterTransferFillUpTxFifo+0xa0>
           (((readRegRemainingTimes - writeRegRemainingTimes) < (uint32_t)fifoSize) || (handle->rxData == NULL)))
60007ee0:	eba9 0101 	sub.w	r1, r9, r1
    while ((LPSPI_GetTxFifoCount(base) < fifoSize) &&
60007ee4:	428f      	cmp	r7, r1
60007ee6:	d801      	bhi.n	60007eec <LPSPI_MasterTransferFillUpTxFifo+0x50>
           (((readRegRemainingTimes - writeRegRemainingTimes) < (uint32_t)fifoSize) || (handle->rxData == NULL)))
60007ee8:	6922      	ldr	r2, [r4, #16]
60007eea:	bb3a      	cbnz	r2, 60007f3c <LPSPI_MasterTransferFillUpTxFifo+0xa0>
        if (txRemainingByteCount < (size_t)bytesEachWrite)
60007eec:	429d      	cmp	r5, r3
60007eee:	d903      	bls.n	60007ef8 <LPSPI_MasterTransferFillUpTxFifo+0x5c>
            handle->bytesEachWrite = (uint8_t)txRemainingByteCount;
60007ef0:	b2db      	uxtb	r3, r3
60007ef2:	7223      	strb	r3, [r4, #8]
            bytesEachWrite         = handle->bytesEachWrite;
60007ef4:	7a25      	ldrb	r5, [r4, #8]
60007ef6:	b2ed      	uxtb	r5, r5
        if (handle->txData != NULL)
60007ef8:	68e3      	ldr	r3, [r4, #12]
60007efa:	b30b      	cbz	r3, 60007f40 <LPSPI_MasterTransferFillUpTxFifo+0xa4>
            wordToSend = LPSPI_CombineWriteData(handle->txData, bytesEachWrite, isByteSwap);
60007efc:	68e0      	ldr	r0, [r4, #12]
60007efe:	4642      	mov	r2, r8
60007f00:	4629      	mov	r1, r5
60007f02:	f7ff ff37 	bl	60007d74 <LPSPI_CombineWriteData>
            handle->txData += bytesEachWrite;
60007f06:	68e3      	ldr	r3, [r4, #12]
60007f08:	442b      	add	r3, r5
60007f0a:	60e3      	str	r3, [r4, #12]
 * @param base LPSPI peripheral address.
 * @param data The data word to be sent.
 */
static inline void LPSPI_WriteData(LPSPI_Type *base, uint32_t data)
{
    base->TDR = data;
60007f0c:	6670      	str	r0, [r6, #100]	; 0x64
        --handle->writeRegRemainingTimes;
60007f0e:	69e3      	ldr	r3, [r4, #28]
60007f10:	3b01      	subs	r3, #1
60007f12:	61e3      	str	r3, [r4, #28]
        writeRegRemainingTimes = handle->writeRegRemainingTimes;
60007f14:	69e1      	ldr	r1, [r4, #28]
        handle->txRemainingByteCount -= (size_t)bytesEachWrite;
60007f16:	6963      	ldr	r3, [r4, #20]
60007f18:	1b5b      	subs	r3, r3, r5
60007f1a:	6163      	str	r3, [r4, #20]
        txRemainingByteCount = handle->txRemainingByteCount;
60007f1c:	6963      	ldr	r3, [r4, #20]
        if (handle->txRemainingByteCount == 0U)
60007f1e:	6962      	ldr	r2, [r4, #20]
60007f20:	2a00      	cmp	r2, #0
60007f22:	d1d8      	bne.n	60007ed6 <LPSPI_MasterTransferFillUpTxFifo+0x3a>
            if (handle->isPcsContinuous)
60007f24:	7823      	ldrb	r3, [r4, #0]
60007f26:	b14b      	cbz	r3, 60007f3c <LPSPI_MasterTransferFillUpTxFifo+0xa0>
    return ((base->FSR & LPSPI_FSR_TXCOUNT_MASK) >> LPSPI_FSR_TXCOUNT_SHIFT);
60007f28:	6df3      	ldr	r3, [r6, #92]	; 0x5c
60007f2a:	f003 031f 	and.w	r3, r3, #31
                if (LPSPI_GetTxFifoCount(base) < fifoSize)
60007f2e:	429f      	cmp	r7, r3
60007f30:	d908      	bls.n	60007f44 <LPSPI_MasterTransferFillUpTxFifo+0xa8>
                    base->TCR             = (base->TCR & ~(LPSPI_TCR_CONTC_MASK));
60007f32:	6e33      	ldr	r3, [r6, #96]	; 0x60
60007f34:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
60007f38:	6633      	str	r3, [r6, #96]	; 0x60
                    handle->writeTcrInIsr = false;
60007f3a:	7062      	strb	r2, [r4, #1]
}
60007f3c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            wordToSend = handle->txBuffIfNull;
60007f40:	6aa0      	ldr	r0, [r4, #40]	; 0x28
60007f42:	e7e3      	b.n	60007f0c <LPSPI_MasterTransferFillUpTxFifo+0x70>
                    handle->writeTcrInIsr = true;
60007f44:	2301      	movs	r3, #1
60007f46:	7063      	strb	r3, [r4, #1]
60007f48:	e7f8      	b.n	60007f3c <LPSPI_MasterTransferFillUpTxFifo+0xa0>
60007f4a:	bf00      	nop
60007f4c:	6000d8ef 	.word	0x6000d8ef
60007f50:	6000c68a 	.word	0x6000c68a
60007f54:	6000dbb8 	.word	0x6000dbb8

60007f58 <CLOCK_ControlGate>:
{
    uint32_t index = ((uint32_t)name) >> 8U;
    uint32_t shift = ((uint32_t)name) & 0x1FU;
    volatile uint32_t *reg;

    assert(index <= 6UL);
60007f58:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    uint32_t index = ((uint32_t)name) >> 8U;
60007f5c:	ea4f 2210 	mov.w	r2, r0, lsr #8
{
60007f60:	b510      	push	{r4, lr}
    uint32_t shift = ((uint32_t)name) & 0x1FU;
60007f62:	f000 041f 	and.w	r4, r0, #31
    assert(index <= 6UL);
60007f66:	d30b      	bcc.n	60007f80 <CLOCK_ControlGate+0x28>
60007f68:	490d      	ldr	r1, [pc, #52]	; (60007fa0 <CLOCK_ControlGate+0x48>)
60007f6a:	f44f 63a3 	mov.w	r3, #1304	; 0x518
60007f6e:	480d      	ldr	r0, [pc, #52]	; (60007fa4 <CLOCK_ControlGate+0x4c>)
60007f70:	4a0d      	ldr	r2, [pc, #52]	; (60007fa8 <CLOCK_ControlGate+0x50>)
60007f72:	f002 fda5 	bl	6000aac0 <assert_print>
60007f76:	f44f 61a3 	mov.w	r1, #1304	; 0x518
60007f7a:	480b      	ldr	r0, [pc, #44]	; (60007fa8 <CLOCK_ControlGate+0x50>)
60007f7c:	f002 fd99 	bl	6000aab2 <assert_post_action>

    reg = (volatile uint32_t *)((uint32_t)((volatile uint32_t *)&CCM->CCGR0) + sizeof(volatile uint32_t *) * index);
60007f80:	4b0a      	ldr	r3, [pc, #40]	; (60007fac <CLOCK_ControlGate+0x54>)
    SDK_ATOMIC_LOCAL_CLEAR_AND_SET(reg, (3UL << shift), (((uint32_t)value) << shift));
60007f82:	2003      	movs	r0, #3
60007f84:	40a1      	lsls	r1, r4
    reg = (volatile uint32_t *)((uint32_t)((volatile uint32_t *)&CCM->CCGR0) + sizeof(volatile uint32_t *) * index);
60007f86:	4413      	add	r3, r2
    SDK_ATOMIC_LOCAL_CLEAR_AND_SET(reg, (3UL << shift), (((uint32_t)value) << shift));
60007f88:	40a0      	lsls	r0, r4
    reg = (volatile uint32_t *)((uint32_t)((volatile uint32_t *)&CCM->CCGR0) + sizeof(volatile uint32_t *) * index);
60007f8a:	009a      	lsls	r2, r3, #2
60007f8c:	43c0      	mvns	r0, r0
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
60007f8e:	e852 3f00 	ldrex	r3, [r2]
60007f92:	4003      	ands	r3, r0
60007f94:	430b      	orrs	r3, r1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
60007f96:	e842 3400 	strex	r4, r3, [r2]
60007f9a:	2c00      	cmp	r4, #0
60007f9c:	d1f7      	bne.n	60007f8e <CLOCK_ControlGate+0x36>
}
60007f9e:	bd10      	pop	{r4, pc}
60007fa0:	6000dc7b 	.word	0x6000dc7b
60007fa4:	6000c68a 	.word	0x6000c68a
60007fa8:	6000dc28 	.word	0x6000dc28
60007fac:	1003f01a 	.word	0x1003f01a

60007fb0 <LPSPI_MasterTransferComplete>:
{
60007fb0:	b510      	push	{r4, lr}
    assert(handle != NULL);
60007fb2:	b959      	cbnz	r1, 60007fcc <LPSPI_MasterTransferComplete+0x1c>
60007fb4:	490e      	ldr	r1, [pc, #56]	; (60007ff0 <LPSPI_MasterTransferComplete+0x40>)
60007fb6:	f240 5356 	movw	r3, #1366	; 0x556
60007fba:	480e      	ldr	r0, [pc, #56]	; (60007ff4 <LPSPI_MasterTransferComplete+0x44>)
60007fbc:	4a0e      	ldr	r2, [pc, #56]	; (60007ff8 <LPSPI_MasterTransferComplete+0x48>)
60007fbe:	f002 fd7f 	bl	6000aac0 <assert_print>
60007fc2:	f240 5156 	movw	r1, #1366	; 0x556
60007fc6:	480c      	ldr	r0, [pc, #48]	; (60007ff8 <LPSPI_MasterTransferComplete+0x48>)
60007fc8:	f002 fd73 	bl	6000aab2 <assert_post_action>
    base->IER &= ~mask;
60007fcc:	6982      	ldr	r2, [r0, #24]
60007fce:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
60007fd2:	f022 0203 	bic.w	r2, r2, #3
60007fd6:	6182      	str	r2, [r0, #24]
    handle->state = (uint8_t)kLPSPI_Idle;
60007fd8:	2200      	movs	r2, #0
    if (handle->callback != NULL)
60007fda:	6b0c      	ldr	r4, [r1, #48]	; 0x30
    handle->state = (uint8_t)kLPSPI_Idle;
60007fdc:	f881 202c 	strb.w	r2, [r1, #44]	; 0x2c
    if (handle->callback != NULL)
60007fe0:	b124      	cbz	r4, 60007fec <LPSPI_MasterTransferComplete+0x3c>
        handle->callback(base, handle, kStatus_Success, handle->userData);
60007fe2:	46a4      	mov	ip, r4
60007fe4:	6b4b      	ldr	r3, [r1, #52]	; 0x34
}
60007fe6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        handle->callback(base, handle, kStatus_Success, handle->userData);
60007fea:	4760      	bx	ip
}
60007fec:	bd10      	pop	{r4, pc}
60007fee:	bf00      	nop
60007ff0:	6000d8ef 	.word	0x6000d8ef
60007ff4:	6000c68a 	.word	0x6000c68a
60007ff8:	6000dbb8 	.word	0x6000dbb8

60007ffc <LPSPI_MasterTransferHandleIRQ>:
{
60007ffc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60008000:	4605      	mov	r5, r0
    assert(handle != NULL);
60008002:	460c      	mov	r4, r1
60008004:	b959      	cbnz	r1, 6000801e <LPSPI_MasterTransferHandleIRQ+0x22>
60008006:	4955      	ldr	r1, [pc, #340]	; (6000815c <LPSPI_MasterTransferHandleIRQ+0x160>)
60008008:	f240 53ad 	movw	r3, #1453	; 0x5ad
6000800c:	4854      	ldr	r0, [pc, #336]	; (60008160 <LPSPI_MasterTransferHandleIRQ+0x164>)
6000800e:	4a55      	ldr	r2, [pc, #340]	; (60008164 <LPSPI_MasterTransferHandleIRQ+0x168>)
60008010:	f002 fd56 	bl	6000aac0 <assert_print>
60008014:	f240 51ad 	movw	r1, #1453	; 0x5ad
60008018:	4852      	ldr	r0, [pc, #328]	; (60008164 <LPSPI_MasterTransferHandleIRQ+0x168>)
6000801a:	f002 fd4a 	bl	6000aab2 <assert_post_action>
    uint8_t bytesEachRead          = handle->bytesEachRead;
6000801e:	7a4f      	ldrb	r7, [r1, #9]
    bool isByteSwap                = handle->isByteSwap;
60008020:	f891 8002 	ldrb.w	r8, [r1, #2]
    uint32_t readRegRemainingTimes = handle->readRegRemainingTimes;
60008024:	6a0e      	ldr	r6, [r1, #32]
    uint8_t bytesEachRead          = handle->bytesEachRead;
60008026:	b2ff      	uxtb	r7, r7
    if (handle->rxData != NULL)
60008028:	690b      	ldr	r3, [r1, #16]
    bool isByteSwap                = handle->isByteSwap;
6000802a:	fa5f f888 	uxtb.w	r8, r8
    if (handle->rxData != NULL)
6000802e:	b1eb      	cbz	r3, 6000806c <LPSPI_MasterTransferHandleIRQ+0x70>
        if (handle->rxRemainingByteCount != 0U)
60008030:	698b      	ldr	r3, [r1, #24]
60008032:	b153      	cbz	r3, 6000804a <LPSPI_MasterTransferHandleIRQ+0x4e>
60008034:	6983      	ldr	r3, [r0, #24]
60008036:	f023 0302 	bic.w	r3, r3, #2
6000803a:	6183      	str	r3, [r0, #24]
    return ((base->FSR & LPSPI_FSR_RXCOUNT_MASK) >> LPSPI_FSR_RXCOUNT_SHIFT);
6000803c:	6deb      	ldr	r3, [r5, #92]	; 0x5c
            while ((LPSPI_GetRxFifoCount(base) != 0U) && (handle->rxRemainingByteCount != 0U))
6000803e:	f413 1ff8 	tst.w	r3, #2031616	; 0x1f0000
60008042:	d144      	bne.n	600080ce <LPSPI_MasterTransferHandleIRQ+0xd2>
            if (handle->rxRemainingByteCount != 0U)
60008044:	69a3      	ldr	r3, [r4, #24]
60008046:	2b00      	cmp	r3, #0
60008048:	d15d      	bne.n	60008106 <LPSPI_MasterTransferHandleIRQ+0x10a>
        if (readRegRemainingTimes <= (uint32_t)handle->rxWatermark)
6000804a:	79e3      	ldrb	r3, [r4, #7]
6000804c:	42b3      	cmp	r3, r6
6000804e:	d30d      	bcc.n	6000806c <LPSPI_MasterTransferHandleIRQ+0x70>
                        LPSPI_FCR_RXWATER((readRegRemainingTimes > 1U) ? (readRegRemainingTimes - 1U) : (0U));
60008050:	2e01      	cmp	r6, #1
            base->FCR = (base->FCR & (~LPSPI_FCR_RXWATER_MASK)) |
60008052:	6dab      	ldr	r3, [r5, #88]	; 0x58
                        LPSPI_FCR_RXWATER((readRegRemainingTimes > 1U) ? (readRegRemainingTimes - 1U) : (0U));
60008054:	bf88      	it	hi
60008056:	f106 36ff 	addhi.w	r6, r6, #4294967295	; 0xffffffff
            base->FCR = (base->FCR & (~LPSPI_FCR_RXWATER_MASK)) |
6000805a:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
                        LPSPI_FCR_RXWATER((readRegRemainingTimes > 1U) ? (readRegRemainingTimes - 1U) : (0U));
6000805e:	bf92      	itee	ls
60008060:	2600      	movls	r6, #0
60008062:	0436      	lslhi	r6, r6, #16
60008064:	f406 2670 	andhi.w	r6, r6, #983040	; 0xf0000
            base->FCR = (base->FCR & (~LPSPI_FCR_RXWATER_MASK)) |
60008068:	4333      	orrs	r3, r6
6000806a:	65ab      	str	r3, [r5, #88]	; 0x58
    if (handle->txRemainingByteCount != 0U)
6000806c:	6963      	ldr	r3, [r4, #20]
6000806e:	2b00      	cmp	r3, #0
60008070:	d053      	beq.n	6000811a <LPSPI_MasterTransferHandleIRQ+0x11e>
        if (handle->isTxMask)
60008072:	78e3      	ldrb	r3, [r4, #3]
60008074:	2b00      	cmp	r3, #0
60008076:	d04b      	beq.n	60008110 <LPSPI_MasterTransferHandleIRQ+0x114>
            base->TCR |= LPSPI_TCR_TXMSK_MASK;
60008078:	6e2b      	ldr	r3, [r5, #96]	; 0x60
6000807a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
6000807e:	662b      	str	r3, [r5, #96]	; 0x60
            if ((handle->txRemainingByteCount == (uint32_t)handle->bytesPerFrame) && (handle->isPcsContinuous))
60008080:	6962      	ldr	r2, [r4, #20]
60008082:	88a3      	ldrh	r3, [r4, #4]
60008084:	b29b      	uxth	r3, r3
60008086:	429a      	cmp	r2, r3
60008088:	d105      	bne.n	60008096 <LPSPI_MasterTransferHandleIRQ+0x9a>
6000808a:	7823      	ldrb	r3, [r4, #0]
6000808c:	b11b      	cbz	r3, 60008096 <LPSPI_MasterTransferHandleIRQ+0x9a>
                base->TCR &= ~(LPSPI_TCR_CONTC_MASK | LPSPI_TCR_CONT_MASK | LPSPI_TCR_TXMSK_MASK);
6000808e:	6e2b      	ldr	r3, [r5, #96]	; 0x60
60008090:	f423 1350 	bic.w	r3, r3, #3407872	; 0x340000
60008094:	662b      	str	r3, [r5, #96]	; 0x60
            handle->txRemainingByteCount -= (uint32_t)handle->bytesPerFrame;
60008096:	88a2      	ldrh	r2, [r4, #4]
60008098:	6963      	ldr	r3, [r4, #20]
6000809a:	b292      	uxth	r2, r2
6000809c:	1a9b      	subs	r3, r3, r2
6000809e:	6163      	str	r3, [r4, #20]
    if ((handle->txRemainingByteCount == 0U) && (handle->rxRemainingByteCount == 0U) && (!handle->writeTcrInIsr))
600080a0:	6963      	ldr	r3, [r4, #20]
600080a2:	2b00      	cmp	r3, #0
600080a4:	d158      	bne.n	60008158 <LPSPI_MasterTransferHandleIRQ+0x15c>
600080a6:	69a3      	ldr	r3, [r4, #24]
600080a8:	2b00      	cmp	r3, #0
600080aa:	d155      	bne.n	60008158 <LPSPI_MasterTransferHandleIRQ+0x15c>
600080ac:	7863      	ldrb	r3, [r4, #1]
600080ae:	2b00      	cmp	r3, #0
600080b0:	d152      	bne.n	60008158 <LPSPI_MasterTransferHandleIRQ+0x15c>
        if (handle->rxData == NULL)
600080b2:	6923      	ldr	r3, [r4, #16]
600080b4:	b92b      	cbnz	r3, 600080c2 <LPSPI_MasterTransferHandleIRQ+0xc6>
    return (base->SR);
600080b6:	696b      	ldr	r3, [r5, #20]
            if ((LPSPI_GetStatusFlags(base) & (uint32_t)kLPSPI_TransferCompleteFlag) != 0U)
600080b8:	055b      	lsls	r3, r3, #21
600080ba:	d545      	bpl.n	60008148 <LPSPI_MasterTransferHandleIRQ+0x14c>
    base->SR = statusFlags; /*!< The status flags are cleared by writing 1 (w1c).*/
600080bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
600080c0:	616b      	str	r3, [r5, #20]
            LPSPI_MasterTransferComplete(base, handle);
600080c2:	4621      	mov	r1, r4
600080c4:	4628      	mov	r0, r5
}
600080c6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            LPSPI_MasterTransferComplete(base, handle);
600080ca:	f7ff bf71 	b.w	60007fb0 <LPSPI_MasterTransferComplete>
            while ((LPSPI_GetRxFifoCount(base) != 0U) && (handle->rxRemainingByteCount != 0U))
600080ce:	69a3      	ldr	r3, [r4, #24]
600080d0:	2b00      	cmp	r3, #0
600080d2:	d0b7      	beq.n	60008044 <LPSPI_MasterTransferHandleIRQ+0x48>
 * @param base LPSPI peripheral address.
 * @return The data read from the data buffer.
 */
static inline uint32_t LPSPI_ReadData(LPSPI_Type *base)
{
    return (base->RDR);
600080d4:	6f69      	ldr	r1, [r5, #116]	; 0x74
                --handle->readRegRemainingTimes;
600080d6:	6a23      	ldr	r3, [r4, #32]
600080d8:	3b01      	subs	r3, #1
600080da:	6223      	str	r3, [r4, #32]
                readRegRemainingTimes = handle->readRegRemainingTimes;
600080dc:	6a26      	ldr	r6, [r4, #32]
                if (handle->rxRemainingByteCount < (size_t)bytesEachRead)
600080de:	69a3      	ldr	r3, [r4, #24]
600080e0:	42bb      	cmp	r3, r7
600080e2:	d204      	bcs.n	600080ee <LPSPI_MasterTransferHandleIRQ+0xf2>
                    handle->bytesEachRead = (uint8_t)(handle->rxRemainingByteCount);
600080e4:	69a3      	ldr	r3, [r4, #24]
600080e6:	b2db      	uxtb	r3, r3
600080e8:	7263      	strb	r3, [r4, #9]
                    bytesEachRead         = handle->bytesEachRead;
600080ea:	7a67      	ldrb	r7, [r4, #9]
600080ec:	b2ff      	uxtb	r7, r7
                LPSPI_SeparateReadData(handle->rxData, readData, bytesEachRead, isByteSwap);
600080ee:	4643      	mov	r3, r8
600080f0:	6920      	ldr	r0, [r4, #16]
600080f2:	463a      	mov	r2, r7
600080f4:	f7ff fe80 	bl	60007df8 <LPSPI_SeparateReadData>
                handle->rxData += bytesEachRead;
600080f8:	6923      	ldr	r3, [r4, #16]
600080fa:	443b      	add	r3, r7
600080fc:	6123      	str	r3, [r4, #16]
                handle->rxRemainingByteCount -= (size_t)bytesEachRead;
600080fe:	69a3      	ldr	r3, [r4, #24]
60008100:	1bdb      	subs	r3, r3, r7
60008102:	61a3      	str	r3, [r4, #24]
60008104:	e79a      	b.n	6000803c <LPSPI_MasterTransferHandleIRQ+0x40>
    base->IER |= mask;
60008106:	69ab      	ldr	r3, [r5, #24]
60008108:	f043 0302 	orr.w	r3, r3, #2
6000810c:	61ab      	str	r3, [r5, #24]
}
6000810e:	e79c      	b.n	6000804a <LPSPI_MasterTransferHandleIRQ+0x4e>
            LPSPI_MasterTransferFillUpTxFifo(base, handle);
60008110:	4621      	mov	r1, r4
60008112:	4628      	mov	r0, r5
60008114:	f7ff fec2 	bl	60007e9c <LPSPI_MasterTransferFillUpTxFifo>
60008118:	e7c2      	b.n	600080a0 <LPSPI_MasterTransferHandleIRQ+0xa4>
    return ((base->FSR & LPSPI_FSR_TXCOUNT_MASK) >> LPSPI_FSR_TXCOUNT_SHIFT);
6000811a:	6deb      	ldr	r3, [r5, #92]	; 0x5c
        if ((LPSPI_GetTxFifoCount(base) < (handle->fifoSize)))
6000811c:	79a2      	ldrb	r2, [r4, #6]
6000811e:	f003 031f 	and.w	r3, r3, #31
60008122:	429a      	cmp	r2, r3
60008124:	d9bc      	bls.n	600080a0 <LPSPI_MasterTransferHandleIRQ+0xa4>
            if ((handle->isPcsContinuous) && (handle->writeTcrInIsr) && (!handle->isTxMask))
60008126:	7823      	ldrb	r3, [r4, #0]
60008128:	2b00      	cmp	r3, #0
6000812a:	d0b9      	beq.n	600080a0 <LPSPI_MasterTransferHandleIRQ+0xa4>
6000812c:	7863      	ldrb	r3, [r4, #1]
6000812e:	2b00      	cmp	r3, #0
60008130:	d0b6      	beq.n	600080a0 <LPSPI_MasterTransferHandleIRQ+0xa4>
60008132:	78e3      	ldrb	r3, [r4, #3]
60008134:	f003 02ff 	and.w	r2, r3, #255	; 0xff
60008138:	2b00      	cmp	r3, #0
6000813a:	d1b1      	bne.n	600080a0 <LPSPI_MasterTransferHandleIRQ+0xa4>
                base->TCR             = (base->TCR & ~(LPSPI_TCR_CONTC_MASK));
6000813c:	6e2b      	ldr	r3, [r5, #96]	; 0x60
6000813e:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
60008142:	662b      	str	r3, [r5, #96]	; 0x60
                handle->writeTcrInIsr = false;
60008144:	7062      	strb	r2, [r4, #1]
60008146:	e7ab      	b.n	600080a0 <LPSPI_MasterTransferHandleIRQ+0xa4>
    base->IER |= mask;
60008148:	69ab      	ldr	r3, [r5, #24]
6000814a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
6000814e:	61ab      	str	r3, [r5, #24]
    base->IER &= ~mask;
60008150:	69ab      	ldr	r3, [r5, #24]
60008152:	f023 0303 	bic.w	r3, r3, #3
60008156:	61ab      	str	r3, [r5, #24]
}
60008158:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
6000815c:	6000d8ef 	.word	0x6000d8ef
60008160:	6000c68a 	.word	0x6000c68a
60008164:	6000dbb8 	.word	0x6000dbb8

60008168 <EnableIRQ.isra.0>:
  if ((int32_t)(IRQn) >= 0)
60008168:	2800      	cmp	r0, #0
6000816a:	db07      	blt.n	6000817c <EnableIRQ.isra.0+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
6000816c:	2301      	movs	r3, #1
6000816e:	0941      	lsrs	r1, r0, #5
60008170:	f000 001f 	and.w	r0, r0, #31
60008174:	4a02      	ldr	r2, [pc, #8]	; (60008180 <EnableIRQ.isra.0+0x18>)
60008176:	4083      	lsls	r3, r0
60008178:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        NVIC_EnableIRQ(interrupt);
#endif
    }

    return status;
}
6000817c:	4770      	bx	lr
6000817e:	bf00      	nop
60008180:	e000e100 	.word	0xe000e100

60008184 <LPSPI_GetInstance>:
{
60008184:	b508      	push	{r3, lr}
        if (s_lpspiBases[instance] == base)
60008186:	b1c8      	cbz	r0, 600081bc <LPSPI_GetInstance+0x38>
60008188:	4b10      	ldr	r3, [pc, #64]	; (600081cc <LPSPI_GetInstance+0x48>)
6000818a:	4298      	cmp	r0, r3
6000818c:	d015      	beq.n	600081ba <LPSPI_GetInstance+0x36>
6000818e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
60008192:	4298      	cmp	r0, r3
60008194:	d013      	beq.n	600081be <LPSPI_GetInstance+0x3a>
60008196:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
6000819a:	4298      	cmp	r0, r3
6000819c:	d011      	beq.n	600081c2 <LPSPI_GetInstance+0x3e>
6000819e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
600081a2:	4298      	cmp	r0, r3
600081a4:	d00f      	beq.n	600081c6 <LPSPI_GetInstance+0x42>
    assert(instance < ARRAY_SIZE(s_lpspiBases));
600081a6:	490a      	ldr	r1, [pc, #40]	; (600081d0 <LPSPI_GetInstance+0x4c>)
600081a8:	23a6      	movs	r3, #166	; 0xa6
600081aa:	480a      	ldr	r0, [pc, #40]	; (600081d4 <LPSPI_GetInstance+0x50>)
600081ac:	4a0a      	ldr	r2, [pc, #40]	; (600081d8 <LPSPI_GetInstance+0x54>)
600081ae:	f002 fc87 	bl	6000aac0 <assert_print>
600081b2:	21a6      	movs	r1, #166	; 0xa6
600081b4:	4808      	ldr	r0, [pc, #32]	; (600081d8 <LPSPI_GetInstance+0x54>)
600081b6:	f002 fc7c 	bl	6000aab2 <assert_post_action>
    for (instance = 0; instance < ARRAY_SIZE(s_lpspiBases); instance++)
600081ba:	2001      	movs	r0, #1
}
600081bc:	bd08      	pop	{r3, pc}
    for (instance = 0; instance < ARRAY_SIZE(s_lpspiBases); instance++)
600081be:	2002      	movs	r0, #2
600081c0:	e7fc      	b.n	600081bc <LPSPI_GetInstance+0x38>
600081c2:	2003      	movs	r0, #3
600081c4:	e7fa      	b.n	600081bc <LPSPI_GetInstance+0x38>
600081c6:	2004      	movs	r0, #4
600081c8:	e7f8      	b.n	600081bc <LPSPI_GetInstance+0x38>
600081ca:	bf00      	nop
600081cc:	40394000 	.word	0x40394000
600081d0:	6000dc88 	.word	0x6000dc88
600081d4:	6000c68a 	.word	0x6000c68a
600081d8:	6000dbb8 	.word	0x6000dbb8

600081dc <LPSPI_SetDummyData>:
{
600081dc:	b510      	push	{r4, lr}
600081de:	460c      	mov	r4, r1
    uint32_t instance          = LPSPI_GetInstance(base);
600081e0:	f7ff ffd0 	bl	60008184 <LPSPI_GetInstance>
    g_lpspiDummyData[instance] = dummyData;
600081e4:	4b01      	ldr	r3, [pc, #4]	; (600081ec <LPSPI_SetDummyData+0x10>)
600081e6:	541c      	strb	r4, [r3, r0]
}
600081e8:	bd10      	pop	{r4, pc}
600081ea:	bf00      	nop
600081ec:	8000170d 	.word	0x8000170d

600081f0 <LPSPI_MasterGetDefaultConfig>:
{
600081f0:	b510      	push	{r4, lr}
    assert(masterConfig != NULL);
600081f2:	4604      	mov	r4, r0
600081f4:	b958      	cbnz	r0, 6000820e <LPSPI_MasterGetDefaultConfig+0x1e>
600081f6:	490f      	ldr	r1, [pc, #60]	; (60008234 <LPSPI_MasterGetDefaultConfig+0x44>)
600081f8:	f240 1303 	movw	r3, #259	; 0x103
600081fc:	480e      	ldr	r0, [pc, #56]	; (60008238 <LPSPI_MasterGetDefaultConfig+0x48>)
600081fe:	4a0f      	ldr	r2, [pc, #60]	; (6000823c <LPSPI_MasterGetDefaultConfig+0x4c>)
60008200:	f002 fc5e 	bl	6000aac0 <assert_print>
60008204:	f240 1103 	movw	r1, #259	; 0x103
60008208:	480c      	ldr	r0, [pc, #48]	; (6000823c <LPSPI_MasterGetDefaultConfig+0x4c>)
6000820a:	f002 fc52 	bl	6000aab2 <assert_post_action>
    (void)memset(masterConfig, 0, sizeof(*masterConfig));
6000820e:	221c      	movs	r2, #28
60008210:	2100      	movs	r1, #0
60008212:	f002 fcbc 	bl	6000ab8e <memset>
    masterConfig->bitsPerFrame = 8;
60008216:	4a0a      	ldr	r2, [pc, #40]	; (60008240 <LPSPI_MasterGetDefaultConfig+0x50>)
60008218:	2308      	movs	r3, #8
6000821a:	e9c4 2300 	strd	r2, r3, [r4]
    masterConfig->cpol         = kLPSPI_ClockPolarityActiveHigh;
6000821e:	2300      	movs	r3, #0
    masterConfig->pcsToSckDelayInNanoSec        = 1000000000U / masterConfig->baudRate * 2U;
60008220:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
    masterConfig->cpol         = kLPSPI_ClockPolarityActiveHigh;
60008224:	8123      	strh	r3, [r4, #8]
    masterConfig->direction    = kLPSPI_MsbFirst;
60008226:	72a3      	strb	r3, [r4, #10]
    masterConfig->lastSckToPcsDelayInNanoSec    = 1000000000U / masterConfig->baudRate * 2U;
60008228:	e9c4 2203 	strd	r2, r2, [r4, #12]
    masterConfig->whichPcs           = kLPSPI_Pcs0;
6000822c:	e9c4 2305 	strd	r2, r3, [r4, #20]
}
60008230:	bd10      	pop	{r4, pc}
60008232:	bf00      	nop
60008234:	6000dd52 	.word	0x6000dd52
60008238:	6000c68a 	.word	0x6000c68a
6000823c:	6000dbb8 	.word	0x6000dbb8
60008240:	0007a120 	.word	0x0007a120

60008244 <LPSPI_MasterSetBaudRate>:
{
60008244:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
60008248:	4604      	mov	r4, r0
    assert(tcrPrescaleValue != NULL);
6000824a:	e9cd 3200 	strd	r3, r2, [sp]
6000824e:	b95b      	cbnz	r3, 60008268 <LPSPI_MasterSetBaudRate+0x24>
60008250:	492a      	ldr	r1, [pc, #168]	; (600082fc <LPSPI_MasterSetBaudRate+0xb8>)
60008252:	f240 13b1 	movw	r3, #433	; 0x1b1
60008256:	482a      	ldr	r0, [pc, #168]	; (60008300 <LPSPI_MasterSetBaudRate+0xbc>)
60008258:	4a2a      	ldr	r2, [pc, #168]	; (60008304 <LPSPI_MasterSetBaudRate+0xc0>)
6000825a:	f002 fc31 	bl	6000aac0 <assert_print>
6000825e:	f240 11b1 	movw	r1, #433	; 0x1b1
60008262:	4828      	ldr	r0, [pc, #160]	; (60008304 <LPSPI_MasterSetBaudRate+0xc0>)
60008264:	f002 fc25 	bl	6000aab2 <assert_post_action>
    return (bool)((base->CFGR1) & LPSPI_CFGR1_MASTER_MASK);
60008268:	6a40      	ldr	r0, [r0, #36]	; 0x24
    if ((!LPSPI_IsMaster(base)) || ((base->CR & LPSPI_CR_MEN_MASK) != 0U))
6000826a:	f010 0001 	ands.w	r0, r0, #1
6000826e:	d03b      	beq.n	600082e8 <LPSPI_MasterSetBaudRate+0xa4>
60008270:	6920      	ldr	r0, [r4, #16]
60008272:	f010 0001 	ands.w	r0, r0, #1
60008276:	d13e      	bne.n	600082f6 <LPSPI_MasterSetBaudRate+0xb2>
60008278:	f8df b08c 	ldr.w	fp, [pc, #140]	; 60008308 <LPSPI_MasterSetBaudRate+0xc4>
    for (prescaler = 0U; prescaler < 8U; prescaler++)
6000827c:	4605      	mov	r5, r0
    bestScaler    = 255;
6000827e:	23ff      	movs	r3, #255	; 0xff
    bestPrescaler = 7;
60008280:	2707      	movs	r7, #7
    min_diff = 0xFFFFFFFFU;
60008282:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
            realBaudrate = (srcClock_Hz / (s_baudratePrescaler[prescaler] * (scaler + 2U)));
60008286:	f81b ab01 	ldrb.w	sl, [fp], #1
6000828a:	469e      	mov	lr, r3
6000828c:	4680      	mov	r8, r0
        for (scaler = 0U; scaler < 256U; scaler++)
6000828e:	2300      	movs	r3, #0
60008290:	ea4f 064a 	mov.w	r6, sl, lsl #1
            if (min_diff == 0U)
60008294:	4694      	mov	ip, r2
            realBaudrate = (srcClock_Hz / (s_baudratePrescaler[prescaler] * (scaler + 2U)));
60008296:	9a01      	ldr	r2, [sp, #4]
60008298:	f103 0901 	add.w	r9, r3, #1
6000829c:	fbb2 f0f6 	udiv	r0, r2, r6
            if (desiredBaudrate >= realBaudrate)
600082a0:	4281      	cmp	r1, r0
600082a2:	d302      	bcc.n	600082aa <LPSPI_MasterSetBaudRate+0x66>
                diff = desiredBaudrate - realBaudrate;
600082a4:	1a0a      	subs	r2, r1, r0
                if (min_diff > diff)
600082a6:	4562      	cmp	r2, ip
600082a8:	d30e      	bcc.n	600082c8 <LPSPI_MasterSetBaudRate+0x84>
        for (scaler = 0U; scaler < 256U; scaler++)
600082aa:	f5b9 7f80 	cmp.w	r9, #256	; 0x100
600082ae:	d01e      	beq.n	600082ee <LPSPI_MasterSetBaudRate+0xaa>
            if (min_diff == 0U)
600082b0:	4456      	add	r6, sl
600082b2:	4662      	mov	r2, ip
600082b4:	4640      	mov	r0, r8
600082b6:	4673      	mov	r3, lr
600082b8:	e002      	b.n	600082c0 <LPSPI_MasterSetBaudRate+0x7c>
600082ba:	4456      	add	r6, sl
600082bc:	462f      	mov	r7, r5
600082be:	b13a      	cbz	r2, 600082d0 <LPSPI_MasterSetBaudRate+0x8c>
600082c0:	469e      	mov	lr, r3
600082c2:	4680      	mov	r8, r0
600082c4:	464b      	mov	r3, r9
600082c6:	e7e5      	b.n	60008294 <LPSPI_MasterSetBaudRate+0x50>
        for (scaler = 0U; scaler < 256U; scaler++)
600082c8:	f5b9 7f80 	cmp.w	r9, #256	; 0x100
600082cc:	d1f5      	bne.n	600082ba <LPSPI_MasterSetBaudRate+0x76>
600082ce:	462f      	mov	r7, r5
    for (prescaler = 0U; prescaler < 8U; prescaler++)
600082d0:	3501      	adds	r5, #1
600082d2:	2d08      	cmp	r5, #8
600082d4:	d001      	beq.n	600082da <LPSPI_MasterSetBaudRate+0x96>
        if (min_diff == 0U)
600082d6:	2a00      	cmp	r2, #0
600082d8:	d1d5      	bne.n	60008286 <LPSPI_MasterSetBaudRate+0x42>
    base->CCR = (base->CCR & ~LPSPI_CCR_SCKDIV_MASK) | LPSPI_CCR_SCKDIV(bestScaler);
600082da:	6c22      	ldr	r2, [r4, #64]	; 0x40
600082dc:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
600082e0:	4313      	orrs	r3, r2
600082e2:	6423      	str	r3, [r4, #64]	; 0x40
    *tcrPrescaleValue = bestPrescaler;
600082e4:	9b00      	ldr	r3, [sp, #0]
600082e6:	601f      	str	r7, [r3, #0]
}
600082e8:	b003      	add	sp, #12
600082ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for (scaler = 0U; scaler < 256U; scaler++)
600082ee:	4640      	mov	r0, r8
600082f0:	4673      	mov	r3, lr
600082f2:	4662      	mov	r2, ip
600082f4:	e7ec      	b.n	600082d0 <LPSPI_MasterSetBaudRate+0x8c>
        return 0U;
600082f6:	2000      	movs	r0, #0
600082f8:	e7f6      	b.n	600082e8 <LPSPI_MasterSetBaudRate+0xa4>
600082fa:	bf00      	nop
600082fc:	6000dd6e 	.word	0x6000dd6e
60008300:	6000c68a 	.word	0x6000c68a
60008304:	6000dbb8 	.word	0x6000dbb8
60008308:	6000dda6 	.word	0x6000dda6

6000830c <LPSPI_MasterSetDelayScaler>:
    switch (whichDelay)
6000830c:	2a02      	cmp	r2, #2
{
6000830e:	b508      	push	{r3, lr}
    switch (whichDelay)
60008310:	d00c      	beq.n	6000832c <LPSPI_MasterSetDelayScaler+0x20>
60008312:	2a03      	cmp	r2, #3
60008314:	d011      	beq.n	6000833a <LPSPI_MasterSetDelayScaler+0x2e>
60008316:	2a01      	cmp	r2, #1
60008318:	d115      	bne.n	60008346 <LPSPI_MasterSetDelayScaler+0x3a>
            base->CCR = (base->CCR & (~LPSPI_CCR_PCSSCK_MASK)) | LPSPI_CCR_PCSSCK(scaler);
6000831a:	6c03      	ldr	r3, [r0, #64]	; 0x40
6000831c:	0409      	lsls	r1, r1, #16
6000831e:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
60008322:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
            base->CCR = (base->CCR & (~LPSPI_CCR_DBT_MASK)) | LPSPI_CCR_DBT(scaler);
60008326:	4319      	orrs	r1, r3
60008328:	6401      	str	r1, [r0, #64]	; 0x40
            break;
6000832a:	e005      	b.n	60008338 <LPSPI_MasterSetDelayScaler+0x2c>
            base->CCR = (base->CCR & (~LPSPI_CCR_SCKPCS_MASK)) | LPSPI_CCR_SCKPCS(scaler);
6000832c:	6c03      	ldr	r3, [r0, #64]	; 0x40
6000832e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
60008332:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
60008336:	6403      	str	r3, [r0, #64]	; 0x40
}
60008338:	bd08      	pop	{r3, pc}
            base->CCR = (base->CCR & (~LPSPI_CCR_DBT_MASK)) | LPSPI_CCR_DBT(scaler);
6000833a:	6c03      	ldr	r3, [r0, #64]	; 0x40
6000833c:	0209      	lsls	r1, r1, #8
6000833e:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
60008342:	b289      	uxth	r1, r1
60008344:	e7ef      	b.n	60008326 <LPSPI_MasterSetDelayScaler+0x1a>
            assert(false);
60008346:	4906      	ldr	r1, [pc, #24]	; (60008360 <LPSPI_MasterSetDelayScaler+0x54>)
60008348:	f44f 7311 	mov.w	r3, #580	; 0x244
6000834c:	4805      	ldr	r0, [pc, #20]	; (60008364 <LPSPI_MasterSetDelayScaler+0x58>)
6000834e:	4a06      	ldr	r2, [pc, #24]	; (60008368 <LPSPI_MasterSetDelayScaler+0x5c>)
60008350:	f002 fbb6 	bl	6000aac0 <assert_print>
60008354:	f44f 7111 	mov.w	r1, #580	; 0x244
60008358:	4803      	ldr	r0, [pc, #12]	; (60008368 <LPSPI_MasterSetDelayScaler+0x5c>)
6000835a:	f002 fbaa 	bl	6000aab2 <assert_post_action>
6000835e:	bf00      	nop
60008360:	6000d5b3 	.word	0x6000d5b3
60008364:	6000c68a 	.word	0x6000c68a
60008368:	6000dbb8 	.word	0x6000dbb8

6000836c <LPSPI_MasterInit>:
{
6000836c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
60008370:	4604      	mov	r4, r0
60008372:	4616      	mov	r6, r2
    assert(masterConfig != NULL);
60008374:	460d      	mov	r5, r1
60008376:	b949      	cbnz	r1, 6000838c <LPSPI_MasterInit+0x20>
60008378:	493a      	ldr	r1, [pc, #232]	; (60008464 <LPSPI_MasterInit+0xf8>)
6000837a:	23c4      	movs	r3, #196	; 0xc4
6000837c:	483a      	ldr	r0, [pc, #232]	; (60008468 <LPSPI_MasterInit+0xfc>)
6000837e:	4a3b      	ldr	r2, [pc, #236]	; (6000846c <LPSPI_MasterInit+0x100>)
60008380:	f002 fb9e 	bl	6000aac0 <assert_print>
60008384:	21c4      	movs	r1, #196	; 0xc4
60008386:	4839      	ldr	r0, [pc, #228]	; (6000846c <LPSPI_MasterInit+0x100>)
60008388:	f002 fb93 	bl	6000aab2 <assert_post_action>
    uint32_t tcrPrescaleValue = 0;
6000838c:	2700      	movs	r7, #0
    cfgr1Value = base->CFGR1 & ~(1UL << (LPSPI_CFGR1_PCSPOL_SHIFT + (uint32_t)pcs));
6000838e:	f04f 0801 	mov.w	r8, #1
    uint32_t tcrPrescaleValue = 0;
60008392:	9701      	str	r7, [sp, #4]
    uint32_t instance = LPSPI_GetInstance(base);
60008394:	f7ff fef6 	bl	60008184 <LPSPI_GetInstance>
 *
 * @param name  Which clock to enable, see \ref clock_ip_name_t.
 */
static inline void CLOCK_EnableClock(clock_ip_name_t name)
{
    CLOCK_ControlGate(name, kCLOCK_ClockNeededRunWait);
60008398:	4b35      	ldr	r3, [pc, #212]	; (60008470 <LPSPI_MasterInit+0x104>)
6000839a:	2103      	movs	r1, #3
6000839c:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
600083a0:	f7ff fdda 	bl	60007f58 <CLOCK_ControlGate>
    base->CFGR1 = (base->CFGR1 & (~LPSPI_CFGR1_MASTER_MASK)) | LPSPI_CFGR1_MASTER(mode);
600083a4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    (void)LPSPI_MasterSetBaudRate(base, masterConfig->baudRate, srcClock_Hz, &tcrPrescaleValue);
600083a6:	4620      	mov	r0, r4
600083a8:	f043 0301 	orr.w	r3, r3, #1
600083ac:	6263      	str	r3, [r4, #36]	; 0x24
    cfgr1Value = base->CFGR1 & ~(1UL << (LPSPI_CFGR1_PCSPOL_SHIFT + (uint32_t)pcs));
600083ae:	7e2a      	ldrb	r2, [r5, #24]
600083b0:	6a63      	ldr	r3, [r4, #36]	; 0x24
600083b2:	3208      	adds	r2, #8
600083b4:	fa08 f102 	lsl.w	r1, r8, r2
600083b8:	ea23 0301 	bic.w	r3, r3, r1
    base->CFGR1 = cfgr1Value | ((uint32_t)activeLowOrHigh << (LPSPI_CFGR1_PCSPOL_SHIFT + (uint32_t)pcs));
600083bc:	7e69      	ldrb	r1, [r5, #25]
600083be:	fa01 f202 	lsl.w	r2, r1, r2
600083c2:	4313      	orrs	r3, r2
600083c4:	6263      	str	r3, [r4, #36]	; 0x24
                  LPSPI_CFGR1_OUTCFG(masterConfig->dataOutConfig) | LPSPI_CFGR1_PINCFG(masterConfig->pinCfg) |
600083c6:	7eeb      	ldrb	r3, [r5, #27]
600083c8:	7ea9      	ldrb	r1, [r5, #26]
    base->CFGR1 = (base->CFGR1 & ~(LPSPI_CFGR1_OUTCFG_MASK | LPSPI_CFGR1_PINCFG_MASK | LPSPI_CFGR1_NOSTALL_MASK)) |
600083ca:	6a62      	ldr	r2, [r4, #36]	; 0x24
                  LPSPI_CFGR1_OUTCFG(masterConfig->dataOutConfig) | LPSPI_CFGR1_PINCFG(masterConfig->pinCfg) |
600083cc:	069b      	lsls	r3, r3, #26
600083ce:	0609      	lsls	r1, r1, #24
600083d0:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
    base->CFGR1 = (base->CFGR1 & ~(LPSPI_CFGR1_OUTCFG_MASK | LPSPI_CFGR1_PINCFG_MASK | LPSPI_CFGR1_NOSTALL_MASK)) |
600083d4:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
                  LPSPI_CFGR1_OUTCFG(masterConfig->dataOutConfig) | LPSPI_CFGR1_PINCFG(masterConfig->pinCfg) |
600083d8:	f001 7140 	and.w	r1, r1, #50331648	; 0x3000000
    base->CFGR1 = (base->CFGR1 & ~(LPSPI_CFGR1_OUTCFG_MASK | LPSPI_CFGR1_PINCFG_MASK | LPSPI_CFGR1_NOSTALL_MASK)) |
600083dc:	f022 0208 	bic.w	r2, r2, #8
                  LPSPI_CFGR1_OUTCFG(masterConfig->dataOutConfig) | LPSPI_CFGR1_PINCFG(masterConfig->pinCfg) |
600083e0:	430b      	orrs	r3, r1
600083e2:	4313      	orrs	r3, r2
    (void)LPSPI_MasterSetBaudRate(base, masterConfig->baudRate, srcClock_Hz, &tcrPrescaleValue);
600083e4:	4632      	mov	r2, r6
    base->CFGR1 = (base->CFGR1 & ~(LPSPI_CFGR1_OUTCFG_MASK | LPSPI_CFGR1_PINCFG_MASK | LPSPI_CFGR1_NOSTALL_MASK)) |
600083e6:	6263      	str	r3, [r4, #36]	; 0x24
    (void)LPSPI_MasterSetBaudRate(base, masterConfig->baudRate, srcClock_Hz, &tcrPrescaleValue);
600083e8:	ab01      	add	r3, sp, #4
600083ea:	6829      	ldr	r1, [r5, #0]
600083ec:	f7ff ff2a 	bl	60008244 <LPSPI_MasterSetBaudRate>
    base->FCR = LPSPI_FCR_TXWATER(txWater) | LPSPI_FCR_RXWATER(rxWater);
600083f0:	65a7      	str	r7, [r4, #88]	; 0x58
                LPSPI_TCR_LSBF(masterConfig->direction) | LPSPI_TCR_FRAMESZ(masterConfig->bitsPerFrame - 1U) |
600083f2:	6869      	ldr	r1, [r5, #4]
    (void)LPSPI_MasterSetDelayTimes(base, masterConfig->pcsToSckDelayInNanoSec, kLPSPI_PcsToSck, srcClock_Hz);
600083f4:	4642      	mov	r2, r8
    base->TCR = LPSPI_TCR_CPOL(masterConfig->cpol) | LPSPI_TCR_CPHA(masterConfig->cpha) |
600083f6:	7a2b      	ldrb	r3, [r5, #8]
    (void)LPSPI_MasterSetDelayTimes(base, masterConfig->pcsToSckDelayInNanoSec, kLPSPI_PcsToSck, srcClock_Hz);
600083f8:	4620      	mov	r0, r4
                LPSPI_TCR_LSBF(masterConfig->direction) | LPSPI_TCR_FRAMESZ(masterConfig->bitsPerFrame - 1U) |
600083fa:	3901      	subs	r1, #1
600083fc:	f3c1 010b 	ubfx	r1, r1, #0, #12
60008400:	ea41 71c3 	orr.w	r1, r1, r3, lsl #31
                LPSPI_TCR_PRESCALE(tcrPrescaleValue) | LPSPI_TCR_PCS(masterConfig->whichPcs);
60008404:	9b01      	ldr	r3, [sp, #4]
60008406:	06db      	lsls	r3, r3, #27
60008408:	f003 5360 	and.w	r3, r3, #939524096	; 0x38000000
                LPSPI_TCR_LSBF(masterConfig->direction) | LPSPI_TCR_FRAMESZ(masterConfig->bitsPerFrame - 1U) |
6000840c:	4319      	orrs	r1, r3
    base->TCR = LPSPI_TCR_CPOL(masterConfig->cpol) | LPSPI_TCR_CPHA(masterConfig->cpha) |
6000840e:	7a6b      	ldrb	r3, [r5, #9]
60008410:	079b      	lsls	r3, r3, #30
60008412:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
                LPSPI_TCR_LSBF(masterConfig->direction) | LPSPI_TCR_FRAMESZ(masterConfig->bitsPerFrame - 1U) |
60008416:	4319      	orrs	r1, r3
60008418:	7aab      	ldrb	r3, [r5, #10]
6000841a:	05db      	lsls	r3, r3, #23
6000841c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
60008420:	4319      	orrs	r1, r3
                LPSPI_TCR_PRESCALE(tcrPrescaleValue) | LPSPI_TCR_PCS(masterConfig->whichPcs);
60008422:	7e2b      	ldrb	r3, [r5, #24]
60008424:	061b      	lsls	r3, r3, #24
60008426:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
6000842a:	4319      	orrs	r1, r3
    base->TCR = LPSPI_TCR_CPOL(masterConfig->cpol) | LPSPI_TCR_CPHA(masterConfig->cpha) |
6000842c:	6621      	str	r1, [r4, #96]	; 0x60
        base->CR |= LPSPI_CR_MEN_MASK;
6000842e:	6923      	ldr	r3, [r4, #16]
60008430:	ea43 0308 	orr.w	r3, r3, r8
60008434:	6123      	str	r3, [r4, #16]
    (void)LPSPI_MasterSetDelayTimes(base, masterConfig->pcsToSckDelayInNanoSec, kLPSPI_PcsToSck, srcClock_Hz);
60008436:	4633      	mov	r3, r6
60008438:	68e9      	ldr	r1, [r5, #12]
6000843a:	f7fb fc89 	bl	60003d50 <LPSPI_MasterSetDelayTimes>
    (void)LPSPI_MasterSetDelayTimes(base, masterConfig->lastSckToPcsDelayInNanoSec, kLPSPI_LastSckToPcs, srcClock_Hz);
6000843e:	4633      	mov	r3, r6
60008440:	6929      	ldr	r1, [r5, #16]
60008442:	2202      	movs	r2, #2
60008444:	4620      	mov	r0, r4
60008446:	f7fb fc83 	bl	60003d50 <LPSPI_MasterSetDelayTimes>
    (void)LPSPI_MasterSetDelayTimes(base, masterConfig->betweenTransferDelayInNanoSec, kLPSPI_BetweenTransfer,
6000844a:	6969      	ldr	r1, [r5, #20]
6000844c:	4633      	mov	r3, r6
6000844e:	2203      	movs	r2, #3
60008450:	4620      	mov	r0, r4
60008452:	f7fb fc7d 	bl	60003d50 <LPSPI_MasterSetDelayTimes>
    LPSPI_SetDummyData(base, LPSPI_DUMMY_DATA);
60008456:	4639      	mov	r1, r7
60008458:	4620      	mov	r0, r4
}
6000845a:	b002      	add	sp, #8
6000845c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    LPSPI_SetDummyData(base, LPSPI_DUMMY_DATA);
60008460:	f7ff bebc 	b.w	600081dc <LPSPI_SetDummyData>
60008464:	6000dd52 	.word	0x6000dd52
60008468:	6000c68a 	.word	0x6000c68a
6000846c:	6000dbb8 	.word	0x6000dbb8
60008470:	6000c548 	.word	0x6000c548

60008474 <LPSPI_MasterTransferCreateHandle>:
{
60008474:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60008476:	4607      	mov	r7, r0
60008478:	4616      	mov	r6, r2
6000847a:	461d      	mov	r5, r3
    assert(handle != NULL);
6000847c:	460c      	mov	r4, r1
6000847e:	b959      	cbnz	r1, 60008498 <LPSPI_MasterTransferCreateHandle+0x24>
60008480:	490e      	ldr	r1, [pc, #56]	; (600084bc <LPSPI_MasterTransferCreateHandle+0x48>)
60008482:	f240 23e5 	movw	r3, #741	; 0x2e5
60008486:	480e      	ldr	r0, [pc, #56]	; (600084c0 <LPSPI_MasterTransferCreateHandle+0x4c>)
60008488:	4a0e      	ldr	r2, [pc, #56]	; (600084c4 <LPSPI_MasterTransferCreateHandle+0x50>)
6000848a:	f002 fb19 	bl	6000aac0 <assert_print>
6000848e:	f240 21e5 	movw	r1, #741	; 0x2e5
60008492:	480c      	ldr	r0, [pc, #48]	; (600084c4 <LPSPI_MasterTransferCreateHandle+0x50>)
60008494:	f002 fb0d 	bl	6000aab2 <assert_post_action>
    (void)memset(handle, 0, sizeof(*handle));
60008498:	2238      	movs	r2, #56	; 0x38
6000849a:	2100      	movs	r1, #0
6000849c:	4620      	mov	r0, r4
6000849e:	f002 fb76 	bl	6000ab8e <memset>
    s_lpspiHandle[LPSPI_GetInstance(base)] = handle;
600084a2:	4638      	mov	r0, r7
600084a4:	f7ff fe6e 	bl	60008184 <LPSPI_GetInstance>
600084a8:	4b07      	ldr	r3, [pc, #28]	; (600084c8 <LPSPI_MasterTransferCreateHandle+0x54>)
    s_lpspiMasterIsr = LPSPI_MasterTransferHandleIRQ;
600084aa:	4a08      	ldr	r2, [pc, #32]	; (600084cc <LPSPI_MasterTransferCreateHandle+0x58>)
    s_lpspiHandle[LPSPI_GetInstance(base)] = handle;
600084ac:	f843 4020 	str.w	r4, [r3, r0, lsl #2]
    s_lpspiMasterIsr = LPSPI_MasterTransferHandleIRQ;
600084b0:	4b07      	ldr	r3, [pc, #28]	; (600084d0 <LPSPI_MasterTransferCreateHandle+0x5c>)
    handle->userData = userData;
600084b2:	e9c4 650c 	strd	r6, r5, [r4, #48]	; 0x30
    s_lpspiMasterIsr = LPSPI_MasterTransferHandleIRQ;
600084b6:	601a      	str	r2, [r3, #0]
}
600084b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
600084ba:	bf00      	nop
600084bc:	6000d8ef 	.word	0x6000d8ef
600084c0:	6000c68a 	.word	0x6000c68a
600084c4:	6000dbb8 	.word	0x6000dbb8
600084c8:	800016b4 	.word	0x800016b4
600084cc:	60007ffd 	.word	0x60007ffd
600084d0:	800016b0 	.word	0x800016b0

600084d4 <LPSPI_CheckTransferArgument>:
{
600084d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
600084d6:	4604      	mov	r4, r0
    assert(transfer != NULL);
600084d8:	b959      	cbnz	r1, 600084f2 <LPSPI_CheckTransferArgument+0x1e>
600084da:	4925      	ldr	r1, [pc, #148]	; (60008570 <LPSPI_CheckTransferArgument+0x9c>)
600084dc:	f240 23fd 	movw	r3, #765	; 0x2fd
600084e0:	4824      	ldr	r0, [pc, #144]	; (60008574 <LPSPI_CheckTransferArgument+0xa0>)
600084e2:	4a25      	ldr	r2, [pc, #148]	; (60008578 <LPSPI_CheckTransferArgument+0xa4>)
600084e4:	f002 faec 	bl	6000aac0 <assert_print>
600084e8:	f240 21fd 	movw	r1, #765	; 0x2fd
600084ec:	4822      	ldr	r0, [pc, #136]	; (60008578 <LPSPI_CheckTransferArgument+0xa4>)
600084ee:	f002 fae0 	bl	6000aab2 <assert_post_action>
    uint32_t bitsPerFrame  = ((base->TCR & LPSPI_TCR_FRAMESZ_MASK) >> LPSPI_TCR_FRAMESZ_SHIFT) + 1U;
600084f2:	6e03      	ldr	r3, [r0, #96]	; 0x60
    uint32_t temp          = (base->CFGR1 & LPSPI_CFGR1_PINCFG_MASK);
600084f4:	6a45      	ldr	r5, [r0, #36]	; 0x24
    if (transfer->dataSize == 0U)
600084f6:	6888      	ldr	r0, [r1, #8]
600084f8:	b390      	cbz	r0, 60008560 <LPSPI_CheckTransferArgument+0x8c>
    if ((NULL == (transfer->txData)) && (NULL == (transfer->rxData)))
600084fa:	680f      	ldr	r7, [r1, #0]
600084fc:	b90f      	cbnz	r7, 60008502 <LPSPI_CheckTransferArgument+0x2e>
600084fe:	6848      	ldr	r0, [r1, #4]
60008500:	b370      	cbz	r0, 60008560 <LPSPI_CheckTransferArgument+0x8c>
    uint32_t bitsPerFrame  = ((base->TCR & LPSPI_TCR_FRAMESZ_MASK) >> LPSPI_TCR_FRAMESZ_SHIFT) + 1U;
60008502:	f3c3 000b 	ubfx	r0, r3, #0, #12
    uint32_t bytesPerFrame = (bitsPerFrame + 7U) / 8U;
60008506:	3008      	adds	r0, #8
    if (bytesPerFrame <= 4U)
60008508:	2827      	cmp	r0, #39	; 0x27
    uint32_t bytesPerFrame = (bitsPerFrame + 7U) / 8U;
6000850a:	ea4f 03d0 	mov.w	r3, r0, lsr #3
    if (bytesPerFrame <= 4U)
6000850e:	d807      	bhi.n	60008520 <LPSPI_CheckTransferArgument+0x4c>
        if ((transfer->dataSize % bytesPerFrame) != 0U)
60008510:	6888      	ldr	r0, [r1, #8]
60008512:	fbb0 f6f3 	udiv	r6, r0, r3
60008516:	fb03 0016 	mls	r0, r3, r6, r0
6000851a:	b138      	cbz	r0, 6000852c <LPSPI_CheckTransferArgument+0x58>
        return false;
6000851c:	2000      	movs	r0, #0
6000851e:	e01f      	b.n	60008560 <LPSPI_CheckTransferArgument+0x8c>
        if ((bytesPerFrame % 4U) != 0U)
60008520:	f013 0003 	ands.w	r0, r3, #3
60008524:	d015      	beq.n	60008552 <LPSPI_CheckTransferArgument+0x7e>
            if (transfer->dataSize != bytesPerFrame)
60008526:	6888      	ldr	r0, [r1, #8]
60008528:	4298      	cmp	r0, r3
6000852a:	d1f7      	bne.n	6000851c <LPSPI_CheckTransferArgument+0x48>
    uint32_t temp          = (base->CFGR1 & LPSPI_CFGR1_PINCFG_MASK);
6000852c:	f005 7040 	and.w	r0, r5, #50331648	; 0x3000000
    if ((temp == LPSPI_CFGR1_PINCFG(kLPSPI_SdiInSdiOut)) || (temp == LPSPI_CFGR1_PINCFG(kLPSPI_SdoInSdoOut)))
60008530:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
60008534:	d002      	beq.n	6000853c <LPSPI_CheckTransferArgument+0x68>
60008536:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
6000853a:	d103      	bne.n	60008544 <LPSPI_CheckTransferArgument+0x70>
        if ((transfer->txData != NULL) && (transfer->rxData != NULL))
6000853c:	b18f      	cbz	r7, 60008562 <LPSPI_CheckTransferArgument+0x8e>
6000853e:	6849      	ldr	r1, [r1, #4]
60008540:	2900      	cmp	r1, #0
60008542:	d1eb      	bne.n	6000851c <LPSPI_CheckTransferArgument+0x48>
    if (isEdma && ((bytesPerFrame % 4U) == 3U))
60008544:	b192      	cbz	r2, 6000856c <LPSPI_CheckTransferArgument+0x98>
60008546:	f003 0303 	and.w	r3, r3, #3
6000854a:	1ed8      	subs	r0, r3, #3
6000854c:	bf18      	it	ne
6000854e:	2001      	movne	r0, #1
60008550:	e006      	b.n	60008560 <LPSPI_CheckTransferArgument+0x8c>
            if ((transfer->dataSize % bytesPerFrame) != 0U)
60008552:	688e      	ldr	r6, [r1, #8]
60008554:	fbb6 fcf3 	udiv	ip, r6, r3
60008558:	fb03 661c 	mls	r6, r3, ip, r6
6000855c:	2e00      	cmp	r6, #0
6000855e:	d0e5      	beq.n	6000852c <LPSPI_CheckTransferArgument+0x58>
}
60008560:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            base->CFGR1 |= LPSPI_CFGR1_OUTCFG_MASK;
60008562:	6a61      	ldr	r1, [r4, #36]	; 0x24
60008564:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
60008568:	6261      	str	r1, [r4, #36]	; 0x24
6000856a:	e7eb      	b.n	60008544 <LPSPI_CheckTransferArgument+0x70>
    return true;
6000856c:	2001      	movs	r0, #1
6000856e:	e7f7      	b.n	60008560 <LPSPI_CheckTransferArgument+0x8c>
60008570:	6000dd8e 	.word	0x6000dd8e
60008574:	6000c68a 	.word	0x6000c68a
60008578:	6000dbb8 	.word	0x6000dbb8

6000857c <LPSPI_MasterTransferNonBlocking>:
{
6000857c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
60008580:	4605      	mov	r5, r0
60008582:	4616      	mov	r6, r2
    assert(handle != NULL);
60008584:	460c      	mov	r4, r1
60008586:	b959      	cbnz	r1, 600085a0 <LPSPI_MasterTransferNonBlocking+0x24>
60008588:	498d      	ldr	r1, [pc, #564]	; (600087c0 <LPSPI_MasterTransferNonBlocking+0x244>)
6000858a:	f240 4361 	movw	r3, #1121	; 0x461
6000858e:	4a8d      	ldr	r2, [pc, #564]	; (600087c4 <LPSPI_MasterTransferNonBlocking+0x248>)
60008590:	488d      	ldr	r0, [pc, #564]	; (600087c8 <LPSPI_MasterTransferNonBlocking+0x24c>)
60008592:	f002 fa95 	bl	6000aac0 <assert_print>
60008596:	f240 4161 	movw	r1, #1121	; 0x461
    assert(transfer != NULL);
6000859a:	488a      	ldr	r0, [pc, #552]	; (600087c4 <LPSPI_MasterTransferNonBlocking+0x248>)
6000859c:	f002 fa89 	bl	6000aab2 <assert_post_action>
600085a0:	b94a      	cbnz	r2, 600085b6 <LPSPI_MasterTransferNonBlocking+0x3a>
600085a2:	498a      	ldr	r1, [pc, #552]	; (600087cc <LPSPI_MasterTransferNonBlocking+0x250>)
600085a4:	f240 4362 	movw	r3, #1122	; 0x462
600085a8:	4a86      	ldr	r2, [pc, #536]	; (600087c4 <LPSPI_MasterTransferNonBlocking+0x248>)
600085aa:	4887      	ldr	r0, [pc, #540]	; (600087c8 <LPSPI_MasterTransferNonBlocking+0x24c>)
600085ac:	f002 fa88 	bl	6000aac0 <assert_print>
600085b0:	f240 4162 	movw	r1, #1122	; 0x462
600085b4:	e7f1      	b.n	6000859a <LPSPI_MasterTransferNonBlocking+0x1e>
    if (handle->state == (uint8_t)kLPSPI_Busy)
600085b6:	f891 302c 	ldrb.w	r3, [r1, #44]	; 0x2c
600085ba:	2b01      	cmp	r3, #1
600085bc:	f000 80fa 	beq.w	600087b4 <LPSPI_MasterTransferNonBlocking+0x238>
        base->CR &= ~LPSPI_CR_MEN_MASK;
600085c0:	6903      	ldr	r3, [r0, #16]
    if (!LPSPI_CheckTransferArgument(base, transfer, false))
600085c2:	2200      	movs	r2, #0
600085c4:	4631      	mov	r1, r6
600085c6:	f023 0301 	bic.w	r3, r3, #1
600085ca:	6103      	str	r3, [r0, #16]
600085cc:	f7ff ff82 	bl	600084d4 <LPSPI_CheckTransferArgument>
600085d0:	4607      	mov	r7, r0
600085d2:	2800      	cmp	r0, #0
600085d4:	f000 80f1 	beq.w	600087ba <LPSPI_MasterTransferNonBlocking+0x23e>
    base->CR |= ((uint32_t)flushTxFifo << LPSPI_CR_RTF_SHIFT) | ((uint32_t)flushRxFifo << LPSPI_CR_RRF_SHIFT);
600085d8:	692b      	ldr	r3, [r5, #16]
    uint8_t dummyData = g_lpspiDummyData[LPSPI_GetInstance(base)];
600085da:	4628      	mov	r0, r5
600085dc:	f443 7340 	orr.w	r3, r3, #768	; 0x300
600085e0:	612b      	str	r3, [r5, #16]
    base->SR = statusFlags; /*!< The status flags are cleared by writing 1 (w1c).*/
600085e2:	4b7b      	ldr	r3, [pc, #492]	; (600087d0 <LPSPI_MasterTransferNonBlocking+0x254>)
600085e4:	616b      	str	r3, [r5, #20]
    base->IER &= ~mask;
600085e6:	69ab      	ldr	r3, [r5, #24]
600085e8:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
600085ec:	f023 0303 	bic.w	r3, r3, #3
600085f0:	61ab      	str	r3, [r5, #24]
600085f2:	f7ff fdc7 	bl	60008184 <LPSPI_GetInstance>
600085f6:	4b77      	ldr	r3, [pc, #476]	; (600087d4 <LPSPI_MasterTransferNonBlocking+0x258>)
    uint32_t whichPcs = (transfer->configFlags & LPSPI_MASTER_PCS_MASK) >> LPSPI_MASTER_PCS_SHIFT;
600085f8:	68f2      	ldr	r2, [r6, #12]
    uint8_t dummyData = g_lpspiDummyData[LPSPI_GetInstance(base)];
600085fa:	5c18      	ldrb	r0, [r3, r0]
    uint32_t temp     = (base->CFGR1 & LPSPI_CFGR1_PINCFG_MASK);
600085fc:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    uint32_t whichPcs = (transfer->configFlags & LPSPI_MASTER_PCS_MASK) >> LPSPI_MASTER_PCS_SHIFT;
600085fe:	0912      	lsrs	r2, r2, #4
    uint8_t dummyData = g_lpspiDummyData[LPSPI_GetInstance(base)];
60008600:	b2c0      	uxtb	r0, r0
    uint32_t temp     = (base->CFGR1 & LPSPI_CFGR1_PINCFG_MASK);
60008602:	f003 7c40 	and.w	ip, r3, #50331648	; 0x3000000
    handle->state                = (uint8_t)kLPSPI_Busy;
60008606:	2301      	movs	r3, #1
60008608:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    handle->txData               = transfer->txData;
6000860c:	6833      	ldr	r3, [r6, #0]
6000860e:	60e3      	str	r3, [r4, #12]
    handle->rxData               = transfer->rxData;
60008610:	6873      	ldr	r3, [r6, #4]
60008612:	6123      	str	r3, [r4, #16]
    handle->txRemainingByteCount = transfer->dataSize;
60008614:	68b3      	ldr	r3, [r6, #8]
60008616:	6163      	str	r3, [r4, #20]
    handle->rxRemainingByteCount = transfer->dataSize;
60008618:	68b3      	ldr	r3, [r6, #8]
6000861a:	61a3      	str	r3, [r4, #24]
    handle->totalByteCount       = transfer->dataSize;
6000861c:	68b3      	ldr	r3, [r6, #8]
6000861e:	6263      	str	r3, [r4, #36]	; 0x24
    handle->writeTcrInIsr        = false;
60008620:	2300      	movs	r3, #0
60008622:	7063      	strb	r3, [r4, #1]
    handle->bytesPerFrame = (uint16_t)((base->TCR & LPSPI_TCR_FRAMESZ_MASK) >> LPSPI_TCR_FRAMESZ_SHIFT) / 8U + 1U;
60008624:	6e2b      	ldr	r3, [r5, #96]	; 0x60
60008626:	f3c3 03c8 	ubfx	r3, r3, #3, #9
6000862a:	3301      	adds	r3, #1
6000862c:	80a3      	strh	r3, [r4, #4]
    bool isPcsContinuous = (((transfer->configFlags & (uint32_t)kLPSPI_MasterPcsContinuous) != 0U) &&
6000862e:	68f3      	ldr	r3, [r6, #12]
60008630:	f413 1380 	ands.w	r3, r3, #1048576	; 0x100000
60008634:	d006      	beq.n	60008644 <LPSPI_MasterTransferNonBlocking+0xc8>
                            (transfer->dataSize > handle->bytesPerFrame));
60008636:	68b3      	ldr	r3, [r6, #8]
60008638:	88a1      	ldrh	r1, [r4, #4]
6000863a:	b289      	uxth	r1, r1
    bool isPcsContinuous = (((transfer->configFlags & (uint32_t)kLPSPI_MasterPcsContinuous) != 0U) &&
6000863c:	428b      	cmp	r3, r1
6000863e:	bf94      	ite	ls
60008640:	2300      	movls	r3, #0
60008642:	2301      	movhi	r3, #1
        (transfer->dataSize / (uint32_t)handle->bytesPerFrame) * (((uint32_t)handle->bytesPerFrame + 3U) / 4U);
60008644:	f8d6 8008 	ldr.w	r8, [r6, #8]
60008648:	f8b4 9004 	ldrh.w	r9, [r4, #4]
6000864c:	88a1      	ldrh	r1, [r4, #4]
6000864e:	fa1f f989 	uxth.w	r9, r9
60008652:	b289      	uxth	r1, r1
60008654:	fbb8 f8f9 	udiv	r8, r8, r9
60008658:	3103      	adds	r1, #3
6000865a:	0889      	lsrs	r1, r1, #2
6000865c:	fb08 f101 	mul.w	r1, r8, r1
    handle->writeRegRemainingTimes =
60008660:	61e1      	str	r1, [r4, #28]
    handle->readRegRemainingTimes = handle->writeRegRemainingTimes;
60008662:	69e1      	ldr	r1, [r4, #28]
60008664:	6221      	str	r1, [r4, #32]
        ((uint32_t)dummyData) | ((uint32_t)dummyData << 8) | ((uint32_t)dummyData << 16) | ((uint32_t)dummyData << 24);
60008666:	f04f 3101 	mov.w	r1, #16843009	; 0x1010101
6000866a:	4348      	muls	r0, r1
    return (1U << ((base->PARAM & LPSPI_PARAM_RXFIFO_MASK) >> LPSPI_PARAM_RXFIFO_SHIFT));
6000866c:	2101      	movs	r1, #1
    handle->txBuffIfNull =
6000866e:	62a0      	str	r0, [r4, #40]	; 0x28
60008670:	6868      	ldr	r0, [r5, #4]
60008672:	f3c0 2007 	ubfx	r0, r0, #8, #8
60008676:	4081      	lsls	r1, r0
60008678:	b2c9      	uxtb	r1, r1
    handle->fifoSize        = LPSPI_GetRxFifoSize(base);
6000867a:	71a1      	strb	r1, [r4, #6]
    handle->isPcsContinuous = isPcsContinuous;
6000867c:	7023      	strb	r3, [r4, #0]
    handle->isByteSwap      = ((transfer->configFlags & (uint32_t)kLPSPI_MasterByteSwap) != 0U);
6000867e:	68f1      	ldr	r1, [r6, #12]
60008680:	f3c1 5180 	ubfx	r1, r1, #22, #1
60008684:	70a1      	strb	r1, [r4, #2]
    if (handle->bytesPerFrame <= 4U)
60008686:	88a1      	ldrh	r1, [r4, #4]
60008688:	b289      	uxth	r1, r1
6000868a:	2904      	cmp	r1, #4
6000868c:	d87a      	bhi.n	60008784 <LPSPI_MasterTransferNonBlocking+0x208>
        handle->bytesEachWrite = (uint8_t)handle->bytesPerFrame;
6000868e:	88a1      	ldrh	r1, [r4, #4]
60008690:	b2c9      	uxtb	r1, r1
60008692:	7221      	strb	r1, [r4, #8]
        handle->bytesEachRead  = (uint8_t)handle->bytesPerFrame;
60008694:	88a1      	ldrh	r1, [r4, #4]
60008696:	b2c9      	uxtb	r1, r1
        handle->bytesEachRead  = 4U;
60008698:	7261      	strb	r1, [r4, #9]
    if (handle->fifoSize > 1U)
6000869a:	79a1      	ldrb	r1, [r4, #6]
6000869c:	2901      	cmp	r1, #1
6000869e:	d974      	bls.n	6000878a <LPSPI_MasterTransferNonBlocking+0x20e>
        handle->rxWatermark = handle->fifoSize - 2U;
600086a0:	79a1      	ldrb	r1, [r4, #6]
        txWatermark         = 1U;
600086a2:	2001      	movs	r0, #1
        handle->rxWatermark = handle->fifoSize - 2U;
600086a4:	3902      	subs	r1, #2
600086a6:	b2c9      	uxtb	r1, r1
600086a8:	71e1      	strb	r1, [r4, #7]
    LPSPI_SetFifoWatermarks(base, txWatermark, handle->rxWatermark);
600086aa:	79e1      	ldrb	r1, [r4, #7]
    base->FCR = LPSPI_FCR_TXWATER(txWater) | LPSPI_FCR_RXWATER(rxWater);
600086ac:	0409      	lsls	r1, r1, #16
600086ae:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
600086b2:	4301      	orrs	r1, r0
600086b4:	65a9      	str	r1, [r5, #88]	; 0x58
    if (handle->rxData == NULL)
600086b6:	6921      	ldr	r1, [r4, #16]
600086b8:	2900      	cmp	r1, #0
600086ba:	d169      	bne.n	60008790 <LPSPI_MasterTransferNonBlocking+0x214>
        handle->rxRemainingByteCount = 0;
600086bc:	61a1      	str	r1, [r4, #24]
    if (((temp == LPSPI_CFGR1_PINCFG(kLPSPI_SdiInSdiOut)) || (temp == LPSPI_CFGR1_PINCFG(kLPSPI_SdoInSdoOut))) &&
600086be:	f1bc 7f80 	cmp.w	ip, #16777216	; 0x1000000
600086c2:	d002      	beq.n	600086ca <LPSPI_MasterTransferNonBlocking+0x14e>
600086c4:	f1bc 7f00 	cmp.w	ip, #33554432	; 0x2000000
600086c8:	d103      	bne.n	600086d2 <LPSPI_MasterTransferNonBlocking+0x156>
        (handle->txData == NULL))
600086ca:	68e1      	ldr	r1, [r4, #12]
    if (((temp == LPSPI_CFGR1_PINCFG(kLPSPI_SdiInSdiOut)) || (temp == LPSPI_CFGR1_PINCFG(kLPSPI_SdoInSdoOut))) &&
600086cc:	b909      	cbnz	r1, 600086d2 <LPSPI_MasterTransferNonBlocking+0x156>
        handle->isTxMask = true;
600086ce:	2101      	movs	r1, #1
600086d0:	70e1      	strb	r1, [r4, #3]
    base->CFGR1 &= (~LPSPI_CFGR1_NOSTALL_MASK);
600086d2:	6a69      	ldr	r1, [r5, #36]	; 0x24
                LPSPI_TCR_PCS(whichPcs);
600086d4:	0612      	lsls	r2, r2, #24
    base->CFGR1 &= (~LPSPI_CFGR1_NOSTALL_MASK);
600086d6:	f021 0108 	bic.w	r1, r1, #8
                LPSPI_TCR_PCS(whichPcs);
600086da:	f002 7240 	and.w	r2, r2, #50331648	; 0x3000000
    base->CFGR1 &= (~LPSPI_CFGR1_NOSTALL_MASK);
600086de:	6269      	str	r1, [r5, #36]	; 0x24
        base->CR |= LPSPI_CR_MEN_MASK;
600086e0:	6929      	ldr	r1, [r5, #16]
600086e2:	f041 0101 	orr.w	r1, r1, #1
600086e6:	6129      	str	r1, [r5, #16]
    base->TCR = (base->TCR & ~(LPSPI_TCR_CONT_MASK | LPSPI_TCR_CONTC_MASK | LPSPI_TCR_RXMSK_MASK |
600086e8:	6e29      	ldr	r1, [r5, #96]	; 0x60
600086ea:	f021 714f 	bic.w	r1, r1, #54263808	; 0x33c0000
                               LPSPI_TCR_TXMSK_MASK | LPSPI_TCR_PCS_MASK)) |
600086ee:	430a      	orrs	r2, r1
    base->TCR = (base->TCR & ~(LPSPI_TCR_CONT_MASK | LPSPI_TCR_CONTC_MASK | LPSPI_TCR_RXMSK_MASK |
600086f0:	662a      	str	r2, [r5, #96]	; 0x60
    return ((base->FSR & LPSPI_FSR_TXCOUNT_MASK) >> LPSPI_FSR_TXCOUNT_SHIFT);
600086f2:	6dea      	ldr	r2, [r5, #92]	; 0x5c
{
#if SPI_RETRY_TIMES
    uint32_t waitTimes = SPI_RETRY_TIMES;
    while (((uint8_t)LPSPI_GetTxFifoCount(base) != 0U) && (--waitTimes != 0U))
#else
    while ((uint8_t)LPSPI_GetTxFifoCount(base) != 0U)
600086f4:	06d2      	lsls	r2, r2, #27
600086f6:	d1fc      	bne.n	600086f2 <LPSPI_MasterTransferNonBlocking+0x176>
    base->TCR |= LPSPI_TCR_CONT(isPcsContinuous) | LPSPI_TCR_CONTC(isPcsContinuous) | LPSPI_TCR_RXMSK(isRxMask);
600086f8:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
600086fc:	6e2a      	ldr	r2, [r5, #96]	; 0x60
    (void)EnableIRQ(s_lpspiIRQ[LPSPI_GetInstance(base)]);
600086fe:	4628      	mov	r0, r5
    base->TCR |= LPSPI_TCR_CONT(isPcsContinuous) | LPSPI_TCR_CONTC(isPcsContinuous) | LPSPI_TCR_RXMSK(isRxMask);
60008700:	434b      	muls	r3, r1
60008702:	4313      	orrs	r3, r2
60008704:	ea43 43c7 	orr.w	r3, r3, r7, lsl #19
60008708:	662b      	str	r3, [r5, #96]	; 0x60
    (void)EnableIRQ(s_lpspiIRQ[LPSPI_GetInstance(base)]);
6000870a:	f7ff fd3b 	bl	60008184 <LPSPI_GetInstance>
6000870e:	4b32      	ldr	r3, [pc, #200]	; (600087d8 <LPSPI_MasterTransferNonBlocking+0x25c>)
60008710:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
60008714:	f7ff fd28 	bl	60008168 <EnableIRQ.isra.0>
60008718:	6deb      	ldr	r3, [r5, #92]	; 0x5c
    while ((uint8_t)LPSPI_GetTxFifoCount(base) != 0U)
6000871a:	06db      	lsls	r3, r3, #27
6000871c:	d1fc      	bne.n	60008718 <LPSPI_MasterTransferNonBlocking+0x19c>
    if (handle->isTxMask)
6000871e:	78e3      	ldrb	r3, [r4, #3]
60008720:	2b00      	cmp	r3, #0
60008722:	d037      	beq.n	60008794 <LPSPI_MasterTransferNonBlocking+0x218>
        base->TCR |= LPSPI_TCR_TXMSK_MASK;
60008724:	6e2b      	ldr	r3, [r5, #96]	; 0x60
60008726:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
6000872a:	662b      	str	r3, [r5, #96]	; 0x60
        handle->txRemainingByteCount -= (uint32_t)handle->bytesPerFrame;
6000872c:	88a2      	ldrh	r2, [r4, #4]
6000872e:	6963      	ldr	r3, [r4, #20]
60008730:	b292      	uxth	r2, r2
60008732:	1a9b      	subs	r3, r3, r2
60008734:	6163      	str	r3, [r4, #20]
    if (handle->rxData != NULL)
60008736:	6923      	ldr	r3, [r4, #16]
60008738:	2b00      	cmp	r3, #0
6000873a:	d037      	beq.n	600087ac <LPSPI_MasterTransferNonBlocking+0x230>
        if (handle->isTxMask)
6000873c:	78e3      	ldrb	r3, [r4, #3]
6000873e:	b373      	cbz	r3, 6000879e <LPSPI_MasterTransferNonBlocking+0x222>
            if ((handle->bytesPerFrame / 4U) < (uint16_t)handle->rxWatermark)
60008740:	88a3      	ldrh	r3, [r4, #4]
60008742:	79e2      	ldrb	r2, [r4, #7]
60008744:	f3c3 038d 	ubfx	r3, r3, #2, #14
60008748:	4293      	cmp	r3, r2
6000874a:	d214      	bcs.n	60008776 <LPSPI_MasterTransferNonBlocking+0x1fa>
                    (uint8_t)(handle->bytesPerFrame / 4U) > 0U ? (uint8_t)(handle->bytesPerFrame / 4U - 1U) : 0U;
6000874c:	88a2      	ldrh	r2, [r4, #4]
                handle->rxWatermark =
6000874e:	f412 7f7f 	tst.w	r2, #1020	; 0x3fc
                    (uint8_t)(handle->bytesPerFrame / 4U) > 0U ? (uint8_t)(handle->bytesPerFrame / 4U - 1U) : 0U;
60008752:	f3c2 0387 	ubfx	r3, r2, #2, #8
                handle->rxWatermark =
60008756:	d004      	beq.n	60008762 <LPSPI_MasterTransferNonBlocking+0x1e6>
                    (uint8_t)(handle->bytesPerFrame / 4U) > 0U ? (uint8_t)(handle->bytesPerFrame / 4U - 1U) : 0U;
60008758:	88a3      	ldrh	r3, [r4, #4]
6000875a:	f3c3 038d 	ubfx	r3, r3, #2, #14
                handle->rxWatermark =
6000875e:	3b01      	subs	r3, #1
60008760:	b2db      	uxtb	r3, r3
60008762:	71e3      	strb	r3, [r4, #7]
                base->FCR = (base->FCR & (~LPSPI_FCR_RXWATER_MASK)) | LPSPI_FCR_RXWATER(handle->rxWatermark);
60008764:	6daa      	ldr	r2, [r5, #88]	; 0x58
60008766:	79e3      	ldrb	r3, [r4, #7]
                base->FCR = (base->FCR & (~LPSPI_FCR_RXWATER_MASK)) | LPSPI_FCR_RXWATER(tmpTimes - 1U);
60008768:	041b      	lsls	r3, r3, #16
6000876a:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
6000876e:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
60008772:	4313      	orrs	r3, r2
60008774:	65ab      	str	r3, [r5, #88]	; 0x58
    base->IER |= mask;
60008776:	69ab      	ldr	r3, [r5, #24]
60008778:	f043 0302 	orr.w	r3, r3, #2
    return kStatus_Success;
6000877c:	2000      	movs	r0, #0
6000877e:	61ab      	str	r3, [r5, #24]
}
60008780:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        handle->bytesEachWrite = 4U;
60008784:	2104      	movs	r1, #4
60008786:	7221      	strb	r1, [r4, #8]
60008788:	e786      	b.n	60008698 <LPSPI_MasterTransferNonBlocking+0x11c>
        handle->rxWatermark = 0U;
6000878a:	2000      	movs	r0, #0
6000878c:	71e0      	strb	r0, [r4, #7]
6000878e:	e78c      	b.n	600086aa <LPSPI_MasterTransferNonBlocking+0x12e>
    bool isRxMask = false;
60008790:	2700      	movs	r7, #0
60008792:	e794      	b.n	600086be <LPSPI_MasterTransferNonBlocking+0x142>
        LPSPI_MasterTransferFillUpTxFifo(base, handle);
60008794:	4621      	mov	r1, r4
60008796:	4628      	mov	r0, r5
60008798:	f7ff fb80 	bl	60007e9c <LPSPI_MasterTransferFillUpTxFifo>
6000879c:	e7cb      	b.n	60008736 <LPSPI_MasterTransferNonBlocking+0x1ba>
            tmpTimes = handle->readRegRemainingTimes;
6000879e:	6a23      	ldr	r3, [r4, #32]
            if (tmpTimes <= handle->rxWatermark)
600087a0:	79e2      	ldrb	r2, [r4, #7]
600087a2:	429a      	cmp	r2, r3
600087a4:	d3e7      	bcc.n	60008776 <LPSPI_MasterTransferNonBlocking+0x1fa>
                base->FCR = (base->FCR & (~LPSPI_FCR_RXWATER_MASK)) | LPSPI_FCR_RXWATER(tmpTimes - 1U);
600087a6:	6daa      	ldr	r2, [r5, #88]	; 0x58
600087a8:	3b01      	subs	r3, #1
600087aa:	e7dd      	b.n	60008768 <LPSPI_MasterTransferNonBlocking+0x1ec>
600087ac:	69ab      	ldr	r3, [r5, #24]
600087ae:	f043 0301 	orr.w	r3, r3, #1
600087b2:	e7e3      	b.n	6000877c <LPSPI_MasterTransferNonBlocking+0x200>
        return kStatus_LPSPI_Busy;
600087b4:	f44f 70c8 	mov.w	r0, #400	; 0x190
600087b8:	e7e2      	b.n	60008780 <LPSPI_MasterTransferNonBlocking+0x204>
        return kStatus_InvalidArgument;
600087ba:	2004      	movs	r0, #4
600087bc:	e7e0      	b.n	60008780 <LPSPI_MasterTransferNonBlocking+0x204>
600087be:	bf00      	nop
600087c0:	6000d8ef 	.word	0x6000d8ef
600087c4:	6000dbb8 	.word	0x6000dbb8
600087c8:	6000c68a 	.word	0x6000c68a
600087cc:	6000dd8e 	.word	0x6000dd8e
600087d0:	01003f03 	.word	0x01003f03
600087d4:	8000170d 	.word	0x8000170d
600087d8:	6000c552 	.word	0x6000c552

600087dc <CLOCK_ControlGate>:
    assert(index <= 6UL);
600087dc:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    uint32_t index = ((uint32_t)name) >> 8U;
600087e0:	ea4f 2210 	mov.w	r2, r0, lsr #8
{
600087e4:	b510      	push	{r4, lr}
    uint32_t shift = ((uint32_t)name) & 0x1FU;
600087e6:	f000 041f 	and.w	r4, r0, #31
    assert(index <= 6UL);
600087ea:	d30b      	bcc.n	60008804 <CLOCK_ControlGate+0x28>
600087ec:	490d      	ldr	r1, [pc, #52]	; (60008824 <CLOCK_ControlGate+0x48>)
600087ee:	f44f 63a3 	mov.w	r3, #1304	; 0x518
600087f2:	480d      	ldr	r0, [pc, #52]	; (60008828 <CLOCK_ControlGate+0x4c>)
600087f4:	4a0d      	ldr	r2, [pc, #52]	; (6000882c <CLOCK_ControlGate+0x50>)
600087f6:	f002 f963 	bl	6000aac0 <assert_print>
600087fa:	f44f 61a3 	mov.w	r1, #1304	; 0x518
600087fe:	480b      	ldr	r0, [pc, #44]	; (6000882c <CLOCK_ControlGate+0x50>)
60008800:	f002 f957 	bl	6000aab2 <assert_post_action>
    reg = (volatile uint32_t *)((uint32_t)((volatile uint32_t *)&CCM->CCGR0) + sizeof(volatile uint32_t *) * index);
60008804:	4b0a      	ldr	r3, [pc, #40]	; (60008830 <CLOCK_ControlGate+0x54>)
    SDK_ATOMIC_LOCAL_CLEAR_AND_SET(reg, (3UL << shift), (((uint32_t)value) << shift));
60008806:	2003      	movs	r0, #3
60008808:	40a1      	lsls	r1, r4
    reg = (volatile uint32_t *)((uint32_t)((volatile uint32_t *)&CCM->CCGR0) + sizeof(volatile uint32_t *) * index);
6000880a:	4413      	add	r3, r2
    SDK_ATOMIC_LOCAL_CLEAR_AND_SET(reg, (3UL << shift), (((uint32_t)value) << shift));
6000880c:	40a0      	lsls	r0, r4
    reg = (volatile uint32_t *)((uint32_t)((volatile uint32_t *)&CCM->CCGR0) + sizeof(volatile uint32_t *) * index);
6000880e:	009a      	lsls	r2, r3, #2
    _SDK_ATOMIC_LOCAL_OPS_4BYTE(addr, s_val, s_val = (s_val & ~clearBits) | setBits);
60008810:	43c0      	mvns	r0, r0
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
60008812:	e852 3f00 	ldrex	r3, [r2]
60008816:	4003      	ands	r3, r0
60008818:	430b      	orrs	r3, r1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
6000881a:	e842 3400 	strex	r4, r3, [r2]
6000881e:	2c00      	cmp	r4, #0
60008820:	d1f7      	bne.n	60008812 <CLOCK_ControlGate+0x36>
}
60008822:	bd10      	pop	{r4, pc}
60008824:	6000dc7b 	.word	0x6000dc7b
60008828:	6000c68a 	.word	0x6000c68a
6000882c:	6000dc28 	.word	0x6000dc28
60008830:	1003f01a 	.word	0x1003f01a

60008834 <LPUART_GetInstance>:
 *
 * param base LPUART peripheral base address.
 * return LPUART instance.
 */
uint32_t LPUART_GetInstance(LPUART_Type *base)
{
60008834:	b508      	push	{r3, lr}
60008836:	4a0a      	ldr	r2, [pc, #40]	; (60008860 <LPUART_GetInstance+0x2c>)
60008838:	4603      	mov	r3, r0
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0U; instance < ARRAY_SIZE(s_lpuartBases); instance++)
6000883a:	2000      	movs	r0, #0
    {
        if (s_lpuartBases[instance] == base)
6000883c:	f852 1b04 	ldr.w	r1, [r2], #4
60008840:	4299      	cmp	r1, r3
60008842:	d00c      	beq.n	6000885e <LPUART_GetInstance+0x2a>
    for (instance = 0U; instance < ARRAY_SIZE(s_lpuartBases); instance++)
60008844:	3001      	adds	r0, #1
60008846:	2809      	cmp	r0, #9
60008848:	d1f8      	bne.n	6000883c <LPUART_GetInstance+0x8>
        {
            break;
        }
    }

    assert(instance < ARRAY_SIZE(s_lpuartBases));
6000884a:	4906      	ldr	r1, [pc, #24]	; (60008864 <LPUART_GetInstance+0x30>)
6000884c:	237b      	movs	r3, #123	; 0x7b
6000884e:	4806      	ldr	r0, [pc, #24]	; (60008868 <LPUART_GetInstance+0x34>)
60008850:	4a06      	ldr	r2, [pc, #24]	; (6000886c <LPUART_GetInstance+0x38>)
60008852:	f002 f935 	bl	6000aac0 <assert_print>
60008856:	217b      	movs	r1, #123	; 0x7b
60008858:	4804      	ldr	r0, [pc, #16]	; (6000886c <LPUART_GetInstance+0x38>)
6000885a:	f002 f92a 	bl	6000aab2 <assert_post_action>

    return instance;
}
6000885e:	bd08      	pop	{r3, pc}
60008860:	6000c4b4 	.word	0x6000c4b4
60008864:	6000de08 	.word	0x6000de08
60008868:	6000c68a 	.word	0x6000c68a
6000886c:	6000ddae 	.word	0x6000ddae

60008870 <LPUART_Init>:
 * param srcClock_Hz LPUART clock source frequency in HZ.
 * retval kStatus_LPUART_BaudrateNotSupport Baudrate is not support in current clock source.
 * retval kStatus_Success LPUART initialize succeed
 */
status_t LPUART_Init(LPUART_Type *base, const lpuart_config_t *config, uint32_t srcClock_Hz)
{
60008870:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
60008874:	4604      	mov	r4, r0
    assert(NULL != config);
60008876:	460d      	mov	r5, r1
60008878:	b949      	cbnz	r1, 6000888e <LPUART_Init+0x1e>
6000887a:	4976      	ldr	r1, [pc, #472]	; (60008a54 <LPUART_Init+0x1e4>)
6000887c:	23f2      	movs	r3, #242	; 0xf2
6000887e:	4a76      	ldr	r2, [pc, #472]	; (60008a58 <LPUART_Init+0x1e8>)
60008880:	4876      	ldr	r0, [pc, #472]	; (60008a5c <LPUART_Init+0x1ec>)
60008882:	f002 f91d 	bl	6000aac0 <assert_print>
60008886:	21f2      	movs	r1, #242	; 0xf2
    assert(0U < config->baudRate_Bps);
60008888:	4873      	ldr	r0, [pc, #460]	; (60008a58 <LPUART_Init+0x1e8>)
6000888a:	f002 f912 	bl	6000aab2 <assert_post_action>
6000888e:	680b      	ldr	r3, [r1, #0]
60008890:	b93b      	cbnz	r3, 600088a2 <LPUART_Init+0x32>
60008892:	4973      	ldr	r1, [pc, #460]	; (60008a60 <LPUART_Init+0x1f0>)
60008894:	23f3      	movs	r3, #243	; 0xf3
60008896:	4a70      	ldr	r2, [pc, #448]	; (60008a58 <LPUART_Init+0x1e8>)
60008898:	4870      	ldr	r0, [pc, #448]	; (60008a5c <LPUART_Init+0x1ec>)
6000889a:	f002 f911 	bl	6000aac0 <assert_print>
6000889e:	21f3      	movs	r1, #243	; 0xf3
600088a0:	e7f2      	b.n	60008888 <LPUART_Init+0x18>
#if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    assert((uint8_t)FSL_FEATURE_LPUART_FIFO_SIZEn(base) > config->txFifoWatermark);
600088a2:	7a09      	ldrb	r1, [r1, #8]
600088a4:	2903      	cmp	r1, #3
600088a6:	d907      	bls.n	600088b8 <LPUART_Init+0x48>
600088a8:	496e      	ldr	r1, [pc, #440]	; (60008a64 <LPUART_Init+0x1f4>)
600088aa:	23f5      	movs	r3, #245	; 0xf5
600088ac:	4a6a      	ldr	r2, [pc, #424]	; (60008a58 <LPUART_Init+0x1e8>)
600088ae:	486b      	ldr	r0, [pc, #428]	; (60008a5c <LPUART_Init+0x1ec>)
600088b0:	f002 f906 	bl	6000aac0 <assert_print>
600088b4:	21f5      	movs	r1, #245	; 0xf5
600088b6:	e7e7      	b.n	60008888 <LPUART_Init+0x18>
    assert((uint8_t)FSL_FEATURE_LPUART_FIFO_SIZEn(base) > config->rxFifoWatermark);
600088b8:	7a69      	ldrb	r1, [r5, #9]
600088ba:	2903      	cmp	r1, #3
600088bc:	f200 80b7 	bhi.w	60008a2e <LPUART_Init+0x1be>
    osr      = 0U;
    sbr      = 0U;
    for (osrTemp = 4U; osrTemp <= 32U; osrTemp++)
    {
        /* calculate the temporary sbr value   */
        sbrTemp = (uint16_t)((srcClock_Hz * 10U / (config->baudRate_Bps * (uint32_t)osrTemp) + 5U) / 10U);
600088c0:	f04f 090a 	mov.w	r9, #10
    osr      = 0U;
600088c4:	2600      	movs	r6, #0
600088c6:	ea4f 0883 	mov.w	r8, r3, lsl #2
        sbrTemp = (uint16_t)((srcClock_Hz * 10U / (config->baudRate_Bps * (uint32_t)osrTemp) + 5U) / 10U);
600088ca:	469e      	mov	lr, r3
600088cc:	fb09 fa02 	mul.w	sl, r9, r2
600088d0:	f04f 0c04 	mov.w	ip, #4
    sbr      = 0U;
600088d4:	4637      	mov	r7, r6
        sbrTemp = (uint16_t)((srcClock_Hz * 10U / (config->baudRate_Bps * (uint32_t)osrTemp) + 5U) / 10U);
600088d6:	fbba f1f8 	udiv	r1, sl, r8
600088da:	3105      	adds	r1, #5
    for (osrTemp = 4U; osrTemp <= 32U; osrTemp++)
600088dc:	4498      	add	r8, r3
        sbrTemp = (uint16_t)((srcClock_Hz * 10U / (config->baudRate_Bps * (uint32_t)osrTemp) + 5U) / 10U);
600088de:	fbb1 f1f9 	udiv	r1, r1, r9
600088e2:	b289      	uxth	r1, r1
600088e4:	2901      	cmp	r1, #1
600088e6:	bf38      	it	cc
600088e8:	2101      	movcc	r1, #1
        if (sbrTemp == 0U)
        {
            sbrTemp = 1U;
        }
        /* Calculate the baud rate based on the temporary OSR and SBR values */
        calculatedBaud = (srcClock_Hz / ((uint32_t)osrTemp * (uint32_t)sbrTemp));
600088ea:	fb0c f001 	mul.w	r0, ip, r1
600088ee:	fbb2 f0f0 	udiv	r0, r2, r0
        tempDiff       = calculatedBaud > config->baudRate_Bps ? (calculatedBaud - config->baudRate_Bps) :
600088f2:	4283      	cmp	r3, r0
600088f4:	bf34      	ite	cc
600088f6:	1ac0      	subcc	r0, r0, r3
600088f8:	1a18      	subcs	r0, r3, r0
                                                           (config->baudRate_Bps - calculatedBaud);

        if (tempDiff <= baudDiff)
600088fa:	4570      	cmp	r0, lr
600088fc:	bf98      	it	ls
600088fe:	fa5f f68c 	uxtbls.w	r6, ip
    for (osrTemp = 4U; osrTemp <= 32U; osrTemp++)
60008902:	f10c 0c01 	add.w	ip, ip, #1
        if (tempDiff <= baudDiff)
60008906:	bf9c      	itt	ls
60008908:	4686      	movls	lr, r0
        {
            baudDiff = tempDiff;
            osr      = osrTemp; /* update and store the best OSR value calculated */
            sbr      = sbrTemp; /* update store the best SBR value calculated */
6000890a:	460f      	movls	r7, r1
    for (osrTemp = 4U; osrTemp <= 32U; osrTemp++)
6000890c:	f1bc 0f21 	cmp.w	ip, #33	; 0x21
60008910:	d1e1      	bne.n	600088d6 <LPUART_Init+0x66>
        }
    }

    /* Check to see if actual baud rate is within 3% of desired baud rate
     * based on the best calculate OSR value */
    if (baudDiff > ((config->baudRate_Bps / 100U) * 3U))
60008912:	2264      	movs	r2, #100	; 0x64
60008914:	fbb3 f3f2 	udiv	r3, r3, r2
60008918:	eb03 0343 	add.w	r3, r3, r3, lsl #1
6000891c:	4573      	cmp	r3, lr
6000891e:	f0c0 8096 	bcc.w	60008a4e <LPUART_Init+0x1de>
    }
    else
    {
#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)

        uint32_t instance = LPUART_GetInstance(base);
60008922:	4620      	mov	r0, r4
        temp &= ~LPUART_BAUD_OSR_MASK;
        temp |= LPUART_BAUD_OSR((uint32_t)osr - 1UL);

        /* write the sbr value to the BAUD registers */
        temp &= ~LPUART_BAUD_SBR_MASK;
        base->BAUD = temp | LPUART_BAUD_SBR(sbr);
60008924:	f3c7 070c 	ubfx	r7, r7, #0, #13
        uint32_t instance = LPUART_GetInstance(base);
60008928:	f7ff ff84 	bl	60008834 <LPUART_GetInstance>
    CLOCK_ControlGate(name, kCLOCK_ClockNeededRunWait);
6000892c:	4b4e      	ldr	r3, [pc, #312]	; (60008a68 <LPUART_Init+0x1f8>)
6000892e:	2103      	movs	r1, #3
60008930:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
60008934:	f7ff ff52 	bl	600087dc <CLOCK_ControlGate>
 *
 * @param base LPUART peripheral base address.
 */
static inline void LPUART_SoftwareReset(LPUART_Type *base)
{
    base->GLOBAL |= LPUART_GLOBAL_RST_MASK;
60008938:	68a3      	ldr	r3, [r4, #8]
        if ((osr > 3U) && (osr < 8U))
6000893a:	1f32      	subs	r2, r6, #4
        temp |= LPUART_BAUD_OSR((uint32_t)osr - 1UL);
6000893c:	3e01      	subs	r6, #1
6000893e:	f043 0302 	orr.w	r3, r3, #2
        if ((osr > 3U) && (osr < 8U))
60008942:	2a03      	cmp	r2, #3
        temp |= LPUART_BAUD_OSR((uint32_t)osr - 1UL);
60008944:	ea4f 6606 	mov.w	r6, r6, lsl #24
60008948:	60a3      	str	r3, [r4, #8]
    base->GLOBAL &= ~LPUART_GLOBAL_RST_MASK;
6000894a:	68a3      	ldr	r3, [r4, #8]
6000894c:	f006 56f8 	and.w	r6, r6, #520093696	; 0x1f000000
60008950:	f023 0302 	bic.w	r3, r3, #2
60008954:	60a3      	str	r3, [r4, #8]
        temp = base->BAUD;
60008956:	6923      	ldr	r3, [r4, #16]
            temp |= LPUART_BAUD_BOTHEDGE_MASK;
60008958:	bf98      	it	ls
6000895a:	f443 3300 	orrls.w	r3, r3, #131072	; 0x20000
        temp |= LPUART_BAUD_OSR((uint32_t)osr - 1UL);
6000895e:	f023 231f 	bic.w	r3, r3, #520101632	; 0x1f001f00
60008962:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
        temp &= ~LPUART_BAUD_SBR_MASK;
60008966:	4333      	orrs	r3, r6
        base->BAUD = temp | LPUART_BAUD_SBR(sbr);
60008968:	431f      	orrs	r7, r3
6000896a:	6127      	str	r7, [r4, #16]

        /* Set bit count and parity mode. */
        base->BAUD &= ~LPUART_BAUD_M10_MASK;
6000896c:	6923      	ldr	r3, [r4, #16]
6000896e:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
60008972:	6123      	str	r3, [r4, #16]

        temp = base->CTRL & ~(LPUART_CTRL_PE_MASK | LPUART_CTRL_PT_MASK | LPUART_CTRL_M_MASK | LPUART_CTRL_ILT_MASK |
60008974:	69a3      	ldr	r3, [r4, #24]
                              LPUART_CTRL_IDLECFG_MASK);

        temp |= (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) |
60008976:	7bea      	ldrb	r2, [r5, #15]
        temp = base->CTRL & ~(LPUART_CTRL_PE_MASK | LPUART_CTRL_PT_MASK | LPUART_CTRL_M_MASK | LPUART_CTRL_ILT_MASK |
60008978:	f423 63e2 	bic.w	r3, r3, #1808	; 0x710
        temp |= (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) |
6000897c:	7929      	ldrb	r1, [r5, #4]
6000897e:	0212      	lsls	r2, r2, #8
        temp = base->CTRL & ~(LPUART_CTRL_PE_MASK | LPUART_CTRL_PT_MASK | LPUART_CTRL_M_MASK | LPUART_CTRL_ILT_MASK |
60008980:	f023 0307 	bic.w	r3, r3, #7
        temp |= (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) |
60008984:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
60008988:	430b      	orrs	r3, r1
6000898a:	431a      	orrs	r2, r3
                LPUART_CTRL_ILT(config->rxIdleType);
6000898c:	7bab      	ldrb	r3, [r5, #14]
6000898e:	009b      	lsls	r3, r3, #2
60008990:	f003 0304 	and.w	r3, r3, #4
        temp |= (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) |
60008994:	4313      	orrs	r3, r2

#if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
        if (kLPUART_SevenDataBits == config->dataBitsCount)
60008996:	796a      	ldrb	r2, [r5, #5]
60008998:	2a01      	cmp	r2, #1
6000899a:	d153      	bne.n	60008a44 <LPUART_Init+0x1d4>
        {
            if (kLPUART_ParityDisabled != config->parityMode)
6000899c:	2900      	cmp	r1, #0
6000899e:	d04e      	beq.n	60008a3e <LPUART_Init+0x1ce>
            {
                temp &= ~LPUART_CTRL_M7_MASK; /* Seven data bits and one parity bit */
600089a0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
            {
                temp |= LPUART_CTRL_M_MASK; /* Eight data bits and one parity bit */
            }
        }

        base->CTRL = temp;
600089a4:	61a3      	str	r3, [r4, #24]

#if defined(FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT
        /* set stop bit per char */
        temp       = base->BAUD & ~LPUART_BAUD_SBNS_MASK;
        base->BAUD = temp | LPUART_BAUD_SBNS((uint8_t)config->stopBitCount);
600089a6:	79eb      	ldrb	r3, [r5, #7]
        temp       = base->BAUD & ~LPUART_BAUD_SBNS_MASK;
600089a8:	6922      	ldr	r2, [r4, #16]
        base->BAUD = temp | LPUART_BAUD_SBNS((uint8_t)config->stopBitCount);
600089aa:	035b      	lsls	r3, r3, #13
        temp       = base->BAUD & ~LPUART_BAUD_SBNS_MASK;
600089ac:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
        base->BAUD = temp | LPUART_BAUD_SBNS((uint8_t)config->stopBitCount);
600089b0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
600089b4:	4313      	orrs	r3, r2
600089b6:	6123      	str	r3, [r4, #16]
           mark larger than 1.
           For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
           5 bytes are received. the last byte will be saved in FIFO but not trigger
           RX interrupt because the water mark is 2.
         */
        base->WATER = (((uint32_t)(config->rxFifoWatermark) << 16U) | config->txFifoWatermark);
600089b8:	7a6a      	ldrb	r2, [r5, #9]
600089ba:	7a2b      	ldrb	r3, [r5, #8]
600089bc:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
600089c0:	62e3      	str	r3, [r4, #44]	; 0x2c

        /* Enable tx/rx FIFO */
        base->FIFO |= (LPUART_FIFO_TXFE_MASK | LPUART_FIFO_RXFE_MASK);
600089c2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
600089c4:	f043 0388 	orr.w	r3, r3, #136	; 0x88
600089c8:	62a3      	str	r3, [r4, #40]	; 0x28

        /* Flush FIFO */
        base->FIFO |= (LPUART_FIFO_TXFLUSH_MASK | LPUART_FIFO_RXFLUSH_MASK);
600089ca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
600089cc:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
600089d0:	62a3      	str	r3, [r4, #40]	; 0x28
        temp |= (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK);
#endif

#if defined(FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT) && FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT
        /* Set the CTS configuration/TX CTS source. */
        base->MODIR |= LPUART_MODIR_TXCTSC(config->txCtsConfig) | LPUART_MODIR_TXCTSSRC(config->txCtsSource);
600089d2:	7b6b      	ldrb	r3, [r5, #13]
600089d4:	7b2a      	ldrb	r2, [r5, #12]
600089d6:	011b      	lsls	r3, r3, #4
600089d8:	6a61      	ldr	r1, [r4, #36]	; 0x24
600089da:	0152      	lsls	r2, r2, #5
600089dc:	f003 0310 	and.w	r3, r3, #16
600089e0:	f002 0220 	and.w	r2, r2, #32
600089e4:	4313      	orrs	r3, r2
600089e6:	430b      	orrs	r3, r1
600089e8:	6263      	str	r3, [r4, #36]	; 0x24
        if (true == config->enableRxRTS)
600089ea:	7aab      	ldrb	r3, [r5, #10]
600089ec:	b11b      	cbz	r3, 600089f6 <LPUART_Init+0x186>
        {
            /* Enable the receiver RTS(request-to-send) function. */
            base->MODIR |= LPUART_MODIR_RXRTSE_MASK;
600089ee:	6a63      	ldr	r3, [r4, #36]	; 0x24
600089f0:	f043 0308 	orr.w	r3, r3, #8
600089f4:	6263      	str	r3, [r4, #36]	; 0x24
        }
        if (true == config->enableTxCTS)
600089f6:	7aeb      	ldrb	r3, [r5, #11]
600089f8:	b11b      	cbz	r3, 60008a02 <LPUART_Init+0x192>
        {
            /* Enable the CTS(clear-to-send) function. */
            base->MODIR |= LPUART_MODIR_TXCTSE_MASK;
600089fa:	6a63      	ldr	r3, [r4, #36]	; 0x24
600089fc:	f043 0301 	orr.w	r3, r3, #1
60008a00:	6263      	str	r3, [r4, #36]	; 0x24
        }
#endif

        /* Set data bits order. */
        if (true == config->isMsb)
60008a02:	79a9      	ldrb	r1, [r5, #6]
        {
            temp |= LPUART_STAT_MSBF_MASK;
60008a04:	4b19      	ldr	r3, [pc, #100]	; (60008a6c <LPUART_Init+0x1fc>)
60008a06:	4a1a      	ldr	r2, [pc, #104]	; (60008a70 <LPUART_Init+0x200>)
60008a08:	2900      	cmp	r1, #0
60008a0a:	bf18      	it	ne
60008a0c:	461a      	movne	r2, r3
        else
        {
            temp &= ~LPUART_STAT_MSBF_MASK;
        }

        base->STAT |= temp;
60008a0e:	6963      	ldr	r3, [r4, #20]
60008a10:	4313      	orrs	r3, r2
60008a12:	6163      	str	r3, [r4, #20]

        /* Enable TX/RX base on configure structure. */
        temp = base->CTRL;
        if (true == config->enableTx)
60008a14:	7c2a      	ldrb	r2, [r5, #16]
        temp = base->CTRL;
60008a16:	69a3      	ldr	r3, [r4, #24]
        if (true == config->enableTx)
60008a18:	b10a      	cbz	r2, 60008a1e <LPUART_Init+0x1ae>
        {
            temp |= LPUART_CTRL_TE_MASK;
60008a1a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
        }

        if (true == config->enableRx)
60008a1e:	7c6a      	ldrb	r2, [r5, #17]
60008a20:	b10a      	cbz	r2, 60008a26 <LPUART_Init+0x1b6>
        {
            temp |= LPUART_CTRL_RE_MASK;
60008a22:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    status_t status = kStatus_Success;
60008a26:	2000      	movs	r0, #0
        }

        base->CTRL = temp;
60008a28:	61a3      	str	r3, [r4, #24]
    }

    return status;
}
60008a2a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    assert((uint8_t)FSL_FEATURE_LPUART_FIFO_SIZEn(base) > config->rxFifoWatermark);
60008a2e:	4911      	ldr	r1, [pc, #68]	; (60008a74 <LPUART_Init+0x204>)
60008a30:	23f6      	movs	r3, #246	; 0xf6
60008a32:	4a09      	ldr	r2, [pc, #36]	; (60008a58 <LPUART_Init+0x1e8>)
60008a34:	4809      	ldr	r0, [pc, #36]	; (60008a5c <LPUART_Init+0x1ec>)
60008a36:	f002 f843 	bl	6000aac0 <assert_print>
60008a3a:	21f6      	movs	r1, #246	; 0xf6
60008a3c:	e724      	b.n	60008888 <LPUART_Init+0x18>
                temp |= LPUART_CTRL_M7_MASK;
60008a3e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
60008a42:	e7af      	b.n	600089a4 <LPUART_Init+0x134>
            if (kLPUART_ParityDisabled != config->parityMode)
60008a44:	2900      	cmp	r1, #0
60008a46:	d0ad      	beq.n	600089a4 <LPUART_Init+0x134>
                temp |= LPUART_CTRL_M_MASK; /* Eight data bits and one parity bit */
60008a48:	f043 0310 	orr.w	r3, r3, #16
60008a4c:	e7aa      	b.n	600089a4 <LPUART_Init+0x134>
        status = kStatus_LPUART_BaudrateNotSupport;
60008a4e:	f240 5021 	movw	r0, #1313	; 0x521
    return status;
60008a52:	e7ea      	b.n	60008a2a <LPUART_Init+0x1ba>
60008a54:	6000ded6 	.word	0x6000ded6
60008a58:	6000ddae 	.word	0x6000ddae
60008a5c:	6000c68a 	.word	0x6000c68a
60008a60:	6000deec 	.word	0x6000deec
60008a64:	6000df06 	.word	0x6000df06
60008a68:	6000c55c 	.word	0x6000c55c
60008a6c:	e01fc000 	.word	0xe01fc000
60008a70:	c01fc000 	.word	0xc01fc000
60008a74:	6000df2d 	.word	0x6000df2d

60008a78 <LPUART_Deinit>:
 * This function waits for transmit to complete, disables TX and RX, and disables the LPUART clock.
 *
 * param base LPUART peripheral base address.
 */
void LPUART_Deinit(LPUART_Type *base)
{
60008a78:	b510      	push	{r4, lr}
    uint32_t temp;

#if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    /* Wait tx FIFO send out*/
    while (0U != ((base->WATER & LPUART_WATER_TXCOUNT_MASK) >> LPUART_WATER_TXWATER_SHIFT))
60008a7a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
60008a7c:	f413 6fe0 	tst.w	r3, #1792	; 0x700
60008a80:	d1fb      	bne.n	60008a7a <LPUART_Deinit+0x2>
    {
    }
#endif
    /* Wait last char shift out */
    while (0U == (base->STAT & LPUART_STAT_TC_MASK))
60008a82:	6943      	ldr	r3, [r0, #20]
60008a84:	025b      	lsls	r3, r3, #9
60008a86:	d5fc      	bpl.n	60008a82 <LPUART_Deinit+0xa>

#if defined(FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING) && FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING
    temp |= (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK);
#endif

    base->STAT |= temp;
60008a88:	6943      	ldr	r3, [r0, #20]

    /* Disable the module. */
    base->CTRL = 0U;
60008a8a:	2400      	movs	r4, #0
    base->STAT |= temp;
60008a8c:	f043 23c0 	orr.w	r3, r3, #3221274624	; 0xc000c000
60008a90:	f443 13f8 	orr.w	r3, r3, #2031616	; 0x1f0000
60008a94:	6143      	str	r3, [r0, #20]
    base->CTRL = 0U;
60008a96:	6184      	str	r4, [r0, #24]

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    uint32_t instance = LPUART_GetInstance(base);
60008a98:	f7ff fecc 	bl	60008834 <LPUART_GetInstance>
 *
 * @param name  Which clock to disable, see \ref clock_ip_name_t.
 */
static inline void CLOCK_DisableClock(clock_ip_name_t name)
{
    CLOCK_ControlGate(name, kCLOCK_ClockNotNeeded);
60008a9c:	4b03      	ldr	r3, [pc, #12]	; (60008aac <LPUART_Deinit+0x34>)
60008a9e:	4621      	mov	r1, r4
60008aa0:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
#if defined(LPUART_PERIPH_CLOCKS)
    (void)CLOCK_DisableClock(s_lpuartPeriphClocks[instance]);
#endif

#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
}
60008aa4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
60008aa8:	f7ff be98 	b.w	600087dc <CLOCK_ControlGate>
60008aac:	6000c55c 	.word	0x6000c55c

60008ab0 <LPUART_GetDefaultConfig>:
 *   lpuartConfig->enableRx = false;
 *
 * param config Pointer to a configuration structure.
 */
void LPUART_GetDefaultConfig(lpuart_config_t *config)
{
60008ab0:	b510      	push	{r4, lr}
    assert(NULL != config);
60008ab2:	4604      	mov	r4, r0
60008ab4:	b958      	cbnz	r0, 60008ace <LPUART_GetDefaultConfig+0x1e>
60008ab6:	490c      	ldr	r1, [pc, #48]	; (60008ae8 <LPUART_GetDefaultConfig+0x38>)
60008ab8:	f240 2306 	movw	r3, #518	; 0x206
60008abc:	480b      	ldr	r0, [pc, #44]	; (60008aec <LPUART_GetDefaultConfig+0x3c>)
60008abe:	4a0c      	ldr	r2, [pc, #48]	; (60008af0 <LPUART_GetDefaultConfig+0x40>)
60008ac0:	f001 fffe 	bl	6000aac0 <assert_print>
60008ac4:	f240 2106 	movw	r1, #518	; 0x206
60008ac8:	4809      	ldr	r0, [pc, #36]	; (60008af0 <LPUART_GetDefaultConfig+0x40>)
60008aca:	f001 fff2 	bl	6000aab2 <assert_post_action>

    /* Initializes the configure structure to zero. */
    (void)memset(config, 0, sizeof(*config));
60008ace:	2214      	movs	r2, #20
60008ad0:	2100      	movs	r1, #0
60008ad2:	f002 f85c 	bl	6000ab8e <memset>

    config->baudRate_Bps  = 115200U;
    config->parityMode    = kLPUART_ParityDisabled;
60008ad6:	2300      	movs	r3, #0
60008ad8:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
    config->txCtsConfig = kLPUART_CtsSampleAtStart;
    config->txCtsSource = kLPUART_CtsSourcePin;
#endif
    config->rxIdleType   = kLPUART_IdleTypeStartBit;
    config->rxIdleConfig = kLPUART_IdleCharacter1;
    config->enableTx     = false;
60008adc:	8223      	strh	r3, [r4, #16]
    config->parityMode    = kLPUART_ParityDisabled;
60008ade:	e9c4 2300 	strd	r2, r3, [r4]
    config->txCtsSource = kLPUART_CtsSourcePin;
60008ae2:	e9c4 3302 	strd	r3, r3, [r4, #8]
    config->enableRx     = false;
}
60008ae6:	bd10      	pop	{r4, pc}
60008ae8:	6000ded6 	.word	0x6000ded6
60008aec:	6000c68a 	.word	0x6000c68a
60008af0:	6000ddae 	.word	0x6000ddae

60008af4 <LPUART_GetStatusFlags>:
 * return LPUART status flags which are ORed by the enumerators in the _lpuart_flags.
 */
uint32_t LPUART_GetStatusFlags(LPUART_Type *base)
{
    uint32_t temp;
    temp = base->STAT;
60008af4:	6942      	ldr	r2, [r0, #20]
#if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    temp |= (base->FIFO &
60008af6:	6a83      	ldr	r3, [r0, #40]	; 0x28
            16U;
#endif
    /* Only keeps the status bits */
    temp &= (uint32_t)kLPUART_AllFlags;
    return temp;
}
60008af8:	4803      	ldr	r0, [pc, #12]	; (60008b08 <LPUART_GetStatusFlags+0x14>)
             (LPUART_FIFO_TXEMPT_MASK | LPUART_FIFO_RXEMPT_MASK | LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK)) >>
60008afa:	0c1b      	lsrs	r3, r3, #16
60008afc:	f003 03c3 	and.w	r3, r3, #195	; 0xc3
    temp |= (base->FIFO &
60008b00:	4313      	orrs	r3, r2
}
60008b02:	4018      	ands	r0, r3
60008b04:	4770      	bx	lr
60008b06:	bf00      	nop
60008b08:	c1ffc0c3 	.word	0xc1ffc0c3

60008b0c <LPUART_ClearStatusFlags>:
 * retval kStatus_LPUART_FlagCannotClearManually The flag can't be cleared by this function but
 *         it is cleared automatically by hardware.
 * retval kStatus_Success Status in the mask are cleared.
 */
status_t LPUART_ClearStatusFlags(LPUART_Type *base, uint32_t mask)
{
60008b0c:	b510      	push	{r4, lr}

    /* Only deal with the clearable flags */
    mask &= (uint32_t)kLPUART_AllClearFlags;
#if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    /* Status bits in FIFO register */
    if ((mask & ((uint32_t)kLPUART_TxFifoOverflowFlag | (uint32_t)kLPUART_RxFifoUnderflowFlag)) != 0U)
60008b0e:	078b      	lsls	r3, r1, #30
    mask &= (uint32_t)kLPUART_AllClearFlags;
60008b10:	4c0c      	ldr	r4, [pc, #48]	; (60008b44 <LPUART_ClearStatusFlags+0x38>)
60008b12:	ea04 0401 	and.w	r4, r4, r1
    if ((mask & ((uint32_t)kLPUART_TxFifoOverflowFlag | (uint32_t)kLPUART_RxFifoUnderflowFlag)) != 0U)
60008b16:	d007      	beq.n	60008b28 <LPUART_ClearStatusFlags+0x1c>
    {
        /* Get the FIFO register value and mask the rx/tx FIFO flush bits and the status bits that can be W1C in case
           they are written 1 accidentally. */
        temp = (uint32_t)base->FIFO;
60008b18:	6a82      	ldr	r2, [r0, #40]	; 0x28
        temp &= (uint32_t)(
            ~(LPUART_FIFO_TXFLUSH_MASK | LPUART_FIFO_RXFLUSH_MASK | LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK));
        temp |= (mask << 16U) & (LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK);
60008b1a:	0423      	lsls	r3, r4, #16
        temp &= (uint32_t)(
60008b1c:	f422 3270 	bic.w	r2, r2, #245760	; 0x3c000
        temp |= (mask << 16U) & (LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK);
60008b20:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
60008b24:	4313      	orrs	r3, r2
        base->FIFO = temp;
60008b26:	6283      	str	r3, [r0, #40]	; 0x28
    }
#endif
    /* Status bits in STAT register */
    /* First get the STAT register value and mask all the bits that not represent status, then OR with the status bit
     * that is to be W1C */
    temp       = (base->STAT & 0x3E000000UL) | mask;
60008b28:	6943      	ldr	r3, [r0, #20]
60008b2a:	f003 5378 	and.w	r3, r3, #1040187392	; 0x3e000000
60008b2e:	4323      	orrs	r3, r4
    base->STAT = temp;
60008b30:	6143      	str	r3, [r0, #20]
    /* If some flags still pending. */
    if (0U != (mask & LPUART_GetStatusFlags(base)))
60008b32:	f7ff ffdf 	bl	60008af4 <LPUART_GetStatusFlags>
    {
        status = kStatus_LPUART_FlagCannotClearManually;
60008b36:	4220      	tst	r0, r4
    {
        status = kStatus_Success;
    }

    return status;
}
60008b38:	f240 501a 	movw	r0, #1306	; 0x51a
60008b3c:	bf08      	it	eq
60008b3e:	2000      	moveq	r0, #0
60008b40:	bd10      	pop	{r4, pc}
60008b42:	bf00      	nop
60008b44:	c01fc003 	.word	0xc01fc003

60008b48 <GPIO_PinWrite>:
 *        - 0: corresponding pin output low-logic level.
 *        - 1: corresponding pin output high-logic level.
 */
void GPIO_PinWrite(GPIO_Type *base, uint32_t pin, uint8_t output)
{
    assert(pin < 32U);
60008b48:	291f      	cmp	r1, #31
{
60008b4a:	b508      	push	{r3, lr}
    assert(pin < 32U);
60008b4c:	d909      	bls.n	60008b62 <GPIO_PinWrite+0x1a>
60008b4e:	490a      	ldr	r1, [pc, #40]	; (60008b78 <GPIO_PinWrite+0x30>)
60008b50:	2375      	movs	r3, #117	; 0x75
60008b52:	480a      	ldr	r0, [pc, #40]	; (60008b7c <GPIO_PinWrite+0x34>)
60008b54:	4a0a      	ldr	r2, [pc, #40]	; (60008b80 <GPIO_PinWrite+0x38>)
60008b56:	f001 ffb3 	bl	6000aac0 <assert_print>
60008b5a:	2175      	movs	r1, #117	; 0x75
60008b5c:	4808      	ldr	r0, [pc, #32]	; (60008b80 <GPIO_PinWrite+0x38>)
60008b5e:	f001 ffa8 	bl	6000aab2 <assert_post_action>
    if (output == 0U)
    {
#if (defined(FSL_FEATURE_IGPIO_HAS_DR_CLEAR) && FSL_FEATURE_IGPIO_HAS_DR_CLEAR)
        base->DR_CLEAR = (1UL << pin);
60008b62:	2301      	movs	r3, #1
60008b64:	fa03 f101 	lsl.w	r1, r3, r1
    if (output == 0U)
60008b68:	b912      	cbnz	r2, 60008b70 <GPIO_PinWrite+0x28>
        base->DR_CLEAR = (1UL << pin);
60008b6a:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
        base->DR_SET = (1UL << pin);
#else
        base->DR |= (1UL << pin);  /* Set pin output to high level.*/
#endif
    }
}
60008b6e:	bd08      	pop	{r3, pc}
        base->DR_SET = (1UL << pin);
60008b70:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
}
60008b74:	e7fb      	b.n	60008b6e <GPIO_PinWrite+0x26>
60008b76:	bf00      	nop
60008b78:	6000df97 	.word	0x6000df97
60008b7c:	6000c68a 	.word	0x6000c68a
60008b80:	6000df54 	.word	0x6000df54

60008b84 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
60008b84:	b510      	push	{r4, lr}
60008b86:	4604      	mov	r4, r0
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
60008b88:	2145      	movs	r1, #69	; 0x45
60008b8a:	4803      	ldr	r0, [pc, #12]	; (60008b98 <k_sys_fatal_error_handler+0x14>)
60008b8c:	f001 ffa8 	bl	6000aae0 <z_log_minimal_printk>
	arch_system_halt(reason);
60008b90:	4620      	mov	r0, r4
60008b92:	f002 fc82 	bl	6000b49a <arch_system_halt>
60008b96:	bf00      	nop
60008b98:	6000dfa1 	.word	0x6000dfa1

60008b9c <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
60008b9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
60008b9e:	4604      	mov	r4, r0
60008ba0:	460d      	mov	r5, r1
	__asm__ volatile(
60008ba2:	f04f 0310 	mov.w	r3, #16
60008ba6:	f3ef 8711 	mrs	r7, BASEPRI
60008baa:	f383 8812 	msr	BASEPRI_MAX, r3
60008bae:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
60008bb2:	f001 fa9b 	bl	6000a0ec <z_impl_z_current_get>
60008bb6:	2c04      	cmp	r4, #4
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
60008bb8:	f04f 0200 	mov.w	r2, #0
60008bbc:	4606      	mov	r6, r0
	switch (reason) {
60008bbe:	bf98      	it	ls
60008bc0:	4b1e      	ldrls	r3, [pc, #120]	; (60008c3c <z_fatal_error+0xa0>)
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
60008bc2:	f04f 0145 	mov.w	r1, #69	; 0x45
60008bc6:	bf8c      	ite	hi
60008bc8:	4b1d      	ldrhi	r3, [pc, #116]	; (60008c40 <z_fatal_error+0xa4>)
60008bca:	f853 3024 	ldrls.w	r3, [r3, r4, lsl #2]
60008bce:	9200      	str	r2, [sp, #0]
60008bd0:	4622      	mov	r2, r4
60008bd2:	481c      	ldr	r0, [pc, #112]	; (60008c44 <z_fatal_error+0xa8>)
60008bd4:	f001 ff84 	bl	6000aae0 <z_log_minimal_printk>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
60008bd8:	b13d      	cbz	r5, 60008bea <z_fatal_error+0x4e>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
60008bda:	69eb      	ldr	r3, [r5, #28]
60008bdc:	f3c3 0308 	ubfx	r3, r3, #0, #9
60008be0:	b11b      	cbz	r3, 60008bea <z_fatal_error+0x4e>
		LOG_ERR("Fault during interrupt handling\n");
60008be2:	2145      	movs	r1, #69	; 0x45
60008be4:	4818      	ldr	r0, [pc, #96]	; (60008c48 <z_fatal_error+0xac>)
60008be6:	f001 ff7b 	bl	6000aae0 <z_log_minimal_printk>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
60008bea:	b136      	cbz	r6, 60008bfa <z_fatal_error+0x5e>
60008bec:	4630      	mov	r0, r6
60008bee:	f002 fc61 	bl	6000b4b4 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
60008bf2:	4603      	mov	r3, r0
60008bf4:	b108      	cbz	r0, 60008bfa <z_fatal_error+0x5e>
60008bf6:	7802      	ldrb	r2, [r0, #0]
60008bf8:	b902      	cbnz	r2, 60008bfc <z_fatal_error+0x60>
		thread_name = "unknown";
60008bfa:	4b14      	ldr	r3, [pc, #80]	; (60008c4c <z_fatal_error+0xb0>)
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
60008bfc:	2145      	movs	r1, #69	; 0x45
60008bfe:	4814      	ldr	r0, [pc, #80]	; (60008c50 <z_fatal_error+0xb4>)
60008c00:	4632      	mov	r2, r6
60008c02:	f001 ff6d 	bl	6000aae0 <z_log_minimal_printk>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
60008c06:	4629      	mov	r1, r5
60008c08:	4620      	mov	r0, r4
60008c0a:	f7ff ffbb 	bl	60008b84 <k_sys_fatal_error_handler>
		}
#endif /* CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	} else {
		/* Test mode */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
60008c0e:	b14d      	cbz	r5, 60008c24 <z_fatal_error+0x88>
60008c10:	69eb      	ldr	r3, [r5, #28]
60008c12:	f3c3 0308 	ubfx	r3, r3, #0, #9
60008c16:	b12b      	cbz	r3, 60008c24 <z_fatal_error+0x88>
	__asm__ volatile(
60008c18:	f387 8811 	msr	BASEPRI, r7
60008c1c:	f3bf 8f6f 	isb	sy
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
60008c20:	b003      	add	sp, #12
60008c22:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (reason == K_ERR_SPURIOUS_IRQ) {
60008c24:	2c01      	cmp	r4, #1
60008c26:	d0f7      	beq.n	60008c18 <z_fatal_error+0x7c>
60008c28:	f387 8811 	msr	BASEPRI, r7
60008c2c:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
60008c30:	4630      	mov	r0, r6
}
60008c32:	b003      	add	sp, #12
60008c34:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
60008c38:	f7fc b984 	b.w	60004f44 <z_impl_k_thread_abort>
60008c3c:	6000c4dc 	.word	0x6000c4dc
60008c40:	6000dfb5 	.word	0x6000dfb5
60008c44:	6000dfcb 	.word	0x6000dfcb
60008c48:	6000dff8 	.word	0x6000dff8
60008c4c:	6000dfc3 	.word	0x6000dfc3
60008c50:	6000e01e 	.word	0x6000e01e

60008c54 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
60008c54:	4b0f      	ldr	r3, [pc, #60]	; (60008c94 <z_sys_init_run_level+0x40>)
{
60008c56:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
60008c58:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
60008c5c:	3001      	adds	r0, #1
60008c5e:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
60008c62:	42a6      	cmp	r6, r4
60008c64:	d800      	bhi.n	60008c68 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
60008c66:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
60008c68:	e9d4 3500 	ldrd	r3, r5, [r4]
60008c6c:	4628      	mov	r0, r5
60008c6e:	4798      	blx	r3
		if (dev != NULL) {
60008c70:	b16d      	cbz	r5, 60008c8e <z_sys_init_run_level+0x3a>
			if (rc != 0) {
60008c72:	b138      	cbz	r0, 60008c84 <z_sys_init_run_level+0x30>
				if (rc < 0) {
60008c74:	2800      	cmp	r0, #0
				dev->state->init_res = rc;
60008c76:	68eb      	ldr	r3, [r5, #12]
				if (rc < 0) {
60008c78:	bfb8      	it	lt
60008c7a:	4240      	neglt	r0, r0
				if (rc > UINT8_MAX) {
60008c7c:	28ff      	cmp	r0, #255	; 0xff
60008c7e:	bfa8      	it	ge
60008c80:	20ff      	movge	r0, #255	; 0xff
				dev->state->init_res = rc;
60008c82:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
60008c84:	68ea      	ldr	r2, [r5, #12]
60008c86:	7853      	ldrb	r3, [r2, #1]
60008c88:	f043 0301 	orr.w	r3, r3, #1
60008c8c:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
60008c8e:	3408      	adds	r4, #8
60008c90:	e7e7      	b.n	60008c62 <z_sys_init_run_level+0xe>
60008c92:	bf00      	nop
60008c94:	6000c4f0 	.word	0x6000c4f0

60008c98 <bg_thread_main>:
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
60008c98:	2201      	movs	r2, #1

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
60008c9a:	2003      	movs	r0, #3
{
60008c9c:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
60008c9e:	4b09      	ldr	r3, [pc, #36]	; (60008cc4 <bg_thread_main+0x2c>)
60008ca0:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
60008ca2:	f7ff ffd7 	bl	60008c54 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
60008ca6:	f001 fe87 	bl	6000a9b8 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
60008caa:	2004      	movs	r0, #4
60008cac:	f7ff ffd2 	bl	60008c54 <z_sys_init_run_level>

	z_init_static_threads();
60008cb0:	f000 f988 	bl	60008fc4 <z_init_static_threads>
	extern int main(void);
#else
	extern void main(void);
#endif

	(void)main();
60008cb4:	f7fc fd30 	bl	60005718 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
60008cb8:	4a03      	ldr	r2, [pc, #12]	; (60008cc8 <bg_thread_main+0x30>)
60008cba:	7b13      	ldrb	r3, [r2, #12]
60008cbc:	f023 0301 	bic.w	r3, r3, #1
60008cc0:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
60008cc2:	bd08      	pop	{r3, pc}
60008cc4:	80001712 	.word	0x80001712
60008cc8:	80000a90 	.word	0x80000a90

60008ccc <z_bss_zero>:
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
60008ccc:	4806      	ldr	r0, [pc, #24]	; (60008ce8 <z_bss_zero+0x1c>)
60008cce:	2100      	movs	r1, #0
60008cd0:	4a06      	ldr	r2, [pc, #24]	; (60008cec <z_bss_zero+0x20>)
{
60008cd2:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
60008cd4:	1a12      	subs	r2, r2, r0
60008cd6:	f002 fbe9 	bl	6000b4ac <z_early_memset>
		       - (uintptr_t) &__dtcm_bss_start);
60008cda:	4805      	ldr	r0, [pc, #20]	; (60008cf0 <z_bss_zero+0x24>)
	z_early_memset(&__dtcm_bss_start, 0,
60008cdc:	4a05      	ldr	r2, [pc, #20]	; (60008cf4 <z_bss_zero+0x28>)
60008cde:	2100      	movs	r1, #0
60008ce0:	1a12      	subs	r2, r2, r0
60008ce2:	f002 fbe3 	bl	6000b4ac <z_early_memset>
}
60008ce6:	bd08      	pop	{r3, pc}
60008ce8:	80000950 	.word	0x80000950
60008cec:	80001714 	.word	0x80001714
60008cf0:	20000000 	.word	0x20000000
60008cf4:	20000000 	.word	0x20000000

60008cf8 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
60008cf8:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread = &z_idle_threads[i];
60008cfa:	23a0      	movs	r3, #160	; 0xa0
60008cfc:	4e16      	ldr	r6, [pc, #88]	; (60008d58 <z_init_cpu+0x60>)
{
60008cfe:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
60008d00:	2201      	movs	r2, #1
	struct k_thread *thread = &z_idle_threads[i];
60008d02:	fb03 6600 	mla	r6, r3, r0, r6
	z_setup_new_thread(thread, stack,
60008d06:	4b15      	ldr	r3, [pc, #84]	; (60008d5c <z_init_cpu+0x64>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
60008d08:	4d15      	ldr	r5, [pc, #84]	; (60008d60 <z_init_cpu+0x68>)
{
60008d0a:	4604      	mov	r4, r0
	z_setup_new_thread(thread, stack,
60008d0c:	9305      	str	r3, [sp, #20]
60008d0e:	230f      	movs	r3, #15
60008d10:	4914      	ldr	r1, [pc, #80]	; (60008d64 <z_init_cpu+0x6c>)
60008d12:	e9cd 3203 	strd	r3, r2, [sp, #12]
60008d16:	2300      	movs	r3, #0
60008d18:	f44f 72a0 	mov.w	r2, #320	; 0x140
60008d1c:	e9cd 3301 	strd	r3, r3, [sp, #4]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
60008d20:	2318      	movs	r3, #24
60008d22:	fb03 5500 	mla	r5, r3, r0, r5
	z_setup_new_thread(thread, stack,
60008d26:	f44f 70c0 	mov.w	r0, #384	; 0x180
60008d2a:	4b0f      	ldr	r3, [pc, #60]	; (60008d68 <z_init_cpu+0x70>)
60008d2c:	fb00 1104 	mla	r1, r0, r4, r1
60008d30:	4630      	mov	r0, r6
60008d32:	9500      	str	r5, [sp, #0]
60008d34:	f000 f894 	bl	60008e60 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
60008d38:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
60008d3a:	4a0c      	ldr	r2, [pc, #48]	; (60008d6c <z_init_cpu+0x74>)
60008d3c:	f023 0304 	bic.w	r3, r3, #4
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
60008d40:	60ee      	str	r6, [r5, #12]
	_kernel.cpus[id].id = id;
60008d42:	752c      	strb	r4, [r5, #20]
60008d44:	7373      	strb	r3, [r6, #13]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
60008d46:	f44f 6304 	mov.w	r3, #2112	; 0x840
60008d4a:	fb04 3303 	mla	r3, r4, r3, r3
60008d4e:	4413      	add	r3, r2
	_kernel.cpus[id].irq_stack =
60008d50:	606b      	str	r3, [r5, #4]
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
60008d52:	b006      	add	sp, #24
60008d54:	bd70      	pop	{r4, r5, r6, pc}
60008d56:	bf00      	nop
60008d58:	800009f0 	.word	0x800009f0
60008d5c:	6000e085 	.word	0x6000e085
60008d60:	800016c8 	.word	0x800016c8
60008d64:	800023c0 	.word	0x800023c0
60008d68:	600090f1 	.word	0x600090f1
60008d6c:	80001b80 	.word	0x80001b80

60008d70 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
60008d70:	b580      	push	{r7, lr}
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
60008d72:	2000      	movs	r0, #0
{
60008d74:	b0ae      	sub	sp, #184	; 0xb8
	z_sys_init_run_level(INIT_LEVEL_EARLY);
60008d76:	f7ff ff6d 	bl	60008c54 <z_sys_init_run_level>
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
60008d7a:	4b2a      	ldr	r3, [pc, #168]	; (60008e24 <z_cstart+0xb4>)
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
60008d7c:	f383 8808 	msr	MSP, r3
60008d80:	4d29      	ldr	r5, [pc, #164]	; (60008e28 <z_cstart+0xb8>)
60008d82:	2400      	movs	r4, #0
60008d84:	23f0      	movs	r3, #240	; 0xf0

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
60008d86:	4e29      	ldr	r6, [pc, #164]	; (60008e2c <z_cstart+0xbc>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
60008d88:	4f29      	ldr	r7, [pc, #164]	; (60008e30 <z_cstart+0xc0>)
60008d8a:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
60008d8e:	77ec      	strb	r4, [r5, #31]
60008d90:	762c      	strb	r4, [r5, #24]
60008d92:	766c      	strb	r4, [r5, #25]
60008d94:	76ac      	strb	r4, [r5, #26]
60008d96:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
60008d9a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
60008d9c:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
60008da0:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
60008da2:	f7fc f899 	bl	60004ed8 <z_arm_fault_init>
	z_arm_cpu_idle_init();
60008da6:	f7fb fcd3 	bl	60004750 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
60008daa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60008dae:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
60008db0:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
60008db2:	f7fc f9b9 	bl	60005128 <z_arm_mpu_init>
	_kernel.ready_q.cache = &z_main_thread;
60008db6:	4d1f      	ldr	r5, [pc, #124]	; (60008e34 <z_cstart+0xc4>)
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
60008db8:	f7fc f8da 	bl	60004f70 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
60008dbc:	f240 1301 	movw	r3, #257	; 0x101
	dummy_thread->resource_pool = NULL;
60008dc0:	942a      	str	r4, [sp, #168]	; 0xa8
	dummy_thread->base.user_options = K_ESSENTIAL;
60008dc2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
60008dc6:	ab06      	add	r3, sp, #24
	dummy_thread->stack_info.size = 0U;
60008dc8:	e9cd 4427 	strd	r4, r4, [sp, #156]	; 0x9c
	_current_cpu->current = dummy_thread;
60008dcc:	60b3      	str	r3, [r6, #8]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
60008dce:	f002 fb58 	bl	6000b482 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
60008dd2:	2001      	movs	r0, #1
60008dd4:	f7ff ff3e 	bl	60008c54 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
60008dd8:	2002      	movs	r0, #2
60008dda:	f7ff ff3b 	bl	60008c54 <z_sys_init_run_level>
	z_sched_init();
60008dde:	f001 f80d 	bl	60009dfc <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
60008de2:	4b15      	ldr	r3, [pc, #84]	; (60008e38 <z_cstart+0xc8>)
	_kernel.ready_q.cache = &z_main_thread;
60008de4:	61b5      	str	r5, [r6, #24]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
60008de6:	f44f 6280 	mov.w	r2, #1024	; 0x400
60008dea:	9305      	str	r3, [sp, #20]
60008dec:	2301      	movs	r3, #1
60008dee:	4913      	ldr	r1, [pc, #76]	; (60008e3c <z_cstart+0xcc>)
60008df0:	4628      	mov	r0, r5
60008df2:	9400      	str	r4, [sp, #0]
60008df4:	e9cd 4303 	strd	r4, r3, [sp, #12]
60008df8:	e9cd 4401 	strd	r4, r4, [sp, #4]
60008dfc:	463b      	mov	r3, r7
60008dfe:	f000 f82f 	bl	60008e60 <z_setup_new_thread>
60008e02:	7b6a      	ldrb	r2, [r5, #13]
60008e04:	4606      	mov	r6, r0
	z_ready_thread(&z_main_thread);
60008e06:	4628      	mov	r0, r5
60008e08:	f022 0204 	bic.w	r2, r2, #4
60008e0c:	736a      	strb	r2, [r5, #13]
60008e0e:	f000 fb3b 	bl	60009488 <z_ready_thread>
	z_init_cpu(0);
60008e12:	4620      	mov	r0, r4
60008e14:	f7ff ff70 	bl	60008cf8 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
60008e18:	463a      	mov	r2, r7
60008e1a:	4631      	mov	r1, r6
60008e1c:	4628      	mov	r0, r5
60008e1e:	f7fb fdc9 	bl	600049b4 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
60008e22:	bf00      	nop
60008e24:	800023c0 	.word	0x800023c0
60008e28:	e000ed00 	.word	0xe000ed00
60008e2c:	800016c8 	.word	0x800016c8
60008e30:	60008c99 	.word	0x60008c99
60008e34:	80000a90 	.word	0x80000a90
60008e38:	6000e08a 	.word	0x6000e08a
60008e3c:	80002540 	.word	0x80002540

60008e40 <z_impl_k_thread_name_set>:
	k_spin_unlock(&z_thread_monitor_lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
60008e40:	b510      	push	{r4, lr}
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
60008e42:	4604      	mov	r4, r0
60008e44:	b908      	cbnz	r0, 60008e4a <z_impl_k_thread_name_set+0xa>
		thread = _current;
60008e46:	4b05      	ldr	r3, [pc, #20]	; (60008e5c <z_impl_k_thread_name_set+0x1c>)
60008e48:	689c      	ldr	r4, [r3, #8]
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
60008e4a:	221f      	movs	r2, #31
60008e4c:	f104 0060 	add.w	r0, r4, #96	; 0x60
60008e50:	f001 fe62 	bl	6000ab18 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
60008e54:	2000      	movs	r0, #0
60008e56:	f884 007f 	strb.w	r0, [r4, #127]	; 0x7f

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
60008e5a:	bd10      	pop	{r4, pc}
60008e5c:	800016c8 	.word	0x800016c8

60008e60 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
60008e60:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
60008e64:	9d0d      	ldr	r5, [sp, #52]	; 0x34
60008e66:	4604      	mov	r4, r0
60008e68:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
	char *stack_ptr;

	Z_ASSERT_VALID_PRIO(prio, entry);
60008e6c:	2d0f      	cmp	r5, #15
60008e6e:	d13d      	bne.n	60008eec <z_setup_new_thread+0x8c>
60008e70:	482b      	ldr	r0, [pc, #172]	; (60008f20 <z_setup_new_thread+0xc0>)
60008e72:	4283      	cmp	r3, r0
60008e74:	d13e      	bne.n	60008ef4 <z_setup_new_thread+0x94>
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
60008e76:	f104 0058 	add.w	r0, r4, #88	; 0x58
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
60008e7a:	3207      	adds	r2, #7
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
	thread_base->thread_state = (uint8_t)initial_state;

	thread_base->prio = priority;
60008e7c:	73a5      	strb	r5, [r4, #14]
	thread_base->pended_on = NULL;
60008e7e:	2600      	movs	r6, #0
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
60008e80:	f022 0507 	bic.w	r5, r2, #7

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
60008e84:	f101 0240 	add.w	r2, r1, #64	; 0x40
	thread_base->pended_on = NULL;
60008e88:	60a6      	str	r6, [r4, #8]

	thread_base->sched_locked = 0U;
60008e8a:	73e6      	strb	r6, [r4, #15]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
60008e8c:	f105 0740 	add.w	r7, r5, #64	; 0x40
	new_thread->stack_info.delta = delta;
60008e90:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
	stack_ptr = (char *)stack + stack_obj_size;
60008e94:	440f      	add	r7, r1
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
60008e96:	e9c4 0016 	strd	r0, r0, [r4, #88]	; 0x58
	thread_base->user_options = (uint8_t)options;
60008e9a:	980e      	ldr	r0, [sp, #56]	; 0x38
	new_thread->stack_info.size = stack_buf_size;
60008e9c:	e9c4 2521 	strd	r2, r5, [r4, #132]	; 0x84
	thread_base->user_options = (uint8_t)options;
60008ea0:	7320      	strb	r0, [r4, #12]
	thread_base->thread_state = (uint8_t)initial_state;
60008ea2:	2004      	movs	r0, #4
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
60008ea4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	thread_base->thread_state = (uint8_t)initial_state;
60008ea6:	7360      	strb	r0, [r4, #13]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
60008ea8:	4620      	mov	r0, r4
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
60008eaa:	e9c4 6606 	strd	r6, r6, [r4, #24]
60008eae:	9202      	str	r2, [sp, #8]
60008eb0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
60008eb2:	9201      	str	r2, [sp, #4]
60008eb4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
60008eb6:	9200      	str	r2, [sp, #0]
60008eb8:	463a      	mov	r2, r7
60008eba:	f7fb fd4b 	bl	60004954 <arch_new_thread>
	new_thread->init_data = NULL;
60008ebe:	6566      	str	r6, [r4, #84]	; 0x54
	if (name != NULL) {
60008ec0:	f1b8 0f00 	cmp.w	r8, #0
60008ec4:	d029      	beq.n	60008f1a <z_setup_new_thread+0xba>
		strncpy(new_thread->name, name,
60008ec6:	221f      	movs	r2, #31
60008ec8:	4641      	mov	r1, r8
60008eca:	f104 0060 	add.w	r0, r4, #96	; 0x60
60008ece:	f001 fe23 	bl	6000ab18 <strncpy>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
60008ed2:	f884 607f 	strb.w	r6, [r4, #127]	; 0x7f
	if (!_current) {
60008ed6:	4b13      	ldr	r3, [pc, #76]	; (60008f24 <z_setup_new_thread+0xc4>)
60008ed8:	689b      	ldr	r3, [r3, #8]
60008eda:	b10b      	cbz	r3, 60008ee0 <z_setup_new_thread+0x80>
	new_thread->resource_pool = _current->resource_pool;
60008edc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
}
60008ee0:	4638      	mov	r0, r7
60008ee2:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
60008ee6:	b004      	add	sp, #16
60008ee8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	Z_ASSERT_VALID_PRIO(prio, entry);
60008eec:	f105 0010 	add.w	r0, r5, #16
60008ef0:	281e      	cmp	r0, #30
60008ef2:	d9c0      	bls.n	60008e76 <z_setup_new_thread+0x16>
60008ef4:	f44f 7306 	mov.w	r3, #536	; 0x218
60008ef8:	4a0b      	ldr	r2, [pc, #44]	; (60008f28 <z_setup_new_thread+0xc8>)
60008efa:	490c      	ldr	r1, [pc, #48]	; (60008f2c <z_setup_new_thread+0xcc>)
60008efc:	480c      	ldr	r0, [pc, #48]	; (60008f30 <z_setup_new_thread+0xd0>)
60008efe:	f001 fddf 	bl	6000aac0 <assert_print>
60008f02:	4629      	mov	r1, r5
60008f04:	480b      	ldr	r0, [pc, #44]	; (60008f34 <z_setup_new_thread+0xd4>)
60008f06:	f06f 030f 	mvn.w	r3, #15
60008f0a:	220e      	movs	r2, #14
60008f0c:	f001 fdd8 	bl	6000aac0 <assert_print>
60008f10:	f44f 7106 	mov.w	r1, #536	; 0x218
60008f14:	4804      	ldr	r0, [pc, #16]	; (60008f28 <z_setup_new_thread+0xc8>)
60008f16:	f001 fdcc 	bl	6000aab2 <assert_post_action>
		new_thread->name[0] = '\0';
60008f1a:	f884 8060 	strb.w	r8, [r4, #96]	; 0x60
60008f1e:	e7da      	b.n	60008ed6 <z_setup_new_thread+0x76>
60008f20:	600090f1 	.word	0x600090f1
60008f24:	800016c8 	.word	0x800016c8
60008f28:	6000e092 	.word	0x6000e092
60008f2c:	6000e0b5 	.word	0x6000e0b5
60008f30:	6000c68a 	.word	0x6000c68a
60008f34:	6000e135 	.word	0x6000e135

60008f38 <z_impl_k_thread_create>:
{
60008f38:	b5f0      	push	{r4, r5, r6, r7, lr}
60008f3a:	b087      	sub	sp, #28
60008f3c:	4604      	mov	r4, r0
60008f3e:	e9dd 7612 	ldrd	r7, r6, [sp, #72]	; 0x48
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
60008f42:	f3ef 8505 	mrs	r5, IPSR
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
60008f46:	b175      	cbz	r5, 60008f66 <z_impl_k_thread_create+0x2e>
60008f48:	4919      	ldr	r1, [pc, #100]	; (60008fb0 <z_impl_k_thread_create+0x78>)
60008f4a:	f240 2387 	movw	r3, #647	; 0x287
60008f4e:	4a19      	ldr	r2, [pc, #100]	; (60008fb4 <z_impl_k_thread_create+0x7c>)
60008f50:	4819      	ldr	r0, [pc, #100]	; (60008fb8 <z_impl_k_thread_create+0x80>)
60008f52:	f001 fdb5 	bl	6000aac0 <assert_print>
60008f56:	4819      	ldr	r0, [pc, #100]	; (60008fbc <z_impl_k_thread_create+0x84>)
60008f58:	f001 fdb2 	bl	6000aac0 <assert_print>
60008f5c:	f240 2187 	movw	r1, #647	; 0x287
60008f60:	4814      	ldr	r0, [pc, #80]	; (60008fb4 <z_impl_k_thread_create+0x7c>)
60008f62:	f001 fda6 	bl	6000aab2 <assert_post_action>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
60008f66:	9505      	str	r5, [sp, #20]
60008f68:	9d10      	ldr	r5, [sp, #64]	; 0x40
60008f6a:	9504      	str	r5, [sp, #16]
60008f6c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
60008f6e:	9503      	str	r5, [sp, #12]
60008f70:	9d0e      	ldr	r5, [sp, #56]	; 0x38
60008f72:	9502      	str	r5, [sp, #8]
60008f74:	9d0d      	ldr	r5, [sp, #52]	; 0x34
60008f76:	9501      	str	r5, [sp, #4]
60008f78:	9d0c      	ldr	r5, [sp, #48]	; 0x30
60008f7a:	9500      	str	r5, [sp, #0]
60008f7c:	f7ff ff70 	bl	60008e60 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
60008f80:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
60008f84:	bf08      	it	eq
60008f86:	f1b7 3fff 	cmpeq.w	r7, #4294967295	; 0xffffffff
60008f8a:	d005      	beq.n	60008f98 <z_impl_k_thread_create+0x60>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
60008f8c:	ea56 0307 	orrs.w	r3, r6, r7
60008f90:	d105      	bne.n	60008f9e <z_impl_k_thread_create+0x66>
	z_sched_start(thread);
60008f92:	4620      	mov	r0, r4
60008f94:	f000 fb00 	bl	60009598 <z_sched_start>
}
60008f98:	4620      	mov	r0, r4
60008f9a:	b007      	add	sp, #28
60008f9c:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
60008f9e:	463a      	mov	r2, r7
60008fa0:	4633      	mov	r3, r6
60008fa2:	4907      	ldr	r1, [pc, #28]	; (60008fc0 <z_impl_k_thread_create+0x88>)
60008fa4:	f104 0018 	add.w	r0, r4, #24
60008fa8:	f001 fa90 	bl	6000a4cc <z_add_timeout>
60008fac:	e7f4      	b.n	60008f98 <z_impl_k_thread_create+0x60>
60008fae:	bf00      	nop
60008fb0:	6000e166 	.word	0x6000e166
60008fb4:	6000e092 	.word	0x6000e092
60008fb8:	6000c68a 	.word	0x6000c68a
60008fbc:	6000e178 	.word	0x6000e178
60008fc0:	60009cad 	.word	0x60009cad

60008fc4 <z_init_static_threads>:
{
60008fc4:	b5f0      	push	{r4, r5, r6, r7, lr}
60008fc6:	4c31      	ldr	r4, [pc, #196]	; (6000908c <z_init_static_threads+0xc8>)
60008fc8:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
60008fca:	4d31      	ldr	r5, [pc, #196]	; (60009090 <z_init_static_threads+0xcc>)
60008fcc:	42ac      	cmp	r4, r5
60008fce:	4626      	mov	r6, r4
60008fd0:	d92a      	bls.n	60009028 <z_init_static_threads+0x64>
60008fd2:	4930      	ldr	r1, [pc, #192]	; (60009094 <z_init_static_threads+0xd0>)
60008fd4:	f240 23ee 	movw	r3, #750	; 0x2ee
60008fd8:	4a2f      	ldr	r2, [pc, #188]	; (60009098 <z_init_static_threads+0xd4>)
60008fda:	4830      	ldr	r0, [pc, #192]	; (6000909c <z_init_static_threads+0xd8>)
60008fdc:	f001 fd70 	bl	6000aac0 <assert_print>
60008fe0:	482f      	ldr	r0, [pc, #188]	; (600090a0 <z_init_static_threads+0xdc>)
60008fe2:	f001 fd6d 	bl	6000aac0 <assert_print>
60008fe6:	f240 21ee 	movw	r1, #750	; 0x2ee
	_FOREACH_STATIC_THREAD(thread_data) {
60008fea:	482b      	ldr	r0, [pc, #172]	; (60009098 <z_init_static_threads+0xd4>)
60008fec:	f001 fd61 	bl	6000aab2 <assert_post_action>
		z_setup_new_thread(
60008ff0:	f854 3c04 	ldr.w	r3, [r4, #-4]
60008ff4:	9305      	str	r3, [sp, #20]
60008ff6:	f854 3c0c 	ldr.w	r3, [r4, #-12]
60008ffa:	9304      	str	r3, [sp, #16]
60008ffc:	f854 3c10 	ldr.w	r3, [r4, #-16]
60009000:	9303      	str	r3, [sp, #12]
60009002:	f854 3c14 	ldr.w	r3, [r4, #-20]
60009006:	9302      	str	r3, [sp, #8]
60009008:	f854 3c18 	ldr.w	r3, [r4, #-24]
6000900c:	9301      	str	r3, [sp, #4]
6000900e:	f854 3c1c 	ldr.w	r3, [r4, #-28]
60009012:	9300      	str	r3, [sp, #0]
60009014:	e954 2309 	ldrd	r2, r3, [r4, #-36]	; 0x24
60009018:	e954 010b 	ldrd	r0, r1, [r4, #-44]	; 0x2c
6000901c:	f7ff ff20 	bl	60008e60 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
60009020:	f854 3c2c 	ldr.w	r3, [r4, #-44]
60009024:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
60009026:	e7d1      	b.n	60008fcc <z_init_static_threads+0x8>
60009028:	42ae      	cmp	r6, r5
6000902a:	f104 042c 	add.w	r4, r4, #44	; 0x2c
6000902e:	d3df      	bcc.n	60008ff0 <z_init_static_threads+0x2c>
	_FOREACH_STATIC_THREAD(thread_data) {
60009030:	4c16      	ldr	r4, [pc, #88]	; (6000908c <z_init_static_threads+0xc8>)
60009032:	260a      	movs	r6, #10
60009034:	4f1b      	ldr	r7, [pc, #108]	; (600090a4 <z_init_static_threads+0xe0>)
	k_sched_lock();
60009036:	f000 fb01 	bl	6000963c <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
6000903a:	42ac      	cmp	r4, r5
6000903c:	d920      	bls.n	60009080 <z_init_static_threads+0xbc>
6000903e:	4915      	ldr	r1, [pc, #84]	; (60009094 <z_init_static_threads+0xd0>)
60009040:	f240 330d 	movw	r3, #781	; 0x30d
60009044:	4a14      	ldr	r2, [pc, #80]	; (60009098 <z_init_static_threads+0xd4>)
60009046:	4815      	ldr	r0, [pc, #84]	; (6000909c <z_init_static_threads+0xd8>)
60009048:	f001 fd3a 	bl	6000aac0 <assert_print>
6000904c:	4814      	ldr	r0, [pc, #80]	; (600090a0 <z_init_static_threads+0xdc>)
6000904e:	f001 fd37 	bl	6000aac0 <assert_print>
60009052:	f240 310d 	movw	r1, #781	; 0x30d
60009056:	e7c8      	b.n	60008fea <z_init_static_threads+0x26>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
60009058:	6a62      	ldr	r2, [r4, #36]	; 0x24
6000905a:	1c53      	adds	r3, r2, #1
6000905c:	d009      	beq.n	60009072 <z_init_static_threads+0xae>
					    K_MSEC(thread_data->init_delay));
6000905e:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
			schedule_new_thread(thread_data->init_thread,
60009062:	6820      	ldr	r0, [r4, #0]
60009064:	fb82 2306 	smull	r2, r3, r2, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
60009068:	ea52 0103 	orrs.w	r1, r2, r3
6000906c:	d103      	bne.n	60009076 <z_init_static_threads+0xb2>
	z_sched_start(thread);
6000906e:	f000 fa93 	bl	60009598 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
60009072:	342c      	adds	r4, #44	; 0x2c
60009074:	e7e1      	b.n	6000903a <z_init_static_threads+0x76>
60009076:	4639      	mov	r1, r7
60009078:	3018      	adds	r0, #24
6000907a:	f001 fa27 	bl	6000a4cc <z_add_timeout>
6000907e:	e7f8      	b.n	60009072 <z_init_static_threads+0xae>
60009080:	d3ea      	bcc.n	60009058 <z_init_static_threads+0x94>
}
60009082:	b007      	add	sp, #28
60009084:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
60009088:	f000 bb44 	b.w	60009714 <k_sched_unlock>
6000908c:	6000ba88 	.word	0x6000ba88
60009090:	6000ba88 	.word	0x6000ba88
60009094:	6000e19d 	.word	0x6000e19d
60009098:	6000e092 	.word	0x6000e092
6000909c:	6000c68a 	.word	0x6000c68a
600090a0:	6000e1ca 	.word	0x6000e1ca
600090a4:	60009cad 	.word	0x60009cad

600090a8 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
600090a8:	6800      	ldr	r0, [r0, #0]

	if (thread_cpu != 0U) {
600090aa:	b138      	cbz	r0, 600090bc <z_spin_lock_valid+0x14>
		if ((thread_cpu & 3U) == _current_cpu->id) {
600090ac:	4b04      	ldr	r3, [pc, #16]	; (600090c0 <z_spin_lock_valid+0x18>)
600090ae:	f000 0003 	and.w	r0, r0, #3
600090b2:	7d1b      	ldrb	r3, [r3, #20]
600090b4:	1ac0      	subs	r0, r0, r3
600090b6:	bf18      	it	ne
600090b8:	2001      	movne	r0, #1
600090ba:	4770      	bx	lr
			return false;
		}
	}
	return true;
600090bc:	2001      	movs	r0, #1
}
600090be:	4770      	bx	lr
600090c0:	800016c8 	.word	0x800016c8

600090c4 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
600090c4:	4a05      	ldr	r2, [pc, #20]	; (600090dc <z_spin_unlock_valid+0x18>)
{
600090c6:	4603      	mov	r3, r0
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
600090c8:	7d11      	ldrb	r1, [r2, #20]
600090ca:	6892      	ldr	r2, [r2, #8]
600090cc:	430a      	orrs	r2, r1
600090ce:	6801      	ldr	r1, [r0, #0]
600090d0:	2000      	movs	r0, #0
600090d2:	4291      	cmp	r1, r2
		return false;
	}
	l->thread_cpu = 0;
600090d4:	bf04      	itt	eq
600090d6:	6018      	streq	r0, [r3, #0]
	return true;
600090d8:	2001      	moveq	r0, #1
}
600090da:	4770      	bx	lr
600090dc:	800016c8 	.word	0x800016c8

600090e0 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
600090e0:	4b02      	ldr	r3, [pc, #8]	; (600090ec <z_spin_lock_set_owner+0xc>)
600090e2:	7d1a      	ldrb	r2, [r3, #20]
600090e4:	689b      	ldr	r3, [r3, #8]
600090e6:	4313      	orrs	r3, r2
600090e8:	6003      	str	r3, [r0, #0]
}
600090ea:	4770      	bx	lr
600090ec:	800016c8 	.word	0x800016c8

600090f0 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
600090f0:	b508      	push	{r3, lr}
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
600090f2:	4b0d      	ldr	r3, [pc, #52]	; (60009128 <idle+0x38>)
600090f4:	689b      	ldr	r3, [r3, #8]
600090f6:	f993 300e 	ldrsb.w	r3, [r3, #14]
600090fa:	2b00      	cmp	r3, #0
600090fc:	da09      	bge.n	60009112 <idle+0x22>
600090fe:	490b      	ldr	r1, [pc, #44]	; (6000912c <idle+0x3c>)
60009100:	2327      	movs	r3, #39	; 0x27
60009102:	480b      	ldr	r0, [pc, #44]	; (60009130 <idle+0x40>)
60009104:	4a0b      	ldr	r2, [pc, #44]	; (60009134 <idle+0x44>)
60009106:	f001 fcdb 	bl	6000aac0 <assert_print>
6000910a:	2127      	movs	r1, #39	; 0x27
6000910c:	4809      	ldr	r0, [pc, #36]	; (60009134 <idle+0x44>)
6000910e:	f001 fcd0 	bl	6000aab2 <assert_post_action>
	__asm__ volatile(
60009112:	f04f 0210 	mov.w	r2, #16
60009116:	f3ef 8311 	mrs	r3, BASEPRI
6000911a:	f382 8812 	msr	BASEPRI_MAX, r2
6000911e:	f3bf 8f6f 	isb	sy
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
60009122:	f7fb fb1b 	bl	6000475c <arch_cpu_idle>
60009126:	e7f4      	b.n	60009112 <idle+0x22>
60009128:	800016c8 	.word	0x800016c8
6000912c:	6000e20a 	.word	0x6000e20a
60009130:	6000c68a 	.word	0x6000c68a
60009134:	6000e1e9 	.word	0x6000e1e9

60009138 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
60009138:	b538      	push	{r3, r4, r5, lr}
6000913a:	4604      	mov	r4, r0
6000913c:	f04f 0310 	mov.w	r3, #16
60009140:	f3ef 8511 	mrs	r5, BASEPRI
60009144:	f383 8812 	msr	BASEPRI_MAX, r3
60009148:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000914c:	4815      	ldr	r0, [pc, #84]	; (600091a4 <z_impl_k_sem_give+0x6c>)
6000914e:	f7ff ffab 	bl	600090a8 <z_spin_lock_valid>
60009152:	b968      	cbnz	r0, 60009170 <z_impl_k_sem_give+0x38>
60009154:	2394      	movs	r3, #148	; 0x94
60009156:	4a14      	ldr	r2, [pc, #80]	; (600091a8 <z_impl_k_sem_give+0x70>)
60009158:	4914      	ldr	r1, [pc, #80]	; (600091ac <z_impl_k_sem_give+0x74>)
6000915a:	4815      	ldr	r0, [pc, #84]	; (600091b0 <z_impl_k_sem_give+0x78>)
6000915c:	f001 fcb0 	bl	6000aac0 <assert_print>
60009160:	4910      	ldr	r1, [pc, #64]	; (600091a4 <z_impl_k_sem_give+0x6c>)
60009162:	4814      	ldr	r0, [pc, #80]	; (600091b4 <z_impl_k_sem_give+0x7c>)
60009164:	f001 fcac 	bl	6000aac0 <assert_print>
60009168:	2194      	movs	r1, #148	; 0x94
6000916a:	480f      	ldr	r0, [pc, #60]	; (600091a8 <z_impl_k_sem_give+0x70>)
6000916c:	f001 fca1 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
60009170:	480c      	ldr	r0, [pc, #48]	; (600091a4 <z_impl_k_sem_give+0x6c>)
60009172:	f7ff ffb5 	bl	600090e0 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
60009176:	4620      	mov	r0, r4
60009178:	f000 fdf0 	bl	60009d5c <z_unpend_first_thread>

	if (thread != NULL) {
6000917c:	b150      	cbz	r0, 60009194 <z_impl_k_sem_give+0x5c>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
6000917e:	2200      	movs	r2, #0
60009180:	f8c0 2098 	str.w	r2, [r0, #152]	; 0x98
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
60009184:	f000 f980 	bl	60009488 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
60009188:	4629      	mov	r1, r5
6000918a:	4806      	ldr	r0, [pc, #24]	; (600091a4 <z_impl_k_sem_give+0x6c>)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
6000918c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
60009190:	f000 b9c0 	b.w	60009514 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
60009194:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
60009198:	429a      	cmp	r2, r3
6000919a:	bf18      	it	ne
6000919c:	3301      	addne	r3, #1
6000919e:	60a3      	str	r3, [r4, #8]
}
600091a0:	e7f2      	b.n	60009188 <z_impl_k_sem_give+0x50>
600091a2:	bf00      	nop
600091a4:	800016ec 	.word	0x800016ec
600091a8:	6000d5ed 	.word	0x6000d5ed
600091ac:	6000d61a 	.word	0x6000d61a
600091b0:	6000c68a 	.word	0x6000c68a
600091b4:	6000d62f 	.word	0x6000d62f

600091b8 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
600091b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
600091ba:	4604      	mov	r4, r0
600091bc:	4616      	mov	r6, r2
600091be:	461d      	mov	r5, r3
600091c0:	f3ef 8305 	mrs	r3, IPSR
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
600091c4:	b17b      	cbz	r3, 600091e6 <z_impl_k_sem_take+0x2e>
600091c6:	ea52 0305 	orrs.w	r3, r2, r5
600091ca:	d00c      	beq.n	600091e6 <z_impl_k_sem_take+0x2e>
600091cc:	492d      	ldr	r1, [pc, #180]	; (60009284 <z_impl_k_sem_take+0xcc>)
600091ce:	2379      	movs	r3, #121	; 0x79
600091d0:	4a2d      	ldr	r2, [pc, #180]	; (60009288 <z_impl_k_sem_take+0xd0>)
600091d2:	482e      	ldr	r0, [pc, #184]	; (6000928c <z_impl_k_sem_take+0xd4>)
600091d4:	f001 fc74 	bl	6000aac0 <assert_print>
600091d8:	482d      	ldr	r0, [pc, #180]	; (60009290 <z_impl_k_sem_take+0xd8>)
600091da:	f001 fc71 	bl	6000aac0 <assert_print>
600091de:	2179      	movs	r1, #121	; 0x79
600091e0:	4829      	ldr	r0, [pc, #164]	; (60009288 <z_impl_k_sem_take+0xd0>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
600091e2:	f001 fc66 	bl	6000aab2 <assert_post_action>
600091e6:	f04f 0310 	mov.w	r3, #16
600091ea:	f3ef 8711 	mrs	r7, BASEPRI
600091ee:	f383 8812 	msr	BASEPRI_MAX, r3
600091f2:	f3bf 8f6f 	isb	sy
600091f6:	4827      	ldr	r0, [pc, #156]	; (60009294 <z_impl_k_sem_take+0xdc>)
600091f8:	f7ff ff56 	bl	600090a8 <z_spin_lock_valid>
600091fc:	b960      	cbnz	r0, 60009218 <z_impl_k_sem_take+0x60>
600091fe:	2394      	movs	r3, #148	; 0x94
60009200:	4a25      	ldr	r2, [pc, #148]	; (60009298 <z_impl_k_sem_take+0xe0>)
60009202:	4926      	ldr	r1, [pc, #152]	; (6000929c <z_impl_k_sem_take+0xe4>)
60009204:	4821      	ldr	r0, [pc, #132]	; (6000928c <z_impl_k_sem_take+0xd4>)
60009206:	f001 fc5b 	bl	6000aac0 <assert_print>
6000920a:	4922      	ldr	r1, [pc, #136]	; (60009294 <z_impl_k_sem_take+0xdc>)
6000920c:	4824      	ldr	r0, [pc, #144]	; (600092a0 <z_impl_k_sem_take+0xe8>)
6000920e:	f001 fc57 	bl	6000aac0 <assert_print>
60009212:	2194      	movs	r1, #148	; 0x94
60009214:	4820      	ldr	r0, [pc, #128]	; (60009298 <z_impl_k_sem_take+0xe0>)
60009216:	e7e4      	b.n	600091e2 <z_impl_k_sem_take+0x2a>
	z_spin_lock_set_owner(l);
60009218:	481e      	ldr	r0, [pc, #120]	; (60009294 <z_impl_k_sem_take+0xdc>)
6000921a:	f7ff ff61 	bl	600090e0 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
6000921e:	68a3      	ldr	r3, [r4, #8]
60009220:	b1c3      	cbz	r3, 60009254 <z_impl_k_sem_take+0x9c>
		sem->count--;
60009222:	3b01      	subs	r3, #1
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009224:	481b      	ldr	r0, [pc, #108]	; (60009294 <z_impl_k_sem_take+0xdc>)
60009226:	60a3      	str	r3, [r4, #8]
60009228:	f7ff ff4c 	bl	600090c4 <z_spin_unlock_valid>
6000922c:	b958      	cbnz	r0, 60009246 <z_impl_k_sem_take+0x8e>
6000922e:	23c2      	movs	r3, #194	; 0xc2
60009230:	4a19      	ldr	r2, [pc, #100]	; (60009298 <z_impl_k_sem_take+0xe0>)
60009232:	491c      	ldr	r1, [pc, #112]	; (600092a4 <z_impl_k_sem_take+0xec>)
60009234:	4815      	ldr	r0, [pc, #84]	; (6000928c <z_impl_k_sem_take+0xd4>)
60009236:	f001 fc43 	bl	6000aac0 <assert_print>
6000923a:	4916      	ldr	r1, [pc, #88]	; (60009294 <z_impl_k_sem_take+0xdc>)
6000923c:	481a      	ldr	r0, [pc, #104]	; (600092a8 <z_impl_k_sem_take+0xf0>)
6000923e:	f001 fc3f 	bl	6000aac0 <assert_print>
60009242:	21c2      	movs	r1, #194	; 0xc2
60009244:	e7e6      	b.n	60009214 <z_impl_k_sem_take+0x5c>
	__asm__ volatile(
60009246:	f387 8811 	msr	BASEPRI, r7
6000924a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
6000924e:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
60009250:	b003      	add	sp, #12
60009252:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
60009254:	ea56 0305 	orrs.w	r3, r6, r5
60009258:	d10b      	bne.n	60009272 <z_impl_k_sem_take+0xba>
6000925a:	480e      	ldr	r0, [pc, #56]	; (60009294 <z_impl_k_sem_take+0xdc>)
6000925c:	f7ff ff32 	bl	600090c4 <z_spin_unlock_valid>
60009260:	2800      	cmp	r0, #0
60009262:	d0e4      	beq.n	6000922e <z_impl_k_sem_take+0x76>
60009264:	f387 8811 	msr	BASEPRI, r7
60009268:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
6000926c:	f06f 000f 	mvn.w	r0, #15
60009270:	e7ee      	b.n	60009250 <z_impl_k_sem_take+0x98>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
60009272:	4622      	mov	r2, r4
60009274:	4639      	mov	r1, r7
60009276:	4807      	ldr	r0, [pc, #28]	; (60009294 <z_impl_k_sem_take+0xdc>)
60009278:	e9cd 6500 	strd	r6, r5, [sp]
6000927c:	f000 fc18 	bl	60009ab0 <z_pend_curr>
	return ret;
60009280:	e7e6      	b.n	60009250 <z_impl_k_sem_take+0x98>
60009282:	bf00      	nop
60009284:	6000e252 	.word	0x6000e252
60009288:	6000e232 	.word	0x6000e232
6000928c:	6000c68a 	.word	0x6000c68a
60009290:	6000e2a0 	.word	0x6000e2a0
60009294:	800016ec 	.word	0x800016ec
60009298:	6000d5ed 	.word	0x6000d5ed
6000929c:	6000d61a 	.word	0x6000d61a
600092a0:	6000d62f 	.word	0x6000d62f
600092a4:	6000d647 	.word	0x6000d647
600092a8:	6000d65e 	.word	0x6000d65e

600092ac <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(struct k_thread *curr)
{
600092ac:	b538      	push	{r3, r4, r5, lr}
	int ret = slice_ticks;
600092ae:	4d07      	ldr	r5, [pc, #28]	; (600092cc <z_reset_time_slice+0x20>)
600092b0:	682c      	ldr	r4, [r5, #0]
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time(curr) != 0) {
600092b2:	b154      	cbz	r4, 600092ca <z_reset_time_slice+0x1e>
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
600092b4:	f7fd fb38 	bl	60006928 <sys_clock_elapsed>
600092b8:	4b05      	ldr	r3, [pc, #20]	; (600092d0 <z_reset_time_slice+0x24>)
600092ba:	4404      	add	r4, r0
		z_set_timeout_expiry(slice_time(curr), false);
600092bc:	2100      	movs	r1, #0
600092be:	6828      	ldr	r0, [r5, #0]
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
600092c0:	611c      	str	r4, [r3, #16]
	}
}
600092c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_set_timeout_expiry(slice_time(curr), false);
600092c6:	f001 ba13 	b.w	6000a6f0 <z_set_timeout_expiry>
}
600092ca:	bd38      	pop	{r3, r4, r5, pc}
600092cc:	800016f8 	.word	0x800016f8
600092d0:	800016c8 	.word	0x800016c8

600092d4 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
600092d4:	b538      	push	{r3, r4, r5, lr}
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
600092d6:	4d14      	ldr	r5, [pc, #80]	; (60009328 <update_cache+0x54>)
600092d8:	462b      	mov	r3, r5
600092da:	f853 4f1c 	ldr.w	r4, [r3, #28]!
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
600092de:	429c      	cmp	r4, r3
600092e0:	d000      	beq.n	600092e4 <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
600092e2:	b904      	cbnz	r4, 600092e6 <update_cache+0x12>
600092e4:	68ec      	ldr	r4, [r5, #12]
	__ASSERT(_current != NULL, "");
600092e6:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
600092e8:	b9a8      	cbnz	r0, 60009316 <update_cache+0x42>
	__ASSERT(_current != NULL, "");
600092ea:	b963      	cbnz	r3, 60009306 <update_cache+0x32>
600092ec:	490f      	ldr	r1, [pc, #60]	; (6000932c <update_cache+0x58>)
600092ee:	2389      	movs	r3, #137	; 0x89
600092f0:	4a0f      	ldr	r2, [pc, #60]	; (60009330 <update_cache+0x5c>)
600092f2:	4810      	ldr	r0, [pc, #64]	; (60009334 <update_cache+0x60>)
600092f4:	f001 fbe4 	bl	6000aac0 <assert_print>
600092f8:	480f      	ldr	r0, [pc, #60]	; (60009338 <update_cache+0x64>)
600092fa:	f001 fbe1 	bl	6000aac0 <assert_print>
600092fe:	2189      	movs	r1, #137	; 0x89
60009300:	480b      	ldr	r0, [pc, #44]	; (60009330 <update_cache+0x5c>)
60009302:	f001 fbd6 	bl	6000aab2 <assert_post_action>
	if (z_is_thread_prevented_from_running(_current)) {
60009306:	7b5a      	ldrb	r2, [r3, #13]
60009308:	06d2      	lsls	r2, r2, #27
6000930a:	d104      	bne.n	60009316 <update_cache+0x42>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
6000930c:	69a2      	ldr	r2, [r4, #24]
6000930e:	b912      	cbnz	r2, 60009316 <update_cache+0x42>
	if (is_preempt(_current) || is_metairq(thread)) {
60009310:	89da      	ldrh	r2, [r3, #14]
60009312:	2a7f      	cmp	r2, #127	; 0x7f
60009314:	d805      	bhi.n	60009322 <update_cache+0x4e>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
60009316:	429c      	cmp	r4, r3
60009318:	d002      	beq.n	60009320 <update_cache+0x4c>
			z_reset_time_slice(thread);
6000931a:	4620      	mov	r0, r4
6000931c:	f7ff ffc6 	bl	600092ac <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
60009320:	4623      	mov	r3, r4
60009322:	61ab      	str	r3, [r5, #24]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
60009324:	bd38      	pop	{r3, r4, r5, pc}
60009326:	bf00      	nop
60009328:	800016c8 	.word	0x800016c8
6000932c:	6000e2c5 	.word	0x6000e2c5
60009330:	6000e2a3 	.word	0x6000e2a3
60009334:	6000c68a 	.word	0x6000c68a
60009338:	6000e2a0 	.word	0x6000e2a0

6000933c <ready_thread>:
	}
#endif
}

static void ready_thread(struct k_thread *thread)
{
6000933c:	b570      	push	{r4, r5, r6, lr}
#endif

	/* If thread is queued already, do not try and added it to the
	 * run queue again
	 */
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
6000933e:	f990 300d 	ldrsb.w	r3, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
60009342:	7b42      	ldrb	r2, [r0, #13]
60009344:	2b00      	cmp	r3, #0
60009346:	db38      	blt.n	600093ba <ready_thread+0x7e>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
60009348:	06d3      	lsls	r3, r2, #27
6000934a:	d136      	bne.n	600093ba <ready_thread+0x7e>
	return node->next != NULL;
6000934c:	6983      	ldr	r3, [r0, #24]
6000934e:	2b00      	cmp	r3, #0
60009350:	d133      	bne.n	600093ba <ready_thread+0x7e>
	thread->base.thread_state |= _THREAD_QUEUED;
60009352:	f062 027f 	orn	r2, r2, #127	; 0x7f
60009356:	7342      	strb	r2, [r0, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
60009358:	4a18      	ldr	r2, [pc, #96]	; (600093bc <ready_thread+0x80>)
6000935a:	4290      	cmp	r0, r2
6000935c:	d109      	bne.n	60009372 <ready_thread+0x36>
6000935e:	4918      	ldr	r1, [pc, #96]	; (600093c0 <ready_thread+0x84>)
60009360:	23bb      	movs	r3, #187	; 0xbb
60009362:	4818      	ldr	r0, [pc, #96]	; (600093c4 <ready_thread+0x88>)
60009364:	4a18      	ldr	r2, [pc, #96]	; (600093c8 <ready_thread+0x8c>)
60009366:	f001 fbab 	bl	6000aac0 <assert_print>
6000936a:	21bb      	movs	r1, #187	; 0xbb
6000936c:	4816      	ldr	r0, [pc, #88]	; (600093c8 <ready_thread+0x8c>)
6000936e:	f001 fba0 	bl	6000aab2 <assert_post_action>
	return list->head == list;
60009372:	4916      	ldr	r1, [pc, #88]	; (600093cc <ready_thread+0x90>)
60009374:	460a      	mov	r2, r1
60009376:	f852 4f1c 	ldr.w	r4, [r2, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
6000937a:	4294      	cmp	r4, r2
6000937c:	bf18      	it	ne
6000937e:	4623      	movne	r3, r4
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
60009380:	6a0c      	ldr	r4, [r1, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
60009382:	b923      	cbnz	r3, 6000938e <ready_thread+0x52>
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
	node->prev = tail;
60009384:	e9c0 2400 	strd	r2, r4, [r0]

	tail->next = node;
60009388:	6020      	str	r0, [r4, #0]
	list->tail = node;
6000938a:	6208      	str	r0, [r1, #32]
}
6000938c:	e00c      	b.n	600093a8 <ready_thread+0x6c>
	int32_t b1 = thread_1->base.prio;
6000938e:	f990 500e 	ldrsb.w	r5, [r0, #14]
	int32_t b2 = thread_2->base.prio;
60009392:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
60009396:	42b5      	cmp	r5, r6
60009398:	d00b      	beq.n	600093b2 <ready_thread+0x76>
		if (z_sched_prio_cmp(thread, t) > 0) {
6000939a:	42ae      	cmp	r6, r5
6000939c:	dd09      	ble.n	600093b2 <ready_thread+0x76>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
6000939e:	685a      	ldr	r2, [r3, #4]

	node->prev = prev;
	node->next = successor;
600093a0:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
600093a4:	6010      	str	r0, [r2, #0]
	successor->prev = node;
600093a6:	6058      	str	r0, [r3, #4]
		SYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_ready, thread);

		queue_thread(thread);
		update_cache(0);
600093a8:	2000      	movs	r0, #0
		flag_ipi();
	}
}
600093aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		update_cache(0);
600093ae:	f7ff bf91 	b.w	600092d4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
600093b2:	42a3      	cmp	r3, r4
600093b4:	d0e6      	beq.n	60009384 <ready_thread+0x48>
600093b6:	681b      	ldr	r3, [r3, #0]
600093b8:	e7e3      	b.n	60009382 <ready_thread+0x46>
}
600093ba:	bd70      	pop	{r4, r5, r6, pc}
600093bc:	800009f0 	.word	0x800009f0
600093c0:	6000e2ec 	.word	0x6000e2ec
600093c4:	6000c68a 	.word	0x6000c68a
600093c8:	6000e2a3 	.word	0x6000e2a3
600093cc:	800016c8 	.word	0x800016c8

600093d0 <k_sched_time_slice_set>:
{
600093d0:	b570      	push	{r4, r5, r6, lr}
600093d2:	4604      	mov	r4, r0
600093d4:	460d      	mov	r5, r1
	__asm__ volatile(
600093d6:	f04f 0310 	mov.w	r3, #16
600093da:	f3ef 8611 	mrs	r6, BASEPRI
600093de:	f383 8812 	msr	BASEPRI_MAX, r3
600093e2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
600093e6:	481e      	ldr	r0, [pc, #120]	; (60009460 <k_sched_time_slice_set+0x90>)
600093e8:	f7ff fe5e 	bl	600090a8 <z_spin_lock_valid>
600093ec:	b968      	cbnz	r0, 6000940a <k_sched_time_slice_set+0x3a>
600093ee:	2394      	movs	r3, #148	; 0x94
600093f0:	4a1c      	ldr	r2, [pc, #112]	; (60009464 <k_sched_time_slice_set+0x94>)
600093f2:	491d      	ldr	r1, [pc, #116]	; (60009468 <k_sched_time_slice_set+0x98>)
600093f4:	481d      	ldr	r0, [pc, #116]	; (6000946c <k_sched_time_slice_set+0x9c>)
600093f6:	f001 fb63 	bl	6000aac0 <assert_print>
600093fa:	4919      	ldr	r1, [pc, #100]	; (60009460 <k_sched_time_slice_set+0x90>)
600093fc:	481c      	ldr	r0, [pc, #112]	; (60009470 <k_sched_time_slice_set+0xa0>)
600093fe:	f001 fb5f 	bl	6000aac0 <assert_print>
60009402:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009404:	4817      	ldr	r0, [pc, #92]	; (60009464 <k_sched_time_slice_set+0x94>)
60009406:	f001 fb54 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
6000940a:	4815      	ldr	r0, [pc, #84]	; (60009460 <k_sched_time_slice_set+0x90>)
6000940c:	f7ff fe68 	bl	600090e0 <z_spin_lock_set_owner>
			return ((uint32_t)t) * (to_hz / from_hz);
60009410:	230a      	movs	r3, #10
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
60009412:	2c00      	cmp	r4, #0
60009414:	fb04 f303 	mul.w	r3, r4, r3
60009418:	dd02      	ble.n	60009420 <k_sched_time_slice_set+0x50>
			slice_ticks = MAX(2, slice_ticks);
6000941a:	2b02      	cmp	r3, #2
6000941c:	bfb8      	it	lt
6000941e:	2302      	movlt	r3, #2
		_current_cpu->slice_ticks = 0;
60009420:	4a14      	ldr	r2, [pc, #80]	; (60009474 <k_sched_time_slice_set+0xa4>)
60009422:	2100      	movs	r1, #0
60009424:	6111      	str	r1, [r2, #16]
		slice_ticks = k_ms_to_ticks_ceil32(slice);
60009426:	4914      	ldr	r1, [pc, #80]	; (60009478 <k_sched_time_slice_set+0xa8>)
		z_reset_time_slice(_current);
60009428:	6890      	ldr	r0, [r2, #8]
		slice_ticks = k_ms_to_ticks_ceil32(slice);
6000942a:	600b      	str	r3, [r1, #0]
		slice_max_prio = prio;
6000942c:	4b13      	ldr	r3, [pc, #76]	; (6000947c <k_sched_time_slice_set+0xac>)
6000942e:	601d      	str	r5, [r3, #0]
		z_reset_time_slice(_current);
60009430:	f7ff ff3c 	bl	600092ac <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009434:	480a      	ldr	r0, [pc, #40]	; (60009460 <k_sched_time_slice_set+0x90>)
60009436:	f7ff fe45 	bl	600090c4 <z_spin_unlock_valid>
6000943a:	b958      	cbnz	r0, 60009454 <k_sched_time_slice_set+0x84>
6000943c:	23c2      	movs	r3, #194	; 0xc2
6000943e:	4a09      	ldr	r2, [pc, #36]	; (60009464 <k_sched_time_slice_set+0x94>)
60009440:	490f      	ldr	r1, [pc, #60]	; (60009480 <k_sched_time_slice_set+0xb0>)
60009442:	480a      	ldr	r0, [pc, #40]	; (6000946c <k_sched_time_slice_set+0x9c>)
60009444:	f001 fb3c 	bl	6000aac0 <assert_print>
60009448:	4905      	ldr	r1, [pc, #20]	; (60009460 <k_sched_time_slice_set+0x90>)
6000944a:	480e      	ldr	r0, [pc, #56]	; (60009484 <k_sched_time_slice_set+0xb4>)
6000944c:	f001 fb38 	bl	6000aac0 <assert_print>
60009450:	21c2      	movs	r1, #194	; 0xc2
60009452:	e7d7      	b.n	60009404 <k_sched_time_slice_set+0x34>
	__asm__ volatile(
60009454:	f386 8811 	msr	BASEPRI, r6
60009458:	f3bf 8f6f 	isb	sy
}
6000945c:	bd70      	pop	{r4, r5, r6, pc}
6000945e:	bf00      	nop
60009460:	800016fc 	.word	0x800016fc
60009464:	6000d5ed 	.word	0x6000d5ed
60009468:	6000d61a 	.word	0x6000d61a
6000946c:	6000c68a 	.word	0x6000c68a
60009470:	6000d62f 	.word	0x6000d62f
60009474:	800016c8 	.word	0x800016c8
60009478:	800016f8 	.word	0x800016f8
6000947c:	800016f4 	.word	0x800016f4
60009480:	6000d647 	.word	0x6000d647
60009484:	6000d65e 	.word	0x6000d65e

60009488 <z_ready_thread>:

void z_ready_thread(struct k_thread *thread)
{
60009488:	b538      	push	{r3, r4, r5, lr}
6000948a:	4604      	mov	r4, r0
	__asm__ volatile(
6000948c:	f04f 0310 	mov.w	r3, #16
60009490:	f3ef 8511 	mrs	r5, BASEPRI
60009494:	f383 8812 	msr	BASEPRI_MAX, r3
60009498:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000949c:	4816      	ldr	r0, [pc, #88]	; (600094f8 <z_ready_thread+0x70>)
6000949e:	f7ff fe03 	bl	600090a8 <z_spin_lock_valid>
600094a2:	b968      	cbnz	r0, 600094c0 <z_ready_thread+0x38>
600094a4:	2394      	movs	r3, #148	; 0x94
600094a6:	4a15      	ldr	r2, [pc, #84]	; (600094fc <z_ready_thread+0x74>)
600094a8:	4915      	ldr	r1, [pc, #84]	; (60009500 <z_ready_thread+0x78>)
600094aa:	4816      	ldr	r0, [pc, #88]	; (60009504 <z_ready_thread+0x7c>)
600094ac:	f001 fb08 	bl	6000aac0 <assert_print>
600094b0:	4911      	ldr	r1, [pc, #68]	; (600094f8 <z_ready_thread+0x70>)
600094b2:	4815      	ldr	r0, [pc, #84]	; (60009508 <z_ready_thread+0x80>)
600094b4:	f001 fb04 	bl	6000aac0 <assert_print>
600094b8:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
600094ba:	4810      	ldr	r0, [pc, #64]	; (600094fc <z_ready_thread+0x74>)
600094bc:	f001 faf9 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
600094c0:	480d      	ldr	r0, [pc, #52]	; (600094f8 <z_ready_thread+0x70>)
600094c2:	f7ff fe0d 	bl	600090e0 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		if (!thread_active_elsewhere(thread)) {
			ready_thread(thread);
600094c6:	4620      	mov	r0, r4
600094c8:	f7ff ff38 	bl	6000933c <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
600094cc:	480a      	ldr	r0, [pc, #40]	; (600094f8 <z_ready_thread+0x70>)
600094ce:	f7ff fdf9 	bl	600090c4 <z_spin_unlock_valid>
600094d2:	b958      	cbnz	r0, 600094ec <z_ready_thread+0x64>
600094d4:	23c2      	movs	r3, #194	; 0xc2
600094d6:	4a09      	ldr	r2, [pc, #36]	; (600094fc <z_ready_thread+0x74>)
600094d8:	490c      	ldr	r1, [pc, #48]	; (6000950c <z_ready_thread+0x84>)
600094da:	480a      	ldr	r0, [pc, #40]	; (60009504 <z_ready_thread+0x7c>)
600094dc:	f001 faf0 	bl	6000aac0 <assert_print>
600094e0:	4905      	ldr	r1, [pc, #20]	; (600094f8 <z_ready_thread+0x70>)
600094e2:	480b      	ldr	r0, [pc, #44]	; (60009510 <z_ready_thread+0x88>)
600094e4:	f001 faec 	bl	6000aac0 <assert_print>
600094e8:	21c2      	movs	r1, #194	; 0xc2
600094ea:	e7e6      	b.n	600094ba <z_ready_thread+0x32>
	__asm__ volatile(
600094ec:	f385 8811 	msr	BASEPRI, r5
600094f0:	f3bf 8f6f 	isb	sy
		}
	}
}
600094f4:	bd38      	pop	{r3, r4, r5, pc}
600094f6:	bf00      	nop
600094f8:	800016fc 	.word	0x800016fc
600094fc:	6000d5ed 	.word	0x6000d5ed
60009500:	6000d61a 	.word	0x6000d61a
60009504:	6000c68a 	.word	0x6000c68a
60009508:	6000d62f 	.word	0x6000d62f
6000950c:	6000d647 	.word	0x6000d647
60009510:	6000d65e 	.word	0x6000d65e

60009514 <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
60009514:	b570      	push	{r4, r5, r6, lr}
60009516:	4604      	mov	r4, r0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
60009518:	460d      	mov	r5, r1
6000951a:	b9e9      	cbnz	r1, 60009558 <z_reschedule+0x44>
6000951c:	f3ef 8605 	mrs	r6, IPSR
60009520:	b9d6      	cbnz	r6, 60009558 <z_reschedule+0x44>
	new_thread = _kernel.ready_q.cache;
60009522:	4b18      	ldr	r3, [pc, #96]	; (60009584 <z_reschedule+0x70>)
	if (resched(key.key) && need_swap()) {
60009524:	699a      	ldr	r2, [r3, #24]
60009526:	689b      	ldr	r3, [r3, #8]
60009528:	429a      	cmp	r2, r3
6000952a:	d015      	beq.n	60009558 <z_reschedule+0x44>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000952c:	f7ff fdca 	bl	600090c4 <z_spin_unlock_valid>
60009530:	b968      	cbnz	r0, 6000954e <z_reschedule+0x3a>
60009532:	23e1      	movs	r3, #225	; 0xe1
60009534:	4a14      	ldr	r2, [pc, #80]	; (60009588 <z_reschedule+0x74>)
60009536:	4915      	ldr	r1, [pc, #84]	; (6000958c <z_reschedule+0x78>)
60009538:	4815      	ldr	r0, [pc, #84]	; (60009590 <z_reschedule+0x7c>)
6000953a:	f001 fac1 	bl	6000aac0 <assert_print>
6000953e:	4621      	mov	r1, r4
60009540:	4814      	ldr	r0, [pc, #80]	; (60009594 <z_reschedule+0x80>)
60009542:	f001 fabd 	bl	6000aac0 <assert_print>
60009546:	21e1      	movs	r1, #225	; 0xe1
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009548:	480f      	ldr	r0, [pc, #60]	; (60009588 <z_reschedule+0x74>)
6000954a:	f001 fab2 	bl	6000aab2 <assert_post_action>
	ret = arch_swap(key);
6000954e:	4630      	mov	r0, r6
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
60009550:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
60009554:	f7fb b9a6 	b.w	600048a4 <arch_swap>
60009558:	4620      	mov	r0, r4
6000955a:	f7ff fdb3 	bl	600090c4 <z_spin_unlock_valid>
6000955e:	b958      	cbnz	r0, 60009578 <z_reschedule+0x64>
60009560:	23c2      	movs	r3, #194	; 0xc2
60009562:	4a09      	ldr	r2, [pc, #36]	; (60009588 <z_reschedule+0x74>)
60009564:	4909      	ldr	r1, [pc, #36]	; (6000958c <z_reschedule+0x78>)
60009566:	480a      	ldr	r0, [pc, #40]	; (60009590 <z_reschedule+0x7c>)
60009568:	f001 faaa 	bl	6000aac0 <assert_print>
6000956c:	4621      	mov	r1, r4
6000956e:	4809      	ldr	r0, [pc, #36]	; (60009594 <z_reschedule+0x80>)
60009570:	f001 faa6 	bl	6000aac0 <assert_print>
60009574:	21c2      	movs	r1, #194	; 0xc2
60009576:	e7e7      	b.n	60009548 <z_reschedule+0x34>
60009578:	f385 8811 	msr	BASEPRI, r5
6000957c:	f3bf 8f6f 	isb	sy
60009580:	bd70      	pop	{r4, r5, r6, pc}
60009582:	bf00      	nop
60009584:	800016c8 	.word	0x800016c8
60009588:	6000d5ed 	.word	0x6000d5ed
6000958c:	6000d647 	.word	0x6000d647
60009590:	6000c68a 	.word	0x6000c68a
60009594:	6000d65e 	.word	0x6000d65e

60009598 <z_sched_start>:
{
60009598:	b538      	push	{r3, r4, r5, lr}
6000959a:	4604      	mov	r4, r0
	__asm__ volatile(
6000959c:	f04f 0310 	mov.w	r3, #16
600095a0:	f3ef 8511 	mrs	r5, BASEPRI
600095a4:	f383 8812 	msr	BASEPRI_MAX, r3
600095a8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
600095ac:	481c      	ldr	r0, [pc, #112]	; (60009620 <z_sched_start+0x88>)
600095ae:	f7ff fd7b 	bl	600090a8 <z_spin_lock_valid>
600095b2:	b968      	cbnz	r0, 600095d0 <z_sched_start+0x38>
600095b4:	2394      	movs	r3, #148	; 0x94
600095b6:	4a1b      	ldr	r2, [pc, #108]	; (60009624 <z_sched_start+0x8c>)
600095b8:	491b      	ldr	r1, [pc, #108]	; (60009628 <z_sched_start+0x90>)
600095ba:	481c      	ldr	r0, [pc, #112]	; (6000962c <z_sched_start+0x94>)
600095bc:	f001 fa80 	bl	6000aac0 <assert_print>
600095c0:	4917      	ldr	r1, [pc, #92]	; (60009620 <z_sched_start+0x88>)
600095c2:	481b      	ldr	r0, [pc, #108]	; (60009630 <z_sched_start+0x98>)
600095c4:	f001 fa7c 	bl	6000aac0 <assert_print>
600095c8:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
600095ca:	4816      	ldr	r0, [pc, #88]	; (60009624 <z_sched_start+0x8c>)
600095cc:	f001 fa71 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
600095d0:	4813      	ldr	r0, [pc, #76]	; (60009620 <z_sched_start+0x88>)
600095d2:	f7ff fd85 	bl	600090e0 <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
600095d6:	7b63      	ldrb	r3, [r4, #13]
	if (z_has_thread_started(thread)) {
600095d8:	075a      	lsls	r2, r3, #29
600095da:	d414      	bmi.n	60009606 <z_sched_start+0x6e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
600095dc:	4810      	ldr	r0, [pc, #64]	; (60009620 <z_sched_start+0x88>)
600095de:	f7ff fd71 	bl	600090c4 <z_spin_unlock_valid>
600095e2:	b958      	cbnz	r0, 600095fc <z_sched_start+0x64>
600095e4:	23c2      	movs	r3, #194	; 0xc2
600095e6:	4a0f      	ldr	r2, [pc, #60]	; (60009624 <z_sched_start+0x8c>)
600095e8:	4912      	ldr	r1, [pc, #72]	; (60009634 <z_sched_start+0x9c>)
600095ea:	4810      	ldr	r0, [pc, #64]	; (6000962c <z_sched_start+0x94>)
600095ec:	f001 fa68 	bl	6000aac0 <assert_print>
600095f0:	490b      	ldr	r1, [pc, #44]	; (60009620 <z_sched_start+0x88>)
600095f2:	4811      	ldr	r0, [pc, #68]	; (60009638 <z_sched_start+0xa0>)
600095f4:	f001 fa64 	bl	6000aac0 <assert_print>
600095f8:	21c2      	movs	r1, #194	; 0xc2
600095fa:	e7e6      	b.n	600095ca <z_sched_start+0x32>
	__asm__ volatile(
600095fc:	f385 8811 	msr	BASEPRI, r5
60009600:	f3bf 8f6f 	isb	sy
}
60009604:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
60009606:	f023 0304 	bic.w	r3, r3, #4
	ready_thread(thread);
6000960a:	4620      	mov	r0, r4
6000960c:	7363      	strb	r3, [r4, #13]
6000960e:	f7ff fe95 	bl	6000933c <ready_thread>
	z_reschedule(&sched_spinlock, key);
60009612:	4629      	mov	r1, r5
60009614:	4802      	ldr	r0, [pc, #8]	; (60009620 <z_sched_start+0x88>)
}
60009616:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&sched_spinlock, key);
6000961a:	f7ff bf7b 	b.w	60009514 <z_reschedule>
6000961e:	bf00      	nop
60009620:	800016fc 	.word	0x800016fc
60009624:	6000d5ed 	.word	0x6000d5ed
60009628:	6000d61a 	.word	0x6000d61a
6000962c:	6000c68a 	.word	0x6000c68a
60009630:	6000d62f 	.word	0x6000d62f
60009634:	6000d647 	.word	0x6000d647
60009638:	6000d65e 	.word	0x6000d65e

6000963c <k_sched_lock>:
		signal_pending_ipi();
	}
}

void k_sched_lock(void)
{
6000963c:	b510      	push	{r4, lr}
	__asm__ volatile(
6000963e:	f04f 0310 	mov.w	r3, #16
60009642:	f3ef 8411 	mrs	r4, BASEPRI
60009646:	f383 8812 	msr	BASEPRI_MAX, r3
6000964a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000964e:	4825      	ldr	r0, [pc, #148]	; (600096e4 <k_sched_lock+0xa8>)
60009650:	f7ff fd2a 	bl	600090a8 <z_spin_lock_valid>
60009654:	b960      	cbnz	r0, 60009670 <k_sched_lock+0x34>
60009656:	2394      	movs	r3, #148	; 0x94
60009658:	4a23      	ldr	r2, [pc, #140]	; (600096e8 <k_sched_lock+0xac>)
6000965a:	4924      	ldr	r1, [pc, #144]	; (600096ec <k_sched_lock+0xb0>)
6000965c:	4824      	ldr	r0, [pc, #144]	; (600096f0 <k_sched_lock+0xb4>)
6000965e:	f001 fa2f 	bl	6000aac0 <assert_print>
60009662:	4920      	ldr	r1, [pc, #128]	; (600096e4 <k_sched_lock+0xa8>)
60009664:	4823      	ldr	r0, [pc, #140]	; (600096f4 <k_sched_lock+0xb8>)
60009666:	f001 fa2b 	bl	6000aac0 <assert_print>
6000966a:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000966c:	481e      	ldr	r0, [pc, #120]	; (600096e8 <k_sched_lock+0xac>)
6000966e:	e010      	b.n	60009692 <k_sched_lock+0x56>
	z_spin_lock_set_owner(l);
60009670:	481c      	ldr	r0, [pc, #112]	; (600096e4 <k_sched_lock+0xa8>)
60009672:	f7ff fd35 	bl	600090e0 <z_spin_lock_set_owner>
60009676:	f3ef 8305 	mrs	r3, IPSR
	}
}

static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
6000967a:	b163      	cbz	r3, 60009696 <k_sched_lock+0x5a>
6000967c:	491e      	ldr	r1, [pc, #120]	; (600096f8 <k_sched_lock+0xbc>)
6000967e:	23fd      	movs	r3, #253	; 0xfd
60009680:	4a1e      	ldr	r2, [pc, #120]	; (600096fc <k_sched_lock+0xc0>)
60009682:	481b      	ldr	r0, [pc, #108]	; (600096f0 <k_sched_lock+0xb4>)
60009684:	f001 fa1c 	bl	6000aac0 <assert_print>
60009688:	481d      	ldr	r0, [pc, #116]	; (60009700 <k_sched_lock+0xc4>)
6000968a:	f001 fa19 	bl	6000aac0 <assert_print>
6000968e:	21fd      	movs	r1, #253	; 0xfd
60009690:	481a      	ldr	r0, [pc, #104]	; (600096fc <k_sched_lock+0xc0>)
60009692:	f001 fa0e 	bl	6000aab2 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1U, "");
60009696:	4b1b      	ldr	r3, [pc, #108]	; (60009704 <k_sched_lock+0xc8>)
60009698:	689a      	ldr	r2, [r3, #8]
6000969a:	7bd3      	ldrb	r3, [r2, #15]
6000969c:	2b01      	cmp	r3, #1
6000969e:	d10a      	bne.n	600096b6 <k_sched_lock+0x7a>
600096a0:	4919      	ldr	r1, [pc, #100]	; (60009708 <k_sched_lock+0xcc>)
600096a2:	23fe      	movs	r3, #254	; 0xfe
600096a4:	4a15      	ldr	r2, [pc, #84]	; (600096fc <k_sched_lock+0xc0>)
600096a6:	4812      	ldr	r0, [pc, #72]	; (600096f0 <k_sched_lock+0xb4>)
600096a8:	f001 fa0a 	bl	6000aac0 <assert_print>
600096ac:	4814      	ldr	r0, [pc, #80]	; (60009700 <k_sched_lock+0xc4>)
600096ae:	f001 fa07 	bl	6000aac0 <assert_print>
600096b2:	21fe      	movs	r1, #254	; 0xfe
600096b4:	e7ec      	b.n	60009690 <k_sched_lock+0x54>

	--_current->base.sched_locked;
600096b6:	3b01      	subs	r3, #1
600096b8:	73d3      	strb	r3, [r2, #15]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
600096ba:	480a      	ldr	r0, [pc, #40]	; (600096e4 <k_sched_lock+0xa8>)
600096bc:	f7ff fd02 	bl	600090c4 <z_spin_unlock_valid>
600096c0:	b958      	cbnz	r0, 600096da <k_sched_lock+0x9e>
600096c2:	23c2      	movs	r3, #194	; 0xc2
600096c4:	4a08      	ldr	r2, [pc, #32]	; (600096e8 <k_sched_lock+0xac>)
600096c6:	4911      	ldr	r1, [pc, #68]	; (6000970c <k_sched_lock+0xd0>)
600096c8:	4809      	ldr	r0, [pc, #36]	; (600096f0 <k_sched_lock+0xb4>)
600096ca:	f001 f9f9 	bl	6000aac0 <assert_print>
600096ce:	4905      	ldr	r1, [pc, #20]	; (600096e4 <k_sched_lock+0xa8>)
600096d0:	480f      	ldr	r0, [pc, #60]	; (60009710 <k_sched_lock+0xd4>)
600096d2:	f001 f9f5 	bl	6000aac0 <assert_print>
600096d6:	21c2      	movs	r1, #194	; 0xc2
600096d8:	e7c8      	b.n	6000966c <k_sched_lock+0x30>
	__asm__ volatile(
600096da:	f384 8811 	msr	BASEPRI, r4
600096de:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
600096e2:	bd10      	pop	{r4, pc}
600096e4:	800016fc 	.word	0x800016fc
600096e8:	6000d5ed 	.word	0x6000d5ed
600096ec:	6000d61a 	.word	0x6000d61a
600096f0:	6000c68a 	.word	0x6000c68a
600096f4:	6000d62f 	.word	0x6000d62f
600096f8:	6000e166 	.word	0x6000e166
600096fc:	6000e30d 	.word	0x6000e30d
60009700:	6000e2a0 	.word	0x6000e2a0
60009704:	800016c8 	.word	0x800016c8
60009708:	6000e338 	.word	0x6000e338
6000970c:	6000d647 	.word	0x6000d647
60009710:	6000d65e 	.word	0x6000d65e

60009714 <k_sched_unlock>:

void k_sched_unlock(void)
{
60009714:	b510      	push	{r4, lr}
	__asm__ volatile(
60009716:	f04f 0310 	mov.w	r3, #16
6000971a:	f3ef 8411 	mrs	r4, BASEPRI
6000971e:	f383 8812 	msr	BASEPRI_MAX, r3
60009722:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
60009726:	4829      	ldr	r0, [pc, #164]	; (600097cc <k_sched_unlock+0xb8>)
60009728:	f7ff fcbe 	bl	600090a8 <z_spin_lock_valid>
6000972c:	b960      	cbnz	r0, 60009748 <k_sched_unlock+0x34>
6000972e:	2394      	movs	r3, #148	; 0x94
60009730:	4a27      	ldr	r2, [pc, #156]	; (600097d0 <k_sched_unlock+0xbc>)
60009732:	4928      	ldr	r1, [pc, #160]	; (600097d4 <k_sched_unlock+0xc0>)
60009734:	4828      	ldr	r0, [pc, #160]	; (600097d8 <k_sched_unlock+0xc4>)
60009736:	f001 f9c3 	bl	6000aac0 <assert_print>
6000973a:	4924      	ldr	r1, [pc, #144]	; (600097cc <k_sched_unlock+0xb8>)
6000973c:	4827      	ldr	r0, [pc, #156]	; (600097dc <k_sched_unlock+0xc8>)
6000973e:	f001 f9bf 	bl	6000aac0 <assert_print>
60009742:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009744:	4822      	ldr	r0, [pc, #136]	; (600097d0 <k_sched_unlock+0xbc>)
60009746:	e013      	b.n	60009770 <k_sched_unlock+0x5c>
	z_spin_lock_set_owner(l);
60009748:	4820      	ldr	r0, [pc, #128]	; (600097cc <k_sched_unlock+0xb8>)
6000974a:	f7ff fcc9 	bl	600090e0 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		__ASSERT(_current->base.sched_locked != 0U, "");
6000974e:	4b24      	ldr	r3, [pc, #144]	; (600097e0 <k_sched_unlock+0xcc>)
60009750:	689a      	ldr	r2, [r3, #8]
60009752:	7bd3      	ldrb	r3, [r2, #15]
60009754:	b973      	cbnz	r3, 60009774 <k_sched_unlock+0x60>
60009756:	4923      	ldr	r1, [pc, #140]	; (600097e4 <k_sched_unlock+0xd0>)
60009758:	f240 33eb 	movw	r3, #1003	; 0x3eb
6000975c:	4a22      	ldr	r2, [pc, #136]	; (600097e8 <k_sched_unlock+0xd4>)
6000975e:	481e      	ldr	r0, [pc, #120]	; (600097d8 <k_sched_unlock+0xc4>)
60009760:	f001 f9ae 	bl	6000aac0 <assert_print>
60009764:	4821      	ldr	r0, [pc, #132]	; (600097ec <k_sched_unlock+0xd8>)
60009766:	f001 f9ab 	bl	6000aac0 <assert_print>
6000976a:	f240 31eb 	movw	r1, #1003	; 0x3eb
6000976e:	481e      	ldr	r0, [pc, #120]	; (600097e8 <k_sched_unlock+0xd4>)
60009770:	f001 f99f 	bl	6000aab2 <assert_post_action>
60009774:	f3ef 8005 	mrs	r0, IPSR
		__ASSERT(!arch_is_in_isr(), "");
60009778:	b160      	cbz	r0, 60009794 <k_sched_unlock+0x80>
6000977a:	491d      	ldr	r1, [pc, #116]	; (600097f0 <k_sched_unlock+0xdc>)
6000977c:	f44f 737b 	mov.w	r3, #1004	; 0x3ec
60009780:	4a19      	ldr	r2, [pc, #100]	; (600097e8 <k_sched_unlock+0xd4>)
60009782:	4815      	ldr	r0, [pc, #84]	; (600097d8 <k_sched_unlock+0xc4>)
60009784:	f001 f99c 	bl	6000aac0 <assert_print>
60009788:	4818      	ldr	r0, [pc, #96]	; (600097ec <k_sched_unlock+0xd8>)
6000978a:	f001 f999 	bl	6000aac0 <assert_print>
6000978e:	f44f 717b 	mov.w	r1, #1004	; 0x3ec
60009792:	e7ec      	b.n	6000976e <k_sched_unlock+0x5a>

		++_current->base.sched_locked;
60009794:	3301      	adds	r3, #1
60009796:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
60009798:	f7ff fd9c 	bl	600092d4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000979c:	480b      	ldr	r0, [pc, #44]	; (600097cc <k_sched_unlock+0xb8>)
6000979e:	f7ff fc91 	bl	600090c4 <z_spin_unlock_valid>
600097a2:	b958      	cbnz	r0, 600097bc <k_sched_unlock+0xa8>
600097a4:	23c2      	movs	r3, #194	; 0xc2
600097a6:	4a0a      	ldr	r2, [pc, #40]	; (600097d0 <k_sched_unlock+0xbc>)
600097a8:	4912      	ldr	r1, [pc, #72]	; (600097f4 <k_sched_unlock+0xe0>)
600097aa:	480b      	ldr	r0, [pc, #44]	; (600097d8 <k_sched_unlock+0xc4>)
600097ac:	f001 f988 	bl	6000aac0 <assert_print>
600097b0:	4906      	ldr	r1, [pc, #24]	; (600097cc <k_sched_unlock+0xb8>)
600097b2:	4811      	ldr	r0, [pc, #68]	; (600097f8 <k_sched_unlock+0xe4>)
600097b4:	f001 f984 	bl	6000aac0 <assert_print>
600097b8:	21c2      	movs	r1, #194	; 0xc2
600097ba:	e7c3      	b.n	60009744 <k_sched_unlock+0x30>
	__asm__ volatile(
600097bc:	f384 8811 	msr	BASEPRI, r4
600097c0:	f3bf 8f6f 	isb	sy
		_current, _current->base.sched_locked);

	SYS_PORT_TRACING_FUNC(k_thread, sched_unlock);

	z_reschedule_unlocked();
}
600097c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
600097c8:	f001 be84 	b.w	6000b4d4 <z_reschedule_unlocked>
600097cc:	800016fc 	.word	0x800016fc
600097d0:	6000d5ed 	.word	0x6000d5ed
600097d4:	6000d61a 	.word	0x6000d61a
600097d8:	6000c68a 	.word	0x6000c68a
600097dc:	6000d62f 	.word	0x6000d62f
600097e0:	800016c8 	.word	0x800016c8
600097e4:	6000e369 	.word	0x6000e369
600097e8:	6000e2a3 	.word	0x6000e2a3
600097ec:	6000e2a0 	.word	0x6000e2a0
600097f0:	6000e166 	.word	0x6000e166
600097f4:	6000d647 	.word	0x6000d647
600097f8:	6000d65e 	.word	0x6000d65e

600097fc <z_priq_dumb_remove>:
#endif
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
600097fc:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
600097fe:	4b0b      	ldr	r3, [pc, #44]	; (6000982c <z_priq_dumb_remove+0x30>)
60009800:	4299      	cmp	r1, r3
60009802:	d10b      	bne.n	6000981c <z_priq_dumb_remove+0x20>
60009804:	490a      	ldr	r1, [pc, #40]	; (60009830 <z_priq_dumb_remove+0x34>)
60009806:	f240 4377 	movw	r3, #1143	; 0x477
6000980a:	480a      	ldr	r0, [pc, #40]	; (60009834 <z_priq_dumb_remove+0x38>)
6000980c:	4a0a      	ldr	r2, [pc, #40]	; (60009838 <z_priq_dumb_remove+0x3c>)
6000980e:	f001 f957 	bl	6000aac0 <assert_print>
60009812:	f240 4177 	movw	r1, #1143	; 0x477
60009816:	4808      	ldr	r0, [pc, #32]	; (60009838 <z_priq_dumb_remove+0x3c>)
60009818:	f001 f94b 	bl	6000aab2 <assert_post_action>
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
6000981c:	e9d1 3200 	ldrd	r3, r2, [r1]

	prev->next = next;
60009820:	6013      	str	r3, [r2, #0]
	next->prev = prev;
60009822:	605a      	str	r2, [r3, #4]
	node->next = NULL;
60009824:	2300      	movs	r3, #0
	node->prev = NULL;
60009826:	e9c1 3300 	strd	r3, r3, [r1]

	sys_dlist_remove(&thread->base.qnode_dlist);
}
6000982a:	bd08      	pop	{r3, pc}
6000982c:	800009f0 	.word	0x800009f0
60009830:	6000e2ec 	.word	0x6000e2ec
60009834:	6000c68a 	.word	0x6000c68a
60009838:	6000e2a3 	.word	0x6000e2a3

6000983c <move_thread_to_end_of_prio_q>:
{
6000983c:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
6000983e:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
60009842:	4604      	mov	r4, r0
	return (thread->base.thread_state & state) != 0U;
60009844:	7b43      	ldrb	r3, [r0, #13]
	if (z_is_thread_queued(thread)) {
60009846:	2a00      	cmp	r2, #0
60009848:	da06      	bge.n	60009858 <move_thread_to_end_of_prio_q+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
6000984a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	_priq_run_remove(thread_runq(thread), thread);
6000984e:	4601      	mov	r1, r0
	thread->base.thread_state &= ~_THREAD_QUEUED;
60009850:	7343      	strb	r3, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
60009852:	481d      	ldr	r0, [pc, #116]	; (600098c8 <move_thread_to_end_of_prio_q+0x8c>)
60009854:	f7ff ffd2 	bl	600097fc <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
60009858:	7b63      	ldrb	r3, [r4, #13]
6000985a:	f063 037f 	orn	r3, r3, #127	; 0x7f
6000985e:	7363      	strb	r3, [r4, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
60009860:	4b1a      	ldr	r3, [pc, #104]	; (600098cc <move_thread_to_end_of_prio_q+0x90>)
60009862:	429c      	cmp	r4, r3
60009864:	d109      	bne.n	6000987a <move_thread_to_end_of_prio_q+0x3e>
60009866:	491a      	ldr	r1, [pc, #104]	; (600098d0 <move_thread_to_end_of_prio_q+0x94>)
60009868:	23bb      	movs	r3, #187	; 0xbb
6000986a:	481a      	ldr	r0, [pc, #104]	; (600098d4 <move_thread_to_end_of_prio_q+0x98>)
6000986c:	4a1a      	ldr	r2, [pc, #104]	; (600098d8 <move_thread_to_end_of_prio_q+0x9c>)
6000986e:	f001 f927 	bl	6000aac0 <assert_print>
60009872:	21bb      	movs	r1, #187	; 0xbb
60009874:	4818      	ldr	r0, [pc, #96]	; (600098d8 <move_thread_to_end_of_prio_q+0x9c>)
60009876:	f001 f91c 	bl	6000aab2 <assert_post_action>
	return list->head == list;
6000987a:	4a18      	ldr	r2, [pc, #96]	; (600098dc <move_thread_to_end_of_prio_q+0xa0>)
6000987c:	4611      	mov	r1, r2
	return (node == list->tail) ? NULL : node->next;
6000987e:	6a10      	ldr	r0, [r2, #32]
	return list->head == list;
60009880:	f851 3f1c 	ldr.w	r3, [r1, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
60009884:	428b      	cmp	r3, r1
60009886:	bf08      	it	eq
60009888:	2300      	moveq	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
6000988a:	b923      	cbnz	r3, 60009896 <move_thread_to_end_of_prio_q+0x5a>
	node->prev = tail;
6000988c:	e9c4 1000 	strd	r1, r0, [r4]
	tail->next = node;
60009890:	6004      	str	r4, [r0, #0]
	list->tail = node;
60009892:	6214      	str	r4, [r2, #32]
}
60009894:	e00c      	b.n	600098b0 <move_thread_to_end_of_prio_q+0x74>
	int32_t b1 = thread_1->base.prio;
60009896:	f994 500e 	ldrsb.w	r5, [r4, #14]
	int32_t b2 = thread_2->base.prio;
6000989a:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
6000989e:	42b5      	cmp	r5, r6
600098a0:	d00e      	beq.n	600098c0 <move_thread_to_end_of_prio_q+0x84>
		if (z_sched_prio_cmp(thread, t) > 0) {
600098a2:	42ae      	cmp	r6, r5
600098a4:	dd0c      	ble.n	600098c0 <move_thread_to_end_of_prio_q+0x84>
	sys_dnode_t *const prev = successor->prev;
600098a6:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
600098a8:	e9c4 3100 	strd	r3, r1, [r4]
	prev->next = node;
600098ac:	600c      	str	r4, [r1, #0]
	successor->prev = node;
600098ae:	605c      	str	r4, [r3, #4]
	update_cache(thread == _current);
600098b0:	6890      	ldr	r0, [r2, #8]
600098b2:	1b03      	subs	r3, r0, r4
600098b4:	4258      	negs	r0, r3
}
600098b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
600098ba:	4158      	adcs	r0, r3
600098bc:	f7ff bd0a 	b.w	600092d4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
600098c0:	4298      	cmp	r0, r3
600098c2:	d0e3      	beq.n	6000988c <move_thread_to_end_of_prio_q+0x50>
600098c4:	681b      	ldr	r3, [r3, #0]
600098c6:	e7e0      	b.n	6000988a <move_thread_to_end_of_prio_q+0x4e>
600098c8:	800016e4 	.word	0x800016e4
600098cc:	800009f0 	.word	0x800009f0
600098d0:	6000e2ec 	.word	0x6000e2ec
600098d4:	6000c68a 	.word	0x6000c68a
600098d8:	6000e2a3 	.word	0x6000e2a3
600098dc:	800016c8 	.word	0x800016c8

600098e0 <z_time_slice>:
{
600098e0:	b570      	push	{r4, r5, r6, lr}
600098e2:	4605      	mov	r5, r0
	__asm__ volatile(
600098e4:	f04f 0310 	mov.w	r3, #16
600098e8:	f3ef 8611 	mrs	r6, BASEPRI
600098ec:	f383 8812 	msr	BASEPRI_MAX, r3
600098f0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
600098f4:	4829      	ldr	r0, [pc, #164]	; (6000999c <z_time_slice+0xbc>)
600098f6:	f7ff fbd7 	bl	600090a8 <z_spin_lock_valid>
600098fa:	b968      	cbnz	r0, 60009918 <z_time_slice+0x38>
600098fc:	2394      	movs	r3, #148	; 0x94
600098fe:	4a28      	ldr	r2, [pc, #160]	; (600099a0 <z_time_slice+0xc0>)
60009900:	4928      	ldr	r1, [pc, #160]	; (600099a4 <z_time_slice+0xc4>)
60009902:	4829      	ldr	r0, [pc, #164]	; (600099a8 <z_time_slice+0xc8>)
60009904:	f001 f8dc 	bl	6000aac0 <assert_print>
60009908:	4924      	ldr	r1, [pc, #144]	; (6000999c <z_time_slice+0xbc>)
6000990a:	4828      	ldr	r0, [pc, #160]	; (600099ac <z_time_slice+0xcc>)
6000990c:	f001 f8d8 	bl	6000aac0 <assert_print>
60009910:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009912:	4823      	ldr	r0, [pc, #140]	; (600099a0 <z_time_slice+0xc0>)
60009914:	f001 f8cd 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
60009918:	4820      	ldr	r0, [pc, #128]	; (6000999c <z_time_slice+0xbc>)
6000991a:	f7ff fbe1 	bl	600090e0 <z_spin_lock_set_owner>
	if (pending_current == _current) {
6000991e:	4b24      	ldr	r3, [pc, #144]	; (600099b0 <z_time_slice+0xd0>)
60009920:	4a24      	ldr	r2, [pc, #144]	; (600099b4 <z_time_slice+0xd4>)
60009922:	689c      	ldr	r4, [r3, #8]
60009924:	6811      	ldr	r1, [r2, #0]
60009926:	428c      	cmp	r4, r1
60009928:	d112      	bne.n	60009950 <z_time_slice+0x70>
		z_reset_time_slice(_current);
6000992a:	4620      	mov	r0, r4
6000992c:	f7ff fcbe 	bl	600092ac <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009930:	481a      	ldr	r0, [pc, #104]	; (6000999c <z_time_slice+0xbc>)
60009932:	f7ff fbc7 	bl	600090c4 <z_spin_unlock_valid>
60009936:	bb58      	cbnz	r0, 60009990 <z_time_slice+0xb0>
60009938:	23c2      	movs	r3, #194	; 0xc2
6000993a:	4a19      	ldr	r2, [pc, #100]	; (600099a0 <z_time_slice+0xc0>)
6000993c:	491e      	ldr	r1, [pc, #120]	; (600099b8 <z_time_slice+0xd8>)
6000993e:	481a      	ldr	r0, [pc, #104]	; (600099a8 <z_time_slice+0xc8>)
60009940:	f001 f8be 	bl	6000aac0 <assert_print>
60009944:	4915      	ldr	r1, [pc, #84]	; (6000999c <z_time_slice+0xbc>)
60009946:	481d      	ldr	r0, [pc, #116]	; (600099bc <z_time_slice+0xdc>)
60009948:	f001 f8ba 	bl	6000aac0 <assert_print>
6000994c:	21c2      	movs	r1, #194	; 0xc2
6000994e:	e7e0      	b.n	60009912 <z_time_slice+0x32>
	pending_current = NULL;
60009950:	2100      	movs	r1, #0
60009952:	6011      	str	r1, [r2, #0]
	int ret = slice_ticks;
60009954:	4a1a      	ldr	r2, [pc, #104]	; (600099c0 <z_time_slice+0xe0>)
	if (slice_time(_current) && sliceable(_current)) {
60009956:	6812      	ldr	r2, [r2, #0]
60009958:	b1c2      	cbz	r2, 6000998c <z_time_slice+0xac>
		&& !z_is_idle_thread_object(thread);
6000995a:	89e2      	ldrh	r2, [r4, #14]
6000995c:	2a7f      	cmp	r2, #127	; 0x7f
6000995e:	d815      	bhi.n	6000998c <z_time_slice+0xac>
		&& !z_is_thread_prevented_from_running(thread)
60009960:	7b62      	ldrb	r2, [r4, #13]
60009962:	06d2      	lsls	r2, r2, #27
60009964:	d112      	bne.n	6000998c <z_time_slice+0xac>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
60009966:	4a17      	ldr	r2, [pc, #92]	; (600099c4 <z_time_slice+0xe4>)
60009968:	f994 100e 	ldrsb.w	r1, [r4, #14]
6000996c:	6812      	ldr	r2, [r2, #0]
6000996e:	4291      	cmp	r1, r2
60009970:	db0c      	blt.n	6000998c <z_time_slice+0xac>
		&& !z_is_idle_thread_object(thread);
60009972:	4a15      	ldr	r2, [pc, #84]	; (600099c8 <z_time_slice+0xe8>)
60009974:	4294      	cmp	r4, r2
60009976:	d009      	beq.n	6000998c <z_time_slice+0xac>
		if (ticks >= _current_cpu->slice_ticks) {
60009978:	691a      	ldr	r2, [r3, #16]
6000997a:	42aa      	cmp	r2, r5
6000997c:	dc03      	bgt.n	60009986 <z_time_slice+0xa6>
		move_thread_to_end_of_prio_q(curr);
6000997e:	4620      	mov	r0, r4
60009980:	f7ff ff5c 	bl	6000983c <move_thread_to_end_of_prio_q>
	z_reset_time_slice(curr);
60009984:	e7d1      	b.n	6000992a <z_time_slice+0x4a>
			_current_cpu->slice_ticks -= ticks;
60009986:	1b52      	subs	r2, r2, r5
		_current_cpu->slice_ticks = 0;
60009988:	611a      	str	r2, [r3, #16]
6000998a:	e7d1      	b.n	60009930 <z_time_slice+0x50>
6000998c:	2200      	movs	r2, #0
6000998e:	e7fb      	b.n	60009988 <z_time_slice+0xa8>
	__asm__ volatile(
60009990:	f386 8811 	msr	BASEPRI, r6
60009994:	f3bf 8f6f 	isb	sy
}
60009998:	bd70      	pop	{r4, r5, r6, pc}
6000999a:	bf00      	nop
6000999c:	800016fc 	.word	0x800016fc
600099a0:	6000d5ed 	.word	0x6000d5ed
600099a4:	6000d61a 	.word	0x6000d61a
600099a8:	6000c68a 	.word	0x6000c68a
600099ac:	6000d62f 	.word	0x6000d62f
600099b0:	800016c8 	.word	0x800016c8
600099b4:	800016f0 	.word	0x800016f0
600099b8:	6000d647 	.word	0x6000d647
600099bc:	6000d65e 	.word	0x6000d65e
600099c0:	800016f8 	.word	0x800016f8
600099c4:	800016f4 	.word	0x800016f4
600099c8:	800009f0 	.word	0x800009f0

600099cc <unready_thread>:
{
600099cc:	b510      	push	{r4, lr}
	if (z_is_thread_queued(thread)) {
600099ce:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
600099d2:	4604      	mov	r4, r0
600099d4:	7b43      	ldrb	r3, [r0, #13]
	if (z_is_thread_queued(thread)) {
600099d6:	2a00      	cmp	r2, #0
600099d8:	da06      	bge.n	600099e8 <unready_thread+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
600099da:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	_priq_run_remove(thread_runq(thread), thread);
600099de:	4601      	mov	r1, r0
	thread->base.thread_state &= ~_THREAD_QUEUED;
600099e0:	7343      	strb	r3, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
600099e2:	4806      	ldr	r0, [pc, #24]	; (600099fc <unready_thread+0x30>)
600099e4:	f7ff ff0a 	bl	600097fc <z_priq_dumb_remove>
	update_cache(thread == _current);
600099e8:	4b05      	ldr	r3, [pc, #20]	; (60009a00 <unready_thread+0x34>)
600099ea:	6898      	ldr	r0, [r3, #8]
600099ec:	1b03      	subs	r3, r0, r4
600099ee:	4258      	negs	r0, r3
}
600099f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	update_cache(thread == _current);
600099f4:	4158      	adcs	r0, r3
600099f6:	f7ff bc6d 	b.w	600092d4 <update_cache>
600099fa:	bf00      	nop
600099fc:	800016e4 	.word	0x800016e4
60009a00:	800016c8 	.word	0x800016c8

60009a04 <add_to_waitq_locked>:
{
60009a04:	b538      	push	{r3, r4, r5, lr}
60009a06:	4604      	mov	r4, r0
60009a08:	460d      	mov	r5, r1
	unready_thread(thread);
60009a0a:	f7ff ffdf 	bl	600099cc <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
60009a0e:	7b63      	ldrb	r3, [r4, #13]
60009a10:	f043 0302 	orr.w	r3, r3, #2
60009a14:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
60009a16:	b34d      	cbz	r5, 60009a6c <add_to_waitq_locked+0x68>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
60009a18:	4b15      	ldr	r3, [pc, #84]	; (60009a70 <add_to_waitq_locked+0x6c>)
		thread->base.pended_on = wait_q;
60009a1a:	60a5      	str	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
60009a1c:	429c      	cmp	r4, r3
60009a1e:	d109      	bne.n	60009a34 <add_to_waitq_locked+0x30>
60009a20:	4914      	ldr	r1, [pc, #80]	; (60009a74 <add_to_waitq_locked+0x70>)
60009a22:	23bb      	movs	r3, #187	; 0xbb
60009a24:	4814      	ldr	r0, [pc, #80]	; (60009a78 <add_to_waitq_locked+0x74>)
60009a26:	4a15      	ldr	r2, [pc, #84]	; (60009a7c <add_to_waitq_locked+0x78>)
60009a28:	f001 f84a 	bl	6000aac0 <assert_print>
60009a2c:	21bb      	movs	r1, #187	; 0xbb
60009a2e:	4813      	ldr	r0, [pc, #76]	; (60009a7c <add_to_waitq_locked+0x78>)
60009a30:	f001 f83f 	bl	6000aab2 <assert_post_action>
	return list->head == list;
60009a34:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
60009a36:	429d      	cmp	r5, r3
60009a38:	d109      	bne.n	60009a4e <add_to_waitq_locked+0x4a>
	sys_dnode_t *const tail = list->tail;
60009a3a:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
60009a3c:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
60009a40:	601c      	str	r4, [r3, #0]
	list->tail = node;
60009a42:	606c      	str	r4, [r5, #4]
}
60009a44:	e012      	b.n	60009a6c <add_to_waitq_locked+0x68>
	return (node == list->tail) ? NULL : node->next;
60009a46:	686a      	ldr	r2, [r5, #4]
60009a48:	4293      	cmp	r3, r2
60009a4a:	d0f6      	beq.n	60009a3a <add_to_waitq_locked+0x36>
60009a4c:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
60009a4e:	2b00      	cmp	r3, #0
60009a50:	d0f3      	beq.n	60009a3a <add_to_waitq_locked+0x36>
	int32_t b1 = thread_1->base.prio;
60009a52:	f994 200e 	ldrsb.w	r2, [r4, #14]
	int32_t b2 = thread_2->base.prio;
60009a56:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
60009a5a:	428a      	cmp	r2, r1
60009a5c:	d0f3      	beq.n	60009a46 <add_to_waitq_locked+0x42>
		if (z_sched_prio_cmp(thread, t) > 0) {
60009a5e:	4291      	cmp	r1, r2
60009a60:	ddf1      	ble.n	60009a46 <add_to_waitq_locked+0x42>
	sys_dnode_t *const prev = successor->prev;
60009a62:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
60009a64:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
60009a68:	6014      	str	r4, [r2, #0]
	successor->prev = node;
60009a6a:	605c      	str	r4, [r3, #4]
}
60009a6c:	bd38      	pop	{r3, r4, r5, pc}
60009a6e:	bf00      	nop
60009a70:	800009f0 	.word	0x800009f0
60009a74:	6000e2ec 	.word	0x6000e2ec
60009a78:	6000c68a 	.word	0x6000c68a
60009a7c:	6000e2a3 	.word	0x6000e2a3

60009a80 <pend_locked>:
{
60009a80:	b570      	push	{r4, r5, r6, lr}
60009a82:	4615      	mov	r5, r2
60009a84:	461c      	mov	r4, r3
60009a86:	4606      	mov	r6, r0
	add_to_waitq_locked(thread, wait_q);
60009a88:	f7ff ffbc 	bl	60009a04 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
60009a8c:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
60009a90:	bf08      	it	eq
60009a92:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
60009a96:	d008      	beq.n	60009aaa <pend_locked+0x2a>
60009a98:	462a      	mov	r2, r5
60009a9a:	4623      	mov	r3, r4
60009a9c:	f106 0018 	add.w	r0, r6, #24
60009aa0:	4902      	ldr	r1, [pc, #8]	; (60009aac <pend_locked+0x2c>)
}
60009aa2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
60009aa6:	f000 bd11 	b.w	6000a4cc <z_add_timeout>
60009aaa:	bd70      	pop	{r4, r5, r6, pc}
60009aac:	60009cad 	.word	0x60009cad

60009ab0 <z_pend_curr>:
{
60009ab0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	pending_current = _current;
60009ab4:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 60009b70 <z_pend_curr+0xc0>
{
60009ab8:	4617      	mov	r7, r2
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
60009aba:	4c2e      	ldr	r4, [pc, #184]	; (60009b74 <z_pend_curr+0xc4>)
{
60009abc:	4605      	mov	r5, r0
	pending_current = _current;
60009abe:	f8da 2008 	ldr.w	r2, [sl, #8]
{
60009ac2:	460e      	mov	r6, r1
	pending_current = _current;
60009ac4:	4b2c      	ldr	r3, [pc, #176]	; (60009b78 <z_pend_curr+0xc8>)
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
60009ac6:	42a0      	cmp	r0, r4
{
60009ac8:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
	pending_current = _current;
60009acc:	601a      	str	r2, [r3, #0]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
60009ace:	d10b      	bne.n	60009ae8 <z_pend_curr+0x38>
60009ad0:	492a      	ldr	r1, [pc, #168]	; (60009b7c <z_pend_curr+0xcc>)
60009ad2:	f240 3352 	movw	r3, #850	; 0x352
60009ad6:	482a      	ldr	r0, [pc, #168]	; (60009b80 <z_pend_curr+0xd0>)
60009ad8:	4a2a      	ldr	r2, [pc, #168]	; (60009b84 <z_pend_curr+0xd4>)
60009ada:	f000 fff1 	bl	6000aac0 <assert_print>
60009ade:	f240 3152 	movw	r1, #850	; 0x352
60009ae2:	4828      	ldr	r0, [pc, #160]	; (60009b84 <z_pend_curr+0xd4>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
60009ae4:	f000 ffe5 	bl	6000aab2 <assert_post_action>
	__asm__ volatile(
60009ae8:	f04f 0210 	mov.w	r2, #16
60009aec:	f3ef 8311 	mrs	r3, BASEPRI
60009af0:	f382 8812 	msr	BASEPRI_MAX, r2
60009af4:	f3bf 8f6f 	isb	sy
60009af8:	4620      	mov	r0, r4
60009afa:	f7ff fad5 	bl	600090a8 <z_spin_lock_valid>
60009afe:	b960      	cbnz	r0, 60009b1a <z_pend_curr+0x6a>
60009b00:	2394      	movs	r3, #148	; 0x94
60009b02:	4a21      	ldr	r2, [pc, #132]	; (60009b88 <z_pend_curr+0xd8>)
60009b04:	4921      	ldr	r1, [pc, #132]	; (60009b8c <z_pend_curr+0xdc>)
60009b06:	481e      	ldr	r0, [pc, #120]	; (60009b80 <z_pend_curr+0xd0>)
60009b08:	f000 ffda 	bl	6000aac0 <assert_print>
60009b0c:	4621      	mov	r1, r4
60009b0e:	4820      	ldr	r0, [pc, #128]	; (60009b90 <z_pend_curr+0xe0>)
60009b10:	f000 ffd6 	bl	6000aac0 <assert_print>
60009b14:	2194      	movs	r1, #148	; 0x94
60009b16:	481c      	ldr	r0, [pc, #112]	; (60009b88 <z_pend_curr+0xd8>)
60009b18:	e7e4      	b.n	60009ae4 <z_pend_curr+0x34>
	z_spin_lock_set_owner(l);
60009b1a:	4620      	mov	r0, r4
60009b1c:	f7ff fae0 	bl	600090e0 <z_spin_lock_set_owner>
	pend_locked(_current, wait_q, timeout);
60009b20:	f8da 0008 	ldr.w	r0, [sl, #8]
60009b24:	4642      	mov	r2, r8
60009b26:	464b      	mov	r3, r9
60009b28:	4639      	mov	r1, r7
60009b2a:	f7ff ffa9 	bl	60009a80 <pend_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009b2e:	4628      	mov	r0, r5
60009b30:	f7ff fac8 	bl	600090c4 <z_spin_unlock_valid>
60009b34:	b958      	cbnz	r0, 60009b4e <z_pend_curr+0x9e>
60009b36:	4917      	ldr	r1, [pc, #92]	; (60009b94 <z_pend_curr+0xe4>)
60009b38:	23e1      	movs	r3, #225	; 0xe1
60009b3a:	4a13      	ldr	r2, [pc, #76]	; (60009b88 <z_pend_curr+0xd8>)
60009b3c:	4810      	ldr	r0, [pc, #64]	; (60009b80 <z_pend_curr+0xd0>)
60009b3e:	f000 ffbf 	bl	6000aac0 <assert_print>
60009b42:	4629      	mov	r1, r5
60009b44:	4814      	ldr	r0, [pc, #80]	; (60009b98 <z_pend_curr+0xe8>)
60009b46:	f000 ffbb 	bl	6000aac0 <assert_print>
60009b4a:	21e1      	movs	r1, #225	; 0xe1
60009b4c:	e7e3      	b.n	60009b16 <z_pend_curr+0x66>
60009b4e:	4620      	mov	r0, r4
60009b50:	f7ff fab8 	bl	600090c4 <z_spin_unlock_valid>
60009b54:	b938      	cbnz	r0, 60009b66 <z_pend_curr+0xb6>
60009b56:	490f      	ldr	r1, [pc, #60]	; (60009b94 <z_pend_curr+0xe4>)
60009b58:	23e1      	movs	r3, #225	; 0xe1
60009b5a:	4a0b      	ldr	r2, [pc, #44]	; (60009b88 <z_pend_curr+0xd8>)
60009b5c:	4808      	ldr	r0, [pc, #32]	; (60009b80 <z_pend_curr+0xd0>)
60009b5e:	f000 ffaf 	bl	6000aac0 <assert_print>
60009b62:	4621      	mov	r1, r4
60009b64:	e7ee      	b.n	60009b44 <z_pend_curr+0x94>
60009b66:	4630      	mov	r0, r6
}
60009b68:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
60009b6c:	f7fa be9a 	b.w	600048a4 <arch_swap>
60009b70:	800016c8 	.word	0x800016c8
60009b74:	800016fc 	.word	0x800016fc
60009b78:	800016f0 	.word	0x800016f0
60009b7c:	6000e39a 	.word	0x6000e39a
60009b80:	6000c68a 	.word	0x6000c68a
60009b84:	6000e2a3 	.word	0x6000e2a3
60009b88:	6000d5ed 	.word	0x6000d5ed
60009b8c:	6000d61a 	.word	0x6000d61a
60009b90:	6000d62f 	.word	0x6000d62f
60009b94:	6000d647 	.word	0x6000d647
60009b98:	6000d65e 	.word	0x6000d65e

60009b9c <z_impl_k_thread_suspend>:
{
60009b9c:	b570      	push	{r4, r5, r6, lr}
60009b9e:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
60009ba0:	3018      	adds	r0, #24
60009ba2:	f000 fd59 	bl	6000a658 <z_abort_timeout>
60009ba6:	f04f 0310 	mov.w	r3, #16
60009baa:	f3ef 8611 	mrs	r6, BASEPRI
60009bae:	f383 8812 	msr	BASEPRI_MAX, r3
60009bb2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
60009bb6:	4824      	ldr	r0, [pc, #144]	; (60009c48 <z_impl_k_thread_suspend+0xac>)
60009bb8:	f7ff fa76 	bl	600090a8 <z_spin_lock_valid>
60009bbc:	b968      	cbnz	r0, 60009bda <z_impl_k_thread_suspend+0x3e>
60009bbe:	2394      	movs	r3, #148	; 0x94
60009bc0:	4a22      	ldr	r2, [pc, #136]	; (60009c4c <z_impl_k_thread_suspend+0xb0>)
60009bc2:	4923      	ldr	r1, [pc, #140]	; (60009c50 <z_impl_k_thread_suspend+0xb4>)
60009bc4:	4823      	ldr	r0, [pc, #140]	; (60009c54 <z_impl_k_thread_suspend+0xb8>)
60009bc6:	f000 ff7b 	bl	6000aac0 <assert_print>
60009bca:	491f      	ldr	r1, [pc, #124]	; (60009c48 <z_impl_k_thread_suspend+0xac>)
60009bcc:	4822      	ldr	r0, [pc, #136]	; (60009c58 <z_impl_k_thread_suspend+0xbc>)
60009bce:	f000 ff77 	bl	6000aac0 <assert_print>
60009bd2:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009bd4:	481d      	ldr	r0, [pc, #116]	; (60009c4c <z_impl_k_thread_suspend+0xb0>)
60009bd6:	f000 ff6c 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
60009bda:	481b      	ldr	r0, [pc, #108]	; (60009c48 <z_impl_k_thread_suspend+0xac>)
60009bdc:	f7ff fa80 	bl	600090e0 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
60009be0:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
60009be4:	7b63      	ldrb	r3, [r4, #13]
60009be6:	2a00      	cmp	r2, #0
60009be8:	da06      	bge.n	60009bf8 <z_impl_k_thread_suspend+0x5c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
60009bea:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	_priq_run_remove(thread_runq(thread), thread);
60009bee:	4621      	mov	r1, r4
60009bf0:	481a      	ldr	r0, [pc, #104]	; (60009c5c <z_impl_k_thread_suspend+0xc0>)
	thread->base.thread_state &= ~_THREAD_QUEUED;
60009bf2:	7363      	strb	r3, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
60009bf4:	f7ff fe02 	bl	600097fc <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
60009bf8:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
60009bfa:	4d19      	ldr	r5, [pc, #100]	; (60009c60 <z_impl_k_thread_suspend+0xc4>)
60009bfc:	f043 0310 	orr.w	r3, r3, #16
60009c00:	68a8      	ldr	r0, [r5, #8]
60009c02:	7363      	strb	r3, [r4, #13]
60009c04:	1b03      	subs	r3, r0, r4
60009c06:	4258      	negs	r0, r3
60009c08:	4158      	adcs	r0, r3
60009c0a:	f7ff fb63 	bl	600092d4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009c0e:	480e      	ldr	r0, [pc, #56]	; (60009c48 <z_impl_k_thread_suspend+0xac>)
60009c10:	f7ff fa58 	bl	600090c4 <z_spin_unlock_valid>
60009c14:	b958      	cbnz	r0, 60009c2e <z_impl_k_thread_suspend+0x92>
60009c16:	23c2      	movs	r3, #194	; 0xc2
60009c18:	4a0c      	ldr	r2, [pc, #48]	; (60009c4c <z_impl_k_thread_suspend+0xb0>)
60009c1a:	4912      	ldr	r1, [pc, #72]	; (60009c64 <z_impl_k_thread_suspend+0xc8>)
60009c1c:	480d      	ldr	r0, [pc, #52]	; (60009c54 <z_impl_k_thread_suspend+0xb8>)
60009c1e:	f000 ff4f 	bl	6000aac0 <assert_print>
60009c22:	4909      	ldr	r1, [pc, #36]	; (60009c48 <z_impl_k_thread_suspend+0xac>)
60009c24:	4810      	ldr	r0, [pc, #64]	; (60009c68 <z_impl_k_thread_suspend+0xcc>)
60009c26:	f000 ff4b 	bl	6000aac0 <assert_print>
60009c2a:	21c2      	movs	r1, #194	; 0xc2
60009c2c:	e7d2      	b.n	60009bd4 <z_impl_k_thread_suspend+0x38>
	__asm__ volatile(
60009c2e:	f386 8811 	msr	BASEPRI, r6
60009c32:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
60009c36:	68ab      	ldr	r3, [r5, #8]
60009c38:	42a3      	cmp	r3, r4
60009c3a:	d103      	bne.n	60009c44 <z_impl_k_thread_suspend+0xa8>
}
60009c3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
60009c40:	f001 bc48 	b.w	6000b4d4 <z_reschedule_unlocked>
}
60009c44:	bd70      	pop	{r4, r5, r6, pc}
60009c46:	bf00      	nop
60009c48:	800016fc 	.word	0x800016fc
60009c4c:	6000d5ed 	.word	0x6000d5ed
60009c50:	6000d61a 	.word	0x6000d61a
60009c54:	6000c68a 	.word	0x6000c68a
60009c58:	6000d62f 	.word	0x6000d62f
60009c5c:	800016e4 	.word	0x800016e4
60009c60:	800016c8 	.word	0x800016c8
60009c64:	6000d647 	.word	0x6000d647
60009c68:	6000d65e 	.word	0x6000d65e

60009c6c <unpend_thread_no_timeout>:
{
60009c6c:	b510      	push	{r4, lr}
60009c6e:	4604      	mov	r4, r0
60009c70:	6880      	ldr	r0, [r0, #8]
	__ASSERT_NO_MSG(thread->base.pended_on);
60009c72:	b958      	cbnz	r0, 60009c8c <unpend_thread_no_timeout+0x20>
60009c74:	490a      	ldr	r1, [pc, #40]	; (60009ca0 <unpend_thread_no_timeout+0x34>)
60009c76:	f44f 7336 	mov.w	r3, #728	; 0x2d8
60009c7a:	480a      	ldr	r0, [pc, #40]	; (60009ca4 <unpend_thread_no_timeout+0x38>)
60009c7c:	4a0a      	ldr	r2, [pc, #40]	; (60009ca8 <unpend_thread_no_timeout+0x3c>)
60009c7e:	f000 ff1f 	bl	6000aac0 <assert_print>
60009c82:	f44f 7136 	mov.w	r1, #728	; 0x2d8
60009c86:	4808      	ldr	r0, [pc, #32]	; (60009ca8 <unpend_thread_no_timeout+0x3c>)
60009c88:	f000 ff13 	bl	6000aab2 <assert_post_action>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
60009c8c:	4621      	mov	r1, r4
60009c8e:	f7ff fdb5 	bl	600097fc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
60009c92:	7b63      	ldrb	r3, [r4, #13]
60009c94:	f023 0302 	bic.w	r3, r3, #2
60009c98:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
60009c9a:	2300      	movs	r3, #0
60009c9c:	60a3      	str	r3, [r4, #8]
}
60009c9e:	bd10      	pop	{r4, pc}
60009ca0:	6000e3d1 	.word	0x6000e3d1
60009ca4:	6000c68a 	.word	0x6000c68a
60009ca8:	6000e2a3 	.word	0x6000e2a3

60009cac <z_thread_timeout>:
{
60009cac:	b570      	push	{r4, r5, r6, lr}
60009cae:	4604      	mov	r4, r0
	__asm__ volatile(
60009cb0:	f04f 0310 	mov.w	r3, #16
60009cb4:	f3ef 8611 	mrs	r6, BASEPRI
60009cb8:	f383 8812 	msr	BASEPRI_MAX, r3
60009cbc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
60009cc0:	481f      	ldr	r0, [pc, #124]	; (60009d40 <z_thread_timeout+0x94>)
60009cc2:	f7ff f9f1 	bl	600090a8 <z_spin_lock_valid>
60009cc6:	b968      	cbnz	r0, 60009ce4 <z_thread_timeout+0x38>
60009cc8:	2394      	movs	r3, #148	; 0x94
60009cca:	4a1e      	ldr	r2, [pc, #120]	; (60009d44 <z_thread_timeout+0x98>)
60009ccc:	491e      	ldr	r1, [pc, #120]	; (60009d48 <z_thread_timeout+0x9c>)
60009cce:	481f      	ldr	r0, [pc, #124]	; (60009d4c <z_thread_timeout+0xa0>)
60009cd0:	f000 fef6 	bl	6000aac0 <assert_print>
60009cd4:	491a      	ldr	r1, [pc, #104]	; (60009d40 <z_thread_timeout+0x94>)
60009cd6:	481e      	ldr	r0, [pc, #120]	; (60009d50 <z_thread_timeout+0xa4>)
60009cd8:	f000 fef2 	bl	6000aac0 <assert_print>
60009cdc:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009cde:	4819      	ldr	r0, [pc, #100]	; (60009d44 <z_thread_timeout+0x98>)
60009ce0:	f000 fee7 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
60009ce4:	4816      	ldr	r0, [pc, #88]	; (60009d40 <z_thread_timeout+0x94>)
60009ce6:	f7ff f9fb 	bl	600090e0 <z_spin_lock_set_owner>
		if (!killed) {
60009cea:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
60009cee:	f013 0f28 	tst.w	r3, #40	; 0x28
60009cf2:	d110      	bne.n	60009d16 <z_thread_timeout+0x6a>
			if (thread->base.pended_on != NULL) {
60009cf4:	f854 3c10 	ldr.w	r3, [r4, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
60009cf8:	f1a4 0518 	sub.w	r5, r4, #24
			if (thread->base.pended_on != NULL) {
60009cfc:	b113      	cbz	r3, 60009d04 <z_thread_timeout+0x58>
				unpend_thread_no_timeout(thread);
60009cfe:	4628      	mov	r0, r5
60009d00:	f7ff ffb4 	bl	60009c6c <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
60009d04:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
			ready_thread(thread);
60009d08:	4628      	mov	r0, r5
60009d0a:	f023 0314 	bic.w	r3, r3, #20
60009d0e:	f804 3c0b 	strb.w	r3, [r4, #-11]
60009d12:	f7ff fb13 	bl	6000933c <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009d16:	480a      	ldr	r0, [pc, #40]	; (60009d40 <z_thread_timeout+0x94>)
60009d18:	f7ff f9d4 	bl	600090c4 <z_spin_unlock_valid>
60009d1c:	b958      	cbnz	r0, 60009d36 <z_thread_timeout+0x8a>
60009d1e:	23c2      	movs	r3, #194	; 0xc2
60009d20:	4a08      	ldr	r2, [pc, #32]	; (60009d44 <z_thread_timeout+0x98>)
60009d22:	490c      	ldr	r1, [pc, #48]	; (60009d54 <z_thread_timeout+0xa8>)
60009d24:	4809      	ldr	r0, [pc, #36]	; (60009d4c <z_thread_timeout+0xa0>)
60009d26:	f000 fecb 	bl	6000aac0 <assert_print>
60009d2a:	4905      	ldr	r1, [pc, #20]	; (60009d40 <z_thread_timeout+0x94>)
60009d2c:	480a      	ldr	r0, [pc, #40]	; (60009d58 <z_thread_timeout+0xac>)
60009d2e:	f000 fec7 	bl	6000aac0 <assert_print>
60009d32:	21c2      	movs	r1, #194	; 0xc2
60009d34:	e7d3      	b.n	60009cde <z_thread_timeout+0x32>
	__asm__ volatile(
60009d36:	f386 8811 	msr	BASEPRI, r6
60009d3a:	f3bf 8f6f 	isb	sy
}
60009d3e:	bd70      	pop	{r4, r5, r6, pc}
60009d40:	800016fc 	.word	0x800016fc
60009d44:	6000d5ed 	.word	0x6000d5ed
60009d48:	6000d61a 	.word	0x6000d61a
60009d4c:	6000c68a 	.word	0x6000c68a
60009d50:	6000d62f 	.word	0x6000d62f
60009d54:	6000d647 	.word	0x6000d647
60009d58:	6000d65e 	.word	0x6000d65e

60009d5c <z_unpend_first_thread>:
{
60009d5c:	b570      	push	{r4, r5, r6, lr}
60009d5e:	4605      	mov	r5, r0
	__asm__ volatile(
60009d60:	f04f 0310 	mov.w	r3, #16
60009d64:	f3ef 8611 	mrs	r6, BASEPRI
60009d68:	f383 8812 	msr	BASEPRI_MAX, r3
60009d6c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
60009d70:	481b      	ldr	r0, [pc, #108]	; (60009de0 <z_unpend_first_thread+0x84>)
60009d72:	f7ff f999 	bl	600090a8 <z_spin_lock_valid>
60009d76:	b968      	cbnz	r0, 60009d94 <z_unpend_first_thread+0x38>
60009d78:	2394      	movs	r3, #148	; 0x94
60009d7a:	4a1a      	ldr	r2, [pc, #104]	; (60009de4 <z_unpend_first_thread+0x88>)
60009d7c:	491a      	ldr	r1, [pc, #104]	; (60009de8 <z_unpend_first_thread+0x8c>)
60009d7e:	481b      	ldr	r0, [pc, #108]	; (60009dec <z_unpend_first_thread+0x90>)
60009d80:	f000 fe9e 	bl	6000aac0 <assert_print>
60009d84:	4916      	ldr	r1, [pc, #88]	; (60009de0 <z_unpend_first_thread+0x84>)
60009d86:	481a      	ldr	r0, [pc, #104]	; (60009df0 <z_unpend_first_thread+0x94>)
60009d88:	f000 fe9a 	bl	6000aac0 <assert_print>
60009d8c:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009d8e:	4815      	ldr	r0, [pc, #84]	; (60009de4 <z_unpend_first_thread+0x88>)
60009d90:	f000 fe8f 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
60009d94:	4812      	ldr	r0, [pc, #72]	; (60009de0 <z_unpend_first_thread+0x84>)
60009d96:	f7ff f9a3 	bl	600090e0 <z_spin_lock_set_owner>
	return list->head == list;
60009d9a:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
60009d9c:	42a5      	cmp	r5, r4
60009d9e:	d017      	beq.n	60009dd0 <z_unpend_first_thread+0x74>
		if (thread != NULL) {
60009da0:	b134      	cbz	r4, 60009db0 <z_unpend_first_thread+0x54>
			unpend_thread_no_timeout(thread);
60009da2:	4620      	mov	r0, r4
60009da4:	f7ff ff62 	bl	60009c6c <unpend_thread_no_timeout>
60009da8:	f104 0018 	add.w	r0, r4, #24
60009dac:	f000 fc54 	bl	6000a658 <z_abort_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009db0:	480b      	ldr	r0, [pc, #44]	; (60009de0 <z_unpend_first_thread+0x84>)
60009db2:	f7ff f987 	bl	600090c4 <z_spin_unlock_valid>
60009db6:	b968      	cbnz	r0, 60009dd4 <z_unpend_first_thread+0x78>
60009db8:	23c2      	movs	r3, #194	; 0xc2
60009dba:	4a0a      	ldr	r2, [pc, #40]	; (60009de4 <z_unpend_first_thread+0x88>)
60009dbc:	490d      	ldr	r1, [pc, #52]	; (60009df4 <z_unpend_first_thread+0x98>)
60009dbe:	480b      	ldr	r0, [pc, #44]	; (60009dec <z_unpend_first_thread+0x90>)
60009dc0:	f000 fe7e 	bl	6000aac0 <assert_print>
60009dc4:	4906      	ldr	r1, [pc, #24]	; (60009de0 <z_unpend_first_thread+0x84>)
60009dc6:	480c      	ldr	r0, [pc, #48]	; (60009df8 <z_unpend_first_thread+0x9c>)
60009dc8:	f000 fe7a 	bl	6000aac0 <assert_print>
60009dcc:	21c2      	movs	r1, #194	; 0xc2
60009dce:	e7de      	b.n	60009d8e <z_unpend_first_thread+0x32>
60009dd0:	2400      	movs	r4, #0
60009dd2:	e7ed      	b.n	60009db0 <z_unpend_first_thread+0x54>
	__asm__ volatile(
60009dd4:	f386 8811 	msr	BASEPRI, r6
60009dd8:	f3bf 8f6f 	isb	sy
}
60009ddc:	4620      	mov	r0, r4
60009dde:	bd70      	pop	{r4, r5, r6, pc}
60009de0:	800016fc 	.word	0x800016fc
60009de4:	6000d5ed 	.word	0x6000d5ed
60009de8:	6000d61a 	.word	0x6000d61a
60009dec:	6000c68a 	.word	0x6000c68a
60009df0:	6000d62f 	.word	0x6000d62f
60009df4:	6000d647 	.word	0x6000d647
60009df8:	6000d65e 	.word	0x6000d65e

60009dfc <z_sched_init>:
	list->head = (sys_dnode_t *)list;
60009dfc:	4b04      	ldr	r3, [pc, #16]	; (60009e10 <z_sched_init+0x14>)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
60009dfe:	2100      	movs	r1, #0
60009e00:	f103 021c 	add.w	r2, r3, #28
60009e04:	4608      	mov	r0, r1
	list->tail = (sys_dnode_t *)list;
60009e06:	e9c3 2207 	strd	r2, r2, [r3, #28]
60009e0a:	f7ff bae1 	b.w	600093d0 <k_sched_time_slice_set>
60009e0e:	bf00      	nop
60009e10:	800016c8 	.word	0x800016c8

60009e14 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
60009e14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60009e16:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
60009e1a:	b16b      	cbz	r3, 60009e38 <z_impl_k_yield+0x24>
60009e1c:	493c      	ldr	r1, [pc, #240]	; (60009f10 <z_impl_k_yield+0xfc>)
60009e1e:	f240 5374 	movw	r3, #1396	; 0x574
60009e22:	4a3c      	ldr	r2, [pc, #240]	; (60009f14 <z_impl_k_yield+0x100>)
60009e24:	483c      	ldr	r0, [pc, #240]	; (60009f18 <z_impl_k_yield+0x104>)
60009e26:	f000 fe4b 	bl	6000aac0 <assert_print>
60009e2a:	483c      	ldr	r0, [pc, #240]	; (60009f1c <z_impl_k_yield+0x108>)
60009e2c:	f000 fe48 	bl	6000aac0 <assert_print>
60009e30:	f240 5174 	movw	r1, #1396	; 0x574
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
60009e34:	4837      	ldr	r0, [pc, #220]	; (60009f14 <z_impl_k_yield+0x100>)
60009e36:	e017      	b.n	60009e68 <z_impl_k_yield+0x54>
	__asm__ volatile(
60009e38:	f04f 0310 	mov.w	r3, #16
60009e3c:	f3ef 8611 	mrs	r6, BASEPRI
60009e40:	f383 8812 	msr	BASEPRI_MAX, r3
60009e44:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
60009e48:	4835      	ldr	r0, [pc, #212]	; (60009f20 <z_impl_k_yield+0x10c>)
60009e4a:	f7ff f92d 	bl	600090a8 <z_spin_lock_valid>
60009e4e:	b968      	cbnz	r0, 60009e6c <z_impl_k_yield+0x58>
60009e50:	2394      	movs	r3, #148	; 0x94
60009e52:	4a34      	ldr	r2, [pc, #208]	; (60009f24 <z_impl_k_yield+0x110>)
60009e54:	4934      	ldr	r1, [pc, #208]	; (60009f28 <z_impl_k_yield+0x114>)
60009e56:	4830      	ldr	r0, [pc, #192]	; (60009f18 <z_impl_k_yield+0x104>)
60009e58:	f000 fe32 	bl	6000aac0 <assert_print>
60009e5c:	4930      	ldr	r1, [pc, #192]	; (60009f20 <z_impl_k_yield+0x10c>)
60009e5e:	4833      	ldr	r0, [pc, #204]	; (60009f2c <z_impl_k_yield+0x118>)
60009e60:	f000 fe2e 	bl	6000aac0 <assert_print>
60009e64:	2194      	movs	r1, #148	; 0x94
60009e66:	482f      	ldr	r0, [pc, #188]	; (60009f24 <z_impl_k_yield+0x110>)
60009e68:	f000 fe23 	bl	6000aab2 <assert_post_action>

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
60009e6c:	4c30      	ldr	r4, [pc, #192]	; (60009f30 <z_impl_k_yield+0x11c>)
	z_spin_lock_set_owner(l);
60009e6e:	482c      	ldr	r0, [pc, #176]	; (60009f20 <z_impl_k_yield+0x10c>)
60009e70:	f7ff f936 	bl	600090e0 <z_spin_lock_set_owner>
60009e74:	68a1      	ldr	r1, [r4, #8]
	_priq_run_remove(thread_runq(thread), thread);
60009e76:	f104 051c 	add.w	r5, r4, #28
	thread->base.thread_state &= ~_THREAD_QUEUED;
60009e7a:	7b4b      	ldrb	r3, [r1, #13]
	_priq_run_remove(thread_runq(thread), thread);
60009e7c:	4628      	mov	r0, r5
	thread->base.thread_state &= ~_THREAD_QUEUED;
60009e7e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
60009e82:	734b      	strb	r3, [r1, #13]
	_priq_run_remove(thread_runq(thread), thread);
60009e84:	f7ff fcba 	bl	600097fc <z_priq_dumb_remove>
	}
	queue_thread(_current);
60009e88:	68a3      	ldr	r3, [r4, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
60009e8a:	7b5a      	ldrb	r2, [r3, #13]
60009e8c:	f062 027f 	orn	r2, r2, #127	; 0x7f
60009e90:	735a      	strb	r2, [r3, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
60009e92:	4a28      	ldr	r2, [pc, #160]	; (60009f34 <z_impl_k_yield+0x120>)
60009e94:	4293      	cmp	r3, r2
60009e96:	d107      	bne.n	60009ea8 <z_impl_k_yield+0x94>
60009e98:	4927      	ldr	r1, [pc, #156]	; (60009f38 <z_impl_k_yield+0x124>)
60009e9a:	23bb      	movs	r3, #187	; 0xbb
60009e9c:	4a1d      	ldr	r2, [pc, #116]	; (60009f14 <z_impl_k_yield+0x100>)
60009e9e:	481e      	ldr	r0, [pc, #120]	; (60009f18 <z_impl_k_yield+0x104>)
60009ea0:	f000 fe0e 	bl	6000aac0 <assert_print>
60009ea4:	21bb      	movs	r1, #187	; 0xbb
60009ea6:	e7c5      	b.n	60009e34 <z_impl_k_yield+0x20>
	return list->head == list;
60009ea8:	69e2      	ldr	r2, [r4, #28]
	return (node == list->tail) ? NULL : node->next;
60009eaa:	6a21      	ldr	r1, [r4, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
60009eac:	42aa      	cmp	r2, r5
60009eae:	bf08      	it	eq
60009eb0:	2200      	moveq	r2, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
60009eb2:	b922      	cbnz	r2, 60009ebe <z_impl_k_yield+0xaa>
	node->prev = tail;
60009eb4:	e9c3 5100 	strd	r5, r1, [r3]
	tail->next = node;
60009eb8:	600b      	str	r3, [r1, #0]
	list->tail = node;
60009eba:	6223      	str	r3, [r4, #32]
}
60009ebc:	e00c      	b.n	60009ed8 <z_impl_k_yield+0xc4>
	int32_t b1 = thread_1->base.prio;
60009ebe:	f993 000e 	ldrsb.w	r0, [r3, #14]
	int32_t b2 = thread_2->base.prio;
60009ec2:	f992 700e 	ldrsb.w	r7, [r2, #14]
	if (b1 != b2) {
60009ec6:	42b8      	cmp	r0, r7
60009ec8:	d019      	beq.n	60009efe <z_impl_k_yield+0xea>
		if (z_sched_prio_cmp(thread, t) > 0) {
60009eca:	4287      	cmp	r7, r0
60009ecc:	dd17      	ble.n	60009efe <z_impl_k_yield+0xea>
	sys_dnode_t *const prev = successor->prev;
60009ece:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
60009ed0:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
60009ed4:	600b      	str	r3, [r1, #0]
	successor->prev = node;
60009ed6:	6053      	str	r3, [r2, #4]
	update_cache(1);
60009ed8:	2001      	movs	r0, #1
60009eda:	f7ff f9fb 	bl	600092d4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009ede:	4810      	ldr	r0, [pc, #64]	; (60009f20 <z_impl_k_yield+0x10c>)
60009ee0:	f7ff f8f0 	bl	600090c4 <z_spin_unlock_valid>
60009ee4:	b978      	cbnz	r0, 60009f06 <z_impl_k_yield+0xf2>
60009ee6:	23e1      	movs	r3, #225	; 0xe1
60009ee8:	4a0e      	ldr	r2, [pc, #56]	; (60009f24 <z_impl_k_yield+0x110>)
60009eea:	4914      	ldr	r1, [pc, #80]	; (60009f3c <z_impl_k_yield+0x128>)
60009eec:	480a      	ldr	r0, [pc, #40]	; (60009f18 <z_impl_k_yield+0x104>)
60009eee:	f000 fde7 	bl	6000aac0 <assert_print>
60009ef2:	490b      	ldr	r1, [pc, #44]	; (60009f20 <z_impl_k_yield+0x10c>)
60009ef4:	4812      	ldr	r0, [pc, #72]	; (60009f40 <z_impl_k_yield+0x12c>)
60009ef6:	f000 fde3 	bl	6000aac0 <assert_print>
60009efa:	21e1      	movs	r1, #225	; 0xe1
60009efc:	e7b3      	b.n	60009e66 <z_impl_k_yield+0x52>
	return (node == list->tail) ? NULL : node->next;
60009efe:	428a      	cmp	r2, r1
60009f00:	d0d8      	beq.n	60009eb4 <z_impl_k_yield+0xa0>
60009f02:	6812      	ldr	r2, [r2, #0]
60009f04:	e7d5      	b.n	60009eb2 <z_impl_k_yield+0x9e>
60009f06:	4630      	mov	r0, r6
	z_swap(&sched_spinlock, key);
}
60009f08:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
60009f0c:	f7fa bcca 	b.w	600048a4 <arch_swap>
60009f10:	6000e166 	.word	0x6000e166
60009f14:	6000e2a3 	.word	0x6000e2a3
60009f18:	6000c68a 	.word	0x6000c68a
60009f1c:	6000e2a0 	.word	0x6000e2a0
60009f20:	800016fc 	.word	0x800016fc
60009f24:	6000d5ed 	.word	0x6000d5ed
60009f28:	6000d61a 	.word	0x6000d61a
60009f2c:	6000d62f 	.word	0x6000d62f
60009f30:	800016c8 	.word	0x800016c8
60009f34:	800009f0 	.word	0x800009f0
60009f38:	6000e2ec 	.word	0x6000e2ec
60009f3c:	6000d647 	.word	0x6000d647
60009f40:	6000d65e 	.word	0x6000d65e

60009f44 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
60009f44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60009f48:	4605      	mov	r5, r0
60009f4a:	460e      	mov	r6, r1
60009f4c:	f3ef 8305 	mrs	r3, IPSR
#ifdef CONFIG_MULTITHREADING
	uint32_t expected_wakeup_ticks;

	__ASSERT(!arch_is_in_isr(), "");
60009f50:	b16b      	cbz	r3, 60009f6e <z_tick_sleep+0x2a>
60009f52:	493f      	ldr	r1, [pc, #252]	; (6000a050 <z_tick_sleep+0x10c>)
60009f54:	f44f 63b2 	mov.w	r3, #1424	; 0x590
60009f58:	4a3e      	ldr	r2, [pc, #248]	; (6000a054 <z_tick_sleep+0x110>)
60009f5a:	483f      	ldr	r0, [pc, #252]	; (6000a058 <z_tick_sleep+0x114>)
60009f5c:	f000 fdb0 	bl	6000aac0 <assert_print>
60009f60:	483e      	ldr	r0, [pc, #248]	; (6000a05c <z_tick_sleep+0x118>)
60009f62:	f000 fdad 	bl	6000aac0 <assert_print>
60009f66:	f44f 61b2 	mov.w	r1, #1424	; 0x590
	z_add_thread_timeout(_current, timeout);
	z_mark_thread_as_suspended(_current);

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
60009f6a:	483a      	ldr	r0, [pc, #232]	; (6000a054 <z_tick_sleep+0x110>)
60009f6c:	e025      	b.n	60009fba <z_tick_sleep+0x76>
	if (ticks == 0) {
60009f6e:	ea50 0301 	orrs.w	r3, r0, r1
60009f72:	d103      	bne.n	60009f7c <z_tick_sleep+0x38>
	z_impl_k_yield();
60009f74:	f7ff ff4e 	bl	60009e14 <z_impl_k_yield>
		return 0;
60009f78:	2000      	movs	r0, #0
60009f7a:	e066      	b.n	6000a04a <z_tick_sleep+0x106>
	if (Z_TICK_ABS(ticks) <= 0) {
60009f7c:	1c82      	adds	r2, r0, #2
60009f7e:	f171 33ff 	sbcs.w	r3, r1, #4294967295	; 0xffffffff
60009f82:	db1c      	blt.n	60009fbe <z_tick_sleep+0x7a>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
60009f84:	f001 fab0 	bl	6000b4e8 <sys_clock_tick_get_32>
60009f88:	182c      	adds	r4, r5, r0
60009f8a:	f04f 0310 	mov.w	r3, #16
60009f8e:	f3ef 8811 	mrs	r8, BASEPRI
60009f92:	f383 8812 	msr	BASEPRI_MAX, r3
60009f96:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
60009f9a:	4831      	ldr	r0, [pc, #196]	; (6000a060 <z_tick_sleep+0x11c>)
60009f9c:	f7ff f884 	bl	600090a8 <z_spin_lock_valid>
60009fa0:	b988      	cbnz	r0, 60009fc6 <z_tick_sleep+0x82>
60009fa2:	2394      	movs	r3, #148	; 0x94
60009fa4:	4a2f      	ldr	r2, [pc, #188]	; (6000a064 <z_tick_sleep+0x120>)
60009fa6:	4930      	ldr	r1, [pc, #192]	; (6000a068 <z_tick_sleep+0x124>)
60009fa8:	482b      	ldr	r0, [pc, #172]	; (6000a058 <z_tick_sleep+0x114>)
60009faa:	f000 fd89 	bl	6000aac0 <assert_print>
60009fae:	492c      	ldr	r1, [pc, #176]	; (6000a060 <z_tick_sleep+0x11c>)
60009fb0:	482e      	ldr	r0, [pc, #184]	; (6000a06c <z_tick_sleep+0x128>)
60009fb2:	f000 fd85 	bl	6000aac0 <assert_print>
60009fb6:	2194      	movs	r1, #148	; 0x94
60009fb8:	482a      	ldr	r0, [pc, #168]	; (6000a064 <z_tick_sleep+0x120>)
60009fba:	f000 fd7a 	bl	6000aab2 <assert_post_action>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
60009fbe:	f06f 0401 	mvn.w	r4, #1
60009fc2:	1a24      	subs	r4, r4, r0
60009fc4:	e7e1      	b.n	60009f8a <z_tick_sleep+0x46>
	pending_current = _current;
60009fc6:	4f2a      	ldr	r7, [pc, #168]	; (6000a070 <z_tick_sleep+0x12c>)
	z_spin_lock_set_owner(l);
60009fc8:	4825      	ldr	r0, [pc, #148]	; (6000a060 <z_tick_sleep+0x11c>)
60009fca:	f7ff f889 	bl	600090e0 <z_spin_lock_set_owner>
60009fce:	68b8      	ldr	r0, [r7, #8]
60009fd0:	4b28      	ldr	r3, [pc, #160]	; (6000a074 <z_tick_sleep+0x130>)
60009fd2:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
60009fd4:	f7ff fcfa 	bl	600099cc <unready_thread>
	z_add_thread_timeout(_current, timeout);
60009fd8:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
60009fda:	462a      	mov	r2, r5
60009fdc:	4633      	mov	r3, r6
60009fde:	4926      	ldr	r1, [pc, #152]	; (6000a078 <z_tick_sleep+0x134>)
60009fe0:	3018      	adds	r0, #24
60009fe2:	f000 fa73 	bl	6000a4cc <z_add_timeout>
	z_mark_thread_as_suspended(_current);
60009fe6:	68ba      	ldr	r2, [r7, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
60009fe8:	481d      	ldr	r0, [pc, #116]	; (6000a060 <z_tick_sleep+0x11c>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
60009fea:	7b53      	ldrb	r3, [r2, #13]
60009fec:	f043 0310 	orr.w	r3, r3, #16
60009ff0:	7353      	strb	r3, [r2, #13]
60009ff2:	f7ff f867 	bl	600090c4 <z_spin_unlock_valid>
60009ff6:	b958      	cbnz	r0, 6000a010 <z_tick_sleep+0xcc>
60009ff8:	23e1      	movs	r3, #225	; 0xe1
60009ffa:	4a1a      	ldr	r2, [pc, #104]	; (6000a064 <z_tick_sleep+0x120>)
60009ffc:	491f      	ldr	r1, [pc, #124]	; (6000a07c <z_tick_sleep+0x138>)
60009ffe:	4816      	ldr	r0, [pc, #88]	; (6000a058 <z_tick_sleep+0x114>)
6000a000:	f000 fd5e 	bl	6000aac0 <assert_print>
6000a004:	4916      	ldr	r1, [pc, #88]	; (6000a060 <z_tick_sleep+0x11c>)
6000a006:	481e      	ldr	r0, [pc, #120]	; (6000a080 <z_tick_sleep+0x13c>)
6000a008:	f000 fd5a 	bl	6000aac0 <assert_print>
6000a00c:	21e1      	movs	r1, #225	; 0xe1
6000a00e:	e7d3      	b.n	60009fb8 <z_tick_sleep+0x74>
6000a010:	4640      	mov	r0, r8
6000a012:	f7fa fc47 	bl	600048a4 <arch_swap>
	return (thread->base.thread_state & state) != 0U;
6000a016:	68bb      	ldr	r3, [r7, #8]
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
6000a018:	7b5b      	ldrb	r3, [r3, #13]
6000a01a:	06db      	lsls	r3, r3, #27
6000a01c:	d50c      	bpl.n	6000a038 <z_tick_sleep+0xf4>
6000a01e:	4919      	ldr	r1, [pc, #100]	; (6000a084 <z_tick_sleep+0x140>)
6000a020:	f240 53ac 	movw	r3, #1452	; 0x5ac
6000a024:	4a0b      	ldr	r2, [pc, #44]	; (6000a054 <z_tick_sleep+0x110>)
6000a026:	480c      	ldr	r0, [pc, #48]	; (6000a058 <z_tick_sleep+0x114>)
6000a028:	f000 fd4a 	bl	6000aac0 <assert_print>
6000a02c:	480b      	ldr	r0, [pc, #44]	; (6000a05c <z_tick_sleep+0x118>)
6000a02e:	f000 fd47 	bl	6000aac0 <assert_print>
6000a032:	f240 51ac 	movw	r1, #1452	; 0x5ac
6000a036:	e798      	b.n	60009f6a <z_tick_sleep+0x26>

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
6000a038:	f001 fa56 	bl	6000b4e8 <sys_clock_tick_get_32>
6000a03c:	1a20      	subs	r0, r4, r0
6000a03e:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
6000a042:	2801      	cmp	r0, #1
6000a044:	f173 0300 	sbcs.w	r3, r3, #0
6000a048:	db96      	blt.n	60009f78 <z_tick_sleep+0x34>
		return ticks;
	}
#endif

	return 0;
}
6000a04a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
6000a04e:	bf00      	nop
6000a050:	6000e166 	.word	0x6000e166
6000a054:	6000e2a3 	.word	0x6000e2a3
6000a058:	6000c68a 	.word	0x6000c68a
6000a05c:	6000e2a0 	.word	0x6000e2a0
6000a060:	800016fc 	.word	0x800016fc
6000a064:	6000d5ed 	.word	0x6000d5ed
6000a068:	6000d61a 	.word	0x6000d61a
6000a06c:	6000d62f 	.word	0x6000d62f
6000a070:	800016c8 	.word	0x800016c8
6000a074:	800016f0 	.word	0x800016f0
6000a078:	60009cad 	.word	0x60009cad
6000a07c:	6000d647 	.word	0x6000d647
6000a080:	6000d65e 	.word	0x6000d65e
6000a084:	6000e3e8 	.word	0x6000e3e8

6000a088 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
6000a088:	b508      	push	{r3, lr}
6000a08a:	f3ef 8305 	mrs	r3, IPSR
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
6000a08e:	b173      	cbz	r3, 6000a0ae <z_impl_k_sleep+0x26>
6000a090:	4911      	ldr	r1, [pc, #68]	; (6000a0d8 <z_impl_k_sleep+0x50>)
6000a092:	f240 53bb 	movw	r3, #1467	; 0x5bb
6000a096:	4a11      	ldr	r2, [pc, #68]	; (6000a0dc <z_impl_k_sleep+0x54>)
6000a098:	4811      	ldr	r0, [pc, #68]	; (6000a0e0 <z_impl_k_sleep+0x58>)
6000a09a:	f000 fd11 	bl	6000aac0 <assert_print>
6000a09e:	4811      	ldr	r0, [pc, #68]	; (6000a0e4 <z_impl_k_sleep+0x5c>)
6000a0a0:	f000 fd0e 	bl	6000aac0 <assert_print>
6000a0a4:	f240 51bb 	movw	r1, #1467	; 0x5bb
6000a0a8:	480c      	ldr	r0, [pc, #48]	; (6000a0dc <z_impl_k_sleep+0x54>)
6000a0aa:	f000 fd02 	bl	6000aab2 <assert_post_action>

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
6000a0ae:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
6000a0b2:	bf08      	it	eq
6000a0b4:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
6000a0b8:	d106      	bne.n	6000a0c8 <z_impl_k_sleep+0x40>
		k_thread_suspend(_current);
6000a0ba:	4b0b      	ldr	r3, [pc, #44]	; (6000a0e8 <z_impl_k_sleep+0x60>)
6000a0bc:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
6000a0be:	f7ff fd6d 	bl	60009b9c <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
6000a0c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
6000a0c6:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
6000a0c8:	f7ff ff3c 	bl	60009f44 <z_tick_sleep>
			return t / ((uint64_t)from_hz / to_hz);
6000a0cc:	220a      	movs	r2, #10
6000a0ce:	2300      	movs	r3, #0
6000a0d0:	17c1      	asrs	r1, r0, #31
6000a0d2:	f7f9 fcd1 	bl	60003a78 <__aeabi_uldivmod>
	return ret;
6000a0d6:	e7f6      	b.n	6000a0c6 <z_impl_k_sleep+0x3e>
6000a0d8:	6000e166 	.word	0x6000e166
6000a0dc:	6000e2a3 	.word	0x6000e2a3
6000a0e0:	6000c68a 	.word	0x6000c68a
6000a0e4:	6000e2a0 	.word	0x6000e2a0
6000a0e8:	800016c8 	.word	0x800016c8

6000a0ec <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
6000a0ec:	4b01      	ldr	r3, [pc, #4]	; (6000a0f4 <z_impl_z_current_get+0x8>)
6000a0ee:	6898      	ldr	r0, [r3, #8]
6000a0f0:	4770      	bx	lr
6000a0f2:	bf00      	nop
6000a0f4:	800016c8 	.word	0x800016c8

6000a0f8 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
6000a0f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
6000a0fc:	4604      	mov	r4, r0
6000a0fe:	f04f 0310 	mov.w	r3, #16
6000a102:	f3ef 8611 	mrs	r6, BASEPRI
6000a106:	f383 8812 	msr	BASEPRI_MAX, r3
6000a10a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000a10e:	4851      	ldr	r0, [pc, #324]	; (6000a254 <z_thread_abort+0x15c>)
6000a110:	f7fe ffca 	bl	600090a8 <z_spin_lock_valid>
6000a114:	b968      	cbnz	r0, 6000a132 <z_thread_abort+0x3a>
6000a116:	2394      	movs	r3, #148	; 0x94
6000a118:	4a4f      	ldr	r2, [pc, #316]	; (6000a258 <z_thread_abort+0x160>)
6000a11a:	4950      	ldr	r1, [pc, #320]	; (6000a25c <z_thread_abort+0x164>)
6000a11c:	4850      	ldr	r0, [pc, #320]	; (6000a260 <z_thread_abort+0x168>)
6000a11e:	f000 fccf 	bl	6000aac0 <assert_print>
6000a122:	494c      	ldr	r1, [pc, #304]	; (6000a254 <z_thread_abort+0x15c>)
6000a124:	484f      	ldr	r0, [pc, #316]	; (6000a264 <z_thread_abort+0x16c>)
6000a126:	f000 fccb 	bl	6000aac0 <assert_print>
6000a12a:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a12c:	484a      	ldr	r0, [pc, #296]	; (6000a258 <z_thread_abort+0x160>)
6000a12e:	f000 fcc0 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
6000a132:	4848      	ldr	r0, [pc, #288]	; (6000a254 <z_thread_abort+0x15c>)
6000a134:	f7fe ffd4 	bl	600090e0 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
6000a138:	7b23      	ldrb	r3, [r4, #12]
6000a13a:	07d9      	lsls	r1, r3, #31
6000a13c:	d522      	bpl.n	6000a184 <z_thread_abort+0x8c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a13e:	4845      	ldr	r0, [pc, #276]	; (6000a254 <z_thread_abort+0x15c>)
6000a140:	f7fe ffc0 	bl	600090c4 <z_spin_unlock_valid>
6000a144:	b958      	cbnz	r0, 6000a15e <z_thread_abort+0x66>
6000a146:	23c2      	movs	r3, #194	; 0xc2
6000a148:	4a43      	ldr	r2, [pc, #268]	; (6000a258 <z_thread_abort+0x160>)
6000a14a:	4947      	ldr	r1, [pc, #284]	; (6000a268 <z_thread_abort+0x170>)
6000a14c:	4844      	ldr	r0, [pc, #272]	; (6000a260 <z_thread_abort+0x168>)
6000a14e:	f000 fcb7 	bl	6000aac0 <assert_print>
6000a152:	4940      	ldr	r1, [pc, #256]	; (6000a254 <z_thread_abort+0x15c>)
6000a154:	4845      	ldr	r0, [pc, #276]	; (6000a26c <z_thread_abort+0x174>)
6000a156:	f000 fcb3 	bl	6000aac0 <assert_print>
6000a15a:	21c2      	movs	r1, #194	; 0xc2
6000a15c:	e7e6      	b.n	6000a12c <z_thread_abort+0x34>
	__asm__ volatile(
6000a15e:	f386 8811 	msr	BASEPRI, r6
6000a162:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
6000a166:	f240 63c7 	movw	r3, #1735	; 0x6c7
6000a16a:	4a41      	ldr	r2, [pc, #260]	; (6000a270 <z_thread_abort+0x178>)
6000a16c:	4941      	ldr	r1, [pc, #260]	; (6000a274 <z_thread_abort+0x17c>)
6000a16e:	483c      	ldr	r0, [pc, #240]	; (6000a260 <z_thread_abort+0x168>)
6000a170:	f000 fca6 	bl	6000aac0 <assert_print>
6000a174:	4621      	mov	r1, r4
6000a176:	4840      	ldr	r0, [pc, #256]	; (6000a278 <z_thread_abort+0x180>)
6000a178:	f000 fca2 	bl	6000aac0 <assert_print>
6000a17c:	f240 61c7 	movw	r1, #1735	; 0x6c7
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
6000a180:	483b      	ldr	r0, [pc, #236]	; (6000a270 <z_thread_abort+0x178>)
6000a182:	e7d4      	b.n	6000a12e <z_thread_abort+0x36>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
6000a184:	7b63      	ldrb	r3, [r4, #13]
6000a186:	071a      	lsls	r2, r3, #28
6000a188:	d50a      	bpl.n	6000a1a0 <z_thread_abort+0xa8>
6000a18a:	4832      	ldr	r0, [pc, #200]	; (6000a254 <z_thread_abort+0x15c>)
6000a18c:	f7fe ff9a 	bl	600090c4 <z_spin_unlock_valid>
6000a190:	2800      	cmp	r0, #0
6000a192:	d0d8      	beq.n	6000a146 <z_thread_abort+0x4e>
6000a194:	f386 8811 	msr	BASEPRI, r6
6000a198:	f3bf 8f6f 	isb	sy
	}
	k_spin_unlock(&sched_spinlock, key);
}
6000a19c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
6000a1a0:	f023 0220 	bic.w	r2, r3, #32
6000a1a4:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
6000a1a8:	09d2      	lsrs	r2, r2, #7
6000a1aa:	d12c      	bne.n	6000a206 <z_thread_abort+0x10e>
		thread->base.thread_state &= ~_THREAD_ABORTING;
6000a1ac:	7361      	strb	r1, [r4, #13]
		if (thread->base.pended_on != NULL) {
6000a1ae:	68a3      	ldr	r3, [r4, #8]
6000a1b0:	b113      	cbz	r3, 6000a1b8 <z_thread_abort+0xc0>
			unpend_thread_no_timeout(thread);
6000a1b2:	4620      	mov	r0, r4
6000a1b4:	f7ff fd5a 	bl	60009c6c <unpend_thread_no_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
6000a1b8:	f104 0758 	add.w	r7, r4, #88	; 0x58
6000a1bc:	f04f 0800 	mov.w	r8, #0
	return z_abort_timeout(&thread->base.timeout);
6000a1c0:	f104 0018 	add.w	r0, r4, #24
6000a1c4:	f000 fa48 	bl	6000a658 <z_abort_timeout>
	return list->head == list;
6000a1c8:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
6000a1ca:	42bd      	cmp	r5, r7
6000a1cc:	d000      	beq.n	6000a1d0 <z_thread_abort+0xd8>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
6000a1ce:	bb25      	cbnz	r5, 6000a21a <z_thread_abort+0x122>
		update_cache(1);
6000a1d0:	2001      	movs	r0, #1
6000a1d2:	f7ff f87f 	bl	600092d4 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
6000a1d6:	4b29      	ldr	r3, [pc, #164]	; (6000a27c <z_thread_abort+0x184>)
6000a1d8:	689b      	ldr	r3, [r3, #8]
6000a1da:	42a3      	cmp	r3, r4
6000a1dc:	d1d5      	bne.n	6000a18a <z_thread_abort+0x92>
6000a1de:	f3ef 8305 	mrs	r3, IPSR
6000a1e2:	2b00      	cmp	r3, #0
6000a1e4:	d1d1      	bne.n	6000a18a <z_thread_abort+0x92>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a1e6:	481b      	ldr	r0, [pc, #108]	; (6000a254 <z_thread_abort+0x15c>)
6000a1e8:	f7fe ff6c 	bl	600090c4 <z_spin_unlock_valid>
6000a1ec:	bb10      	cbnz	r0, 6000a234 <z_thread_abort+0x13c>
6000a1ee:	23e1      	movs	r3, #225	; 0xe1
6000a1f0:	4a19      	ldr	r2, [pc, #100]	; (6000a258 <z_thread_abort+0x160>)
6000a1f2:	491d      	ldr	r1, [pc, #116]	; (6000a268 <z_thread_abort+0x170>)
6000a1f4:	481a      	ldr	r0, [pc, #104]	; (6000a260 <z_thread_abort+0x168>)
6000a1f6:	f000 fc63 	bl	6000aac0 <assert_print>
6000a1fa:	4916      	ldr	r1, [pc, #88]	; (6000a254 <z_thread_abort+0x15c>)
6000a1fc:	481b      	ldr	r0, [pc, #108]	; (6000a26c <z_thread_abort+0x174>)
6000a1fe:	f000 fc5f 	bl	6000aac0 <assert_print>
6000a202:	21e1      	movs	r1, #225	; 0xe1
6000a204:	e792      	b.n	6000a12c <z_thread_abort+0x34>
	thread->base.thread_state &= ~_THREAD_QUEUED;
6000a206:	f003 035f 	and.w	r3, r3, #95	; 0x5f
	_priq_run_remove(thread_runq(thread), thread);
6000a20a:	4621      	mov	r1, r4
6000a20c:	481c      	ldr	r0, [pc, #112]	; (6000a280 <z_thread_abort+0x188>)
	thread->base.thread_state &= ~_THREAD_QUEUED;
6000a20e:	f043 0308 	orr.w	r3, r3, #8
6000a212:	7363      	strb	r3, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
6000a214:	f7ff faf2 	bl	600097fc <z_priq_dumb_remove>
}
6000a218:	e7c9      	b.n	6000a1ae <z_thread_abort+0xb6>
		unpend_thread_no_timeout(thread);
6000a21a:	4628      	mov	r0, r5
6000a21c:	f7ff fd26 	bl	60009c6c <unpend_thread_no_timeout>
6000a220:	f105 0018 	add.w	r0, r5, #24
6000a224:	f000 fa18 	bl	6000a658 <z_abort_timeout>
		ready_thread(thread);
6000a228:	4628      	mov	r0, r5
6000a22a:	f8c5 8098 	str.w	r8, [r5, #152]	; 0x98
6000a22e:	f7ff f885 	bl	6000933c <ready_thread>
6000a232:	e7c9      	b.n	6000a1c8 <z_thread_abort+0xd0>
6000a234:	4630      	mov	r0, r6
6000a236:	f7fa fb35 	bl	600048a4 <arch_swap>
		__ASSERT(false, "aborted _current back from dead");
6000a23a:	490e      	ldr	r1, [pc, #56]	; (6000a274 <z_thread_abort+0x17c>)
6000a23c:	f240 63f6 	movw	r3, #1782	; 0x6f6
6000a240:	4a0b      	ldr	r2, [pc, #44]	; (6000a270 <z_thread_abort+0x178>)
6000a242:	4807      	ldr	r0, [pc, #28]	; (6000a260 <z_thread_abort+0x168>)
6000a244:	f000 fc3c 	bl	6000aac0 <assert_print>
6000a248:	480e      	ldr	r0, [pc, #56]	; (6000a284 <z_thread_abort+0x18c>)
6000a24a:	f000 fc39 	bl	6000aac0 <assert_print>
6000a24e:	f240 61f6 	movw	r1, #1782	; 0x6f6
6000a252:	e795      	b.n	6000a180 <z_thread_abort+0x88>
6000a254:	800016fc 	.word	0x800016fc
6000a258:	6000d5ed 	.word	0x6000d5ed
6000a25c:	6000d61a 	.word	0x6000d61a
6000a260:	6000c68a 	.word	0x6000c68a
6000a264:	6000d62f 	.word	0x6000d62f
6000a268:	6000d647 	.word	0x6000d647
6000a26c:	6000d65e 	.word	0x6000d65e
6000a270:	6000e2a3 	.word	0x6000e2a3
6000a274:	6000d5b3 	.word	0x6000d5b3
6000a278:	6000e428 	.word	0x6000e428
6000a27c:	800016c8 	.word	0x800016c8
6000a280:	800016e4 	.word	0x800016e4
6000a284:	6000e447 	.word	0x6000e447

6000a288 <z_impl_k_thread_join>:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
6000a288:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
6000a28c:	4604      	mov	r4, r0
6000a28e:	4616      	mov	r6, r2
6000a290:	461d      	mov	r5, r3
	__asm__ volatile(
6000a292:	f04f 0310 	mov.w	r3, #16
6000a296:	f3ef 8711 	mrs	r7, BASEPRI
6000a29a:	f383 8812 	msr	BASEPRI_MAX, r3
6000a29e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000a2a2:	483e      	ldr	r0, [pc, #248]	; (6000a39c <z_impl_k_thread_join+0x114>)
6000a2a4:	f7fe ff00 	bl	600090a8 <z_spin_lock_valid>
6000a2a8:	b960      	cbnz	r0, 6000a2c4 <z_impl_k_thread_join+0x3c>
6000a2aa:	2394      	movs	r3, #148	; 0x94
6000a2ac:	4a3c      	ldr	r2, [pc, #240]	; (6000a3a0 <z_impl_k_thread_join+0x118>)
6000a2ae:	493d      	ldr	r1, [pc, #244]	; (6000a3a4 <z_impl_k_thread_join+0x11c>)
6000a2b0:	483d      	ldr	r0, [pc, #244]	; (6000a3a8 <z_impl_k_thread_join+0x120>)
6000a2b2:	f000 fc05 	bl	6000aac0 <assert_print>
6000a2b6:	4939      	ldr	r1, [pc, #228]	; (6000a39c <z_impl_k_thread_join+0x114>)
6000a2b8:	483c      	ldr	r0, [pc, #240]	; (6000a3ac <z_impl_k_thread_join+0x124>)
6000a2ba:	f000 fc01 	bl	6000aac0 <assert_print>
6000a2be:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a2c0:	4837      	ldr	r0, [pc, #220]	; (6000a3a0 <z_impl_k_thread_join+0x118>)
6000a2c2:	e023      	b.n	6000a30c <z_impl_k_thread_join+0x84>
	z_spin_lock_set_owner(l);
6000a2c4:	4835      	ldr	r0, [pc, #212]	; (6000a39c <z_impl_k_thread_join+0x114>)
6000a2c6:	f7fe ff0b 	bl	600090e0 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);
	int ret = 0;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, join, thread, timeout);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
6000a2ca:	7b63      	ldrb	r3, [r4, #13]
6000a2cc:	071b      	lsls	r3, r3, #28
6000a2ce:	d446      	bmi.n	6000a35e <z_impl_k_thread_join+0xd6>
		ret = 0;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
6000a2d0:	ea55 0306 	orrs.w	r3, r5, r6
6000a2d4:	d054      	beq.n	6000a380 <z_impl_k_thread_join+0xf8>
		ret = -EBUSY;
	} else if ((thread == _current) ||
6000a2d6:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 6000a3b0 <z_impl_k_thread_join+0x128>
6000a2da:	f8d8 0008 	ldr.w	r0, [r8, #8]
6000a2de:	42a0      	cmp	r0, r4
6000a2e0:	d051      	beq.n	6000a386 <z_impl_k_thread_join+0xfe>
		   (thread->base.pended_on == &_current->join_queue)) {
6000a2e2:	f100 0358 	add.w	r3, r0, #88	; 0x58
	} else if ((thread == _current) ||
6000a2e6:	68a2      	ldr	r2, [r4, #8]
6000a2e8:	429a      	cmp	r2, r3
6000a2ea:	d04c      	beq.n	6000a386 <z_impl_k_thread_join+0xfe>
6000a2ec:	f3ef 8305 	mrs	r3, IPSR
		ret = -EDEADLK;
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
6000a2f0:	b173      	cbz	r3, 6000a310 <z_impl_k_thread_join+0x88>
6000a2f2:	4930      	ldr	r1, [pc, #192]	; (6000a3b4 <z_impl_k_thread_join+0x12c>)
6000a2f4:	f240 7315 	movw	r3, #1813	; 0x715
6000a2f8:	4a2f      	ldr	r2, [pc, #188]	; (6000a3b8 <z_impl_k_thread_join+0x130>)
6000a2fa:	482b      	ldr	r0, [pc, #172]	; (6000a3a8 <z_impl_k_thread_join+0x120>)
6000a2fc:	f000 fbe0 	bl	6000aac0 <assert_print>
6000a300:	482e      	ldr	r0, [pc, #184]	; (6000a3bc <z_impl_k_thread_join+0x134>)
6000a302:	f000 fbdd 	bl	6000aac0 <assert_print>
6000a306:	f240 7115 	movw	r1, #1813	; 0x715
6000a30a:	482b      	ldr	r0, [pc, #172]	; (6000a3b8 <z_impl_k_thread_join+0x130>)
6000a30c:	f000 fbd1 	bl	6000aab2 <assert_post_action>
		add_to_waitq_locked(_current, &thread->join_queue);
6000a310:	f104 0158 	add.w	r1, r4, #88	; 0x58
6000a314:	f7ff fb76 	bl	60009a04 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
6000a318:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
6000a31c:	bf08      	it	eq
6000a31e:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
6000a322:	d007      	beq.n	6000a334 <z_impl_k_thread_join+0xac>
		add_thread_timeout(_current, timeout);
6000a324:	f8d8 0008 	ldr.w	r0, [r8, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
6000a328:	4632      	mov	r2, r6
6000a32a:	462b      	mov	r3, r5
6000a32c:	4924      	ldr	r1, [pc, #144]	; (6000a3c0 <z_impl_k_thread_join+0x138>)
6000a32e:	3018      	adds	r0, #24
6000a330:	f000 f8cc 	bl	6000a4cc <z_add_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a334:	4819      	ldr	r0, [pc, #100]	; (6000a39c <z_impl_k_thread_join+0x114>)
6000a336:	f7fe fec5 	bl	600090c4 <z_spin_unlock_valid>
6000a33a:	b958      	cbnz	r0, 6000a354 <z_impl_k_thread_join+0xcc>
6000a33c:	23e1      	movs	r3, #225	; 0xe1
6000a33e:	4a18      	ldr	r2, [pc, #96]	; (6000a3a0 <z_impl_k_thread_join+0x118>)
6000a340:	4920      	ldr	r1, [pc, #128]	; (6000a3c4 <z_impl_k_thread_join+0x13c>)
6000a342:	4819      	ldr	r0, [pc, #100]	; (6000a3a8 <z_impl_k_thread_join+0x120>)
6000a344:	f000 fbbc 	bl	6000aac0 <assert_print>
6000a348:	4914      	ldr	r1, [pc, #80]	; (6000a39c <z_impl_k_thread_join+0x114>)
6000a34a:	481f      	ldr	r0, [pc, #124]	; (6000a3c8 <z_impl_k_thread_join+0x140>)
6000a34c:	f000 fbb8 	bl	6000aac0 <assert_print>
6000a350:	21e1      	movs	r1, #225	; 0xe1
6000a352:	e7b5      	b.n	6000a2c0 <z_impl_k_thread_join+0x38>
6000a354:	4638      	mov	r0, r7

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
}
6000a356:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
6000a35a:	f7fa baa3 	b.w	600048a4 <arch_swap>
		ret = 0;
6000a35e:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a360:	480e      	ldr	r0, [pc, #56]	; (6000a39c <z_impl_k_thread_join+0x114>)
6000a362:	f7fe feaf 	bl	600090c4 <z_spin_unlock_valid>
6000a366:	b988      	cbnz	r0, 6000a38c <z_impl_k_thread_join+0x104>
6000a368:	23c2      	movs	r3, #194	; 0xc2
6000a36a:	4a0d      	ldr	r2, [pc, #52]	; (6000a3a0 <z_impl_k_thread_join+0x118>)
6000a36c:	4915      	ldr	r1, [pc, #84]	; (6000a3c4 <z_impl_k_thread_join+0x13c>)
6000a36e:	480e      	ldr	r0, [pc, #56]	; (6000a3a8 <z_impl_k_thread_join+0x120>)
6000a370:	f000 fba6 	bl	6000aac0 <assert_print>
6000a374:	4909      	ldr	r1, [pc, #36]	; (6000a39c <z_impl_k_thread_join+0x114>)
6000a376:	4814      	ldr	r0, [pc, #80]	; (6000a3c8 <z_impl_k_thread_join+0x140>)
6000a378:	f000 fba2 	bl	6000aac0 <assert_print>
6000a37c:	21c2      	movs	r1, #194	; 0xc2
6000a37e:	e79f      	b.n	6000a2c0 <z_impl_k_thread_join+0x38>
		ret = -EBUSY;
6000a380:	f06f 040f 	mvn.w	r4, #15
6000a384:	e7ec      	b.n	6000a360 <z_impl_k_thread_join+0xd8>
		ret = -EDEADLK;
6000a386:	f06f 042c 	mvn.w	r4, #44	; 0x2c
6000a38a:	e7e9      	b.n	6000a360 <z_impl_k_thread_join+0xd8>
	__asm__ volatile(
6000a38c:	f387 8811 	msr	BASEPRI, r7
6000a390:	f3bf 8f6f 	isb	sy
}
6000a394:	4620      	mov	r0, r4
6000a396:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
6000a39a:	bf00      	nop
6000a39c:	800016fc 	.word	0x800016fc
6000a3a0:	6000d5ed 	.word	0x6000d5ed
6000a3a4:	6000d61a 	.word	0x6000d61a
6000a3a8:	6000c68a 	.word	0x6000c68a
6000a3ac:	6000d62f 	.word	0x6000d62f
6000a3b0:	800016c8 	.word	0x800016c8
6000a3b4:	6000e166 	.word	0x6000e166
6000a3b8:	6000e2a3 	.word	0x6000e2a3
6000a3bc:	6000e469 	.word	0x6000e469
6000a3c0:	60009cad 	.word	0x60009cad
6000a3c4:	6000d647 	.word	0x6000d647
6000a3c8:	6000d65e 	.word	0x6000d65e

6000a3cc <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
6000a3cc:	480c      	ldr	r0, [pc, #48]	; (6000a400 <z_data_copy+0x34>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
6000a3ce:	4a0d      	ldr	r2, [pc, #52]	; (6000a404 <z_data_copy+0x38>)
6000a3d0:	490d      	ldr	r1, [pc, #52]	; (6000a408 <z_data_copy+0x3c>)
6000a3d2:	1a12      	subs	r2, r2, r0
{
6000a3d4:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
6000a3d6:	f001 f86b 	bl	6000b4b0 <z_early_memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
6000a3da:	4a0c      	ldr	r2, [pc, #48]	; (6000a40c <z_data_copy+0x40>)
6000a3dc:	490c      	ldr	r1, [pc, #48]	; (6000a410 <z_data_copy+0x44>)
6000a3de:	480d      	ldr	r0, [pc, #52]	; (6000a414 <z_data_copy+0x48>)
6000a3e0:	f001 f866 	bl	6000b4b0 <z_early_memcpy>
#if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_ccm), okay)
	z_early_memcpy(&__ccm_data_start, &__ccm_data_rom_start,
		       __ccm_data_end - __ccm_data_start);
#endif
#if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_itcm), okay)
	z_early_memcpy(&__itcm_start, &__itcm_load_start,
6000a3e4:	4a0c      	ldr	r2, [pc, #48]	; (6000a418 <z_data_copy+0x4c>)
6000a3e6:	490d      	ldr	r1, [pc, #52]	; (6000a41c <z_data_copy+0x50>)
6000a3e8:	480d      	ldr	r0, [pc, #52]	; (6000a420 <z_data_copy+0x54>)
6000a3ea:	f001 f861 	bl	6000b4b0 <z_early_memcpy>
		       (uintptr_t) &__itcm_size);
#endif
#if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_dtcm), okay)
	z_early_memcpy(&__dtcm_data_start, &__dtcm_data_load_start,
		       __dtcm_data_end - __dtcm_data_start);
6000a3ee:	480d      	ldr	r0, [pc, #52]	; (6000a424 <z_data_copy+0x58>)
	z_early_memcpy(&__dtcm_data_start, &__dtcm_data_load_start,
6000a3f0:	4a0d      	ldr	r2, [pc, #52]	; (6000a428 <z_data_copy+0x5c>)
6000a3f2:	490e      	ldr	r1, [pc, #56]	; (6000a42c <z_data_copy+0x60>)
6000a3f4:	1a12      	subs	r2, r2, r0
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
6000a3f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__dtcm_data_start, &__dtcm_data_load_start,
6000a3fa:	f001 b859 	b.w	6000b4b0 <z_early_memcpy>
6000a3fe:	bf00      	nop
6000a400:	80000800 	.word	0x80000800
6000a404:	8000094c 	.word	0x8000094c
6000a408:	6000e504 	.word	0x6000e504
6000a40c:	00000000 	.word	0x00000000
6000a410:	6000e504 	.word	0x6000e504
6000a414:	80000800 	.word	0x80000800
6000a418:	00000000 	.word	0x00000000
6000a41c:	6000e650 	.word	0x6000e650
6000a420:	00000000 	.word	0x00000000
6000a424:	20000000 	.word	0x20000000
6000a428:	20000000 	.word	0x20000000
6000a42c:	6000e650 	.word	0x6000e650

6000a430 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
6000a430:	4b03      	ldr	r3, [pc, #12]	; (6000a440 <elapsed+0x10>)
6000a432:	681b      	ldr	r3, [r3, #0]
6000a434:	b90b      	cbnz	r3, 6000a43a <elapsed+0xa>
6000a436:	f7fc ba77 	b.w	60006928 <sys_clock_elapsed>
}
6000a43a:	2000      	movs	r0, #0
6000a43c:	4770      	bx	lr
6000a43e:	bf00      	nop
6000a440:	80001700 	.word	0x80001700

6000a444 <next_timeout>:
	return list->head == list;
6000a444:	4b11      	ldr	r3, [pc, #68]	; (6000a48c <next_timeout+0x48>)

static int32_t next_timeout(void)
{
6000a446:	b510      	push	{r4, lr}
6000a448:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
6000a44a:	429c      	cmp	r4, r3
6000a44c:	d10a      	bne.n	6000a464 <next_timeout+0x20>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
6000a44e:	f7ff ffef 	bl	6000a430 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
6000a452:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
6000a456:	4b0e      	ldr	r3, [pc, #56]	; (6000a490 <next_timeout+0x4c>)
6000a458:	691b      	ldr	r3, [r3, #16]
6000a45a:	b113      	cbz	r3, 6000a462 <next_timeout+0x1e>
6000a45c:	4298      	cmp	r0, r3
6000a45e:	bfa8      	it	ge
6000a460:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
6000a462:	bd10      	pop	{r4, pc}
	int32_t ticks_elapsed = elapsed();
6000a464:	f7ff ffe4 	bl	6000a430 <elapsed>
	if ((to == NULL) ||
6000a468:	2c00      	cmp	r4, #0
6000a46a:	d0f2      	beq.n	6000a452 <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
6000a46c:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
6000a470:	1a1b      	subs	r3, r3, r0
6000a472:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
6000a476:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
6000a47a:	f172 0100 	sbcs.w	r1, r2, #0
6000a47e:	dae8      	bge.n	6000a452 <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
6000a480:	2a00      	cmp	r2, #0
6000a482:	bfac      	ite	ge
6000a484:	4618      	movge	r0, r3
6000a486:	2000      	movlt	r0, #0
6000a488:	e7e5      	b.n	6000a456 <next_timeout+0x12>
6000a48a:	bf00      	nop
6000a48c:	80000930 	.word	0x80000930
6000a490:	800016c8 	.word	0x800016c8

6000a494 <remove_timeout>:
{
6000a494:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
6000a496:	b170      	cbz	r0, 6000a4b6 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
6000a498:	4b0b      	ldr	r3, [pc, #44]	; (6000a4c8 <remove_timeout+0x34>)
6000a49a:	685b      	ldr	r3, [r3, #4]
6000a49c:	4298      	cmp	r0, r3
6000a49e:	d00a      	beq.n	6000a4b6 <remove_timeout+0x22>
6000a4a0:	6803      	ldr	r3, [r0, #0]
	if (next(t) != NULL) {
6000a4a2:	b143      	cbz	r3, 6000a4b6 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
6000a4a4:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
6000a4a8:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
6000a4ac:	1912      	adds	r2, r2, r4
6000a4ae:	eb41 0105 	adc.w	r1, r1, r5
6000a4b2:	e9c3 2104 	strd	r2, r1, [r3, #16]
	sys_dnode_t *const next = node->next;
6000a4b6:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
6000a4ba:	6013      	str	r3, [r2, #0]
	next->prev = prev;
6000a4bc:	605a      	str	r2, [r3, #4]
	node->next = NULL;
6000a4be:	2300      	movs	r3, #0
	node->prev = NULL;
6000a4c0:	e9c0 3300 	strd	r3, r3, [r0]
}
6000a4c4:	bd30      	pop	{r4, r5, pc}
6000a4c6:	bf00      	nop
6000a4c8:	80000930 	.word	0x80000930

6000a4cc <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
6000a4cc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
6000a4d0:	bf08      	it	eq
6000a4d2:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
6000a4d6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
6000a4da:	4604      	mov	r4, r0
6000a4dc:	4692      	mov	sl, r2
6000a4de:	461d      	mov	r5, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
6000a4e0:	f000 809e 	beq.w	6000a620 <z_add_timeout+0x154>
	return node->next != NULL;
6000a4e4:	6806      	ldr	r6, [r0, #0]

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
6000a4e6:	b166      	cbz	r6, 6000a502 <z_add_timeout+0x36>
6000a4e8:	494e      	ldr	r1, [pc, #312]	; (6000a624 <z_add_timeout+0x158>)
6000a4ea:	2363      	movs	r3, #99	; 0x63
6000a4ec:	4a4e      	ldr	r2, [pc, #312]	; (6000a628 <z_add_timeout+0x15c>)
6000a4ee:	484f      	ldr	r0, [pc, #316]	; (6000a62c <z_add_timeout+0x160>)
6000a4f0:	f000 fae6 	bl	6000aac0 <assert_print>
6000a4f4:	484e      	ldr	r0, [pc, #312]	; (6000a630 <z_add_timeout+0x164>)
6000a4f6:	f000 fae3 	bl	6000aac0 <assert_print>
6000a4fa:	2163      	movs	r1, #99	; 0x63
6000a4fc:	484a      	ldr	r0, [pc, #296]	; (6000a628 <z_add_timeout+0x15c>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000a4fe:	f000 fad8 	bl	6000aab2 <assert_post_action>
	to->fn = fn;
6000a502:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
6000a504:	f04f 0310 	mov.w	r3, #16
6000a508:	f3ef 8711 	mrs	r7, BASEPRI
6000a50c:	f383 8812 	msr	BASEPRI_MAX, r3
6000a510:	f3bf 8f6f 	isb	sy
6000a514:	4847      	ldr	r0, [pc, #284]	; (6000a634 <z_add_timeout+0x168>)
6000a516:	f7fe fdc7 	bl	600090a8 <z_spin_lock_valid>
6000a51a:	b960      	cbnz	r0, 6000a536 <z_add_timeout+0x6a>
6000a51c:	2394      	movs	r3, #148	; 0x94
6000a51e:	4a46      	ldr	r2, [pc, #280]	; (6000a638 <z_add_timeout+0x16c>)
6000a520:	4946      	ldr	r1, [pc, #280]	; (6000a63c <z_add_timeout+0x170>)
6000a522:	4842      	ldr	r0, [pc, #264]	; (6000a62c <z_add_timeout+0x160>)
6000a524:	f000 facc 	bl	6000aac0 <assert_print>
6000a528:	4942      	ldr	r1, [pc, #264]	; (6000a634 <z_add_timeout+0x168>)
6000a52a:	4845      	ldr	r0, [pc, #276]	; (6000a640 <z_add_timeout+0x174>)
6000a52c:	f000 fac8 	bl	6000aac0 <assert_print>
6000a530:	2194      	movs	r1, #148	; 0x94
6000a532:	4841      	ldr	r0, [pc, #260]	; (6000a638 <z_add_timeout+0x16c>)
6000a534:	e7e3      	b.n	6000a4fe <z_add_timeout+0x32>
	z_spin_lock_set_owner(l);
6000a536:	483f      	ldr	r0, [pc, #252]	; (6000a634 <z_add_timeout+0x168>)
6000a538:	f7fe fdd2 	bl	600090e0 <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
6000a53c:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
6000a540:	f175 33ff 	sbcs.w	r3, r5, #4294967295	; 0xffffffff
6000a544:	da23      	bge.n	6000a58e <z_add_timeout+0xc2>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
6000a546:	493f      	ldr	r1, [pc, #252]	; (6000a644 <z_add_timeout+0x178>)
6000a548:	f06f 0301 	mvn.w	r3, #1
6000a54c:	e9d1 2000 	ldrd	r2, r0, [r1]
6000a550:	1a9b      	subs	r3, r3, r2
6000a552:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
6000a556:	eb62 0000 	sbc.w	r0, r2, r0
6000a55a:	ebb3 030a 	subs.w	r3, r3, sl
6000a55e:	eb60 0005 	sbc.w	r0, r0, r5

			to->dticks = MAX(1, ticks);
6000a562:	2b01      	cmp	r3, #1
6000a564:	f170 0200 	sbcs.w	r2, r0, #0
6000a568:	da01      	bge.n	6000a56e <z_add_timeout+0xa2>
6000a56a:	2301      	movs	r3, #1
6000a56c:	4630      	mov	r0, r6
6000a56e:	e9c4 3004 	strd	r3, r0, [r4, #16]
	return list->head == list;
6000a572:	4b35      	ldr	r3, [pc, #212]	; (6000a648 <z_add_timeout+0x17c>)
6000a574:	681a      	ldr	r2, [r3, #0]
	return (node == list->tail) ? NULL : node->next;
6000a576:	f8d3 c004 	ldr.w	ip, [r3, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
6000a57a:	429a      	cmp	r2, r3
6000a57c:	bf18      	it	ne
6000a57e:	4616      	movne	r6, r2
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
6000a580:	b986      	cbnz	r6, 6000a5a4 <z_add_timeout+0xd8>
	node->prev = tail;
6000a582:	e9c4 3c00 	strd	r3, ip, [r4]
	tail->next = node;
6000a586:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
6000a58a:	605c      	str	r4, [r3, #4]
}
6000a58c:	e01c      	b.n	6000a5c8 <z_add_timeout+0xfc>
			to->dticks = timeout.ticks + 1 + elapsed();
6000a58e:	f7ff ff4f 	bl	6000a430 <elapsed>
6000a592:	f11a 0801 	adds.w	r8, sl, #1
6000a596:	f145 0500 	adc.w	r5, r5, #0
6000a59a:	eb18 0300 	adds.w	r3, r8, r0
6000a59e:	eb45 70e0 	adc.w	r0, r5, r0, asr #31
6000a5a2:	e7e4      	b.n	6000a56e <z_add_timeout+0xa2>
			if (t->dticks > to->dticks) {
6000a5a4:	e9d6 1504 	ldrd	r1, r5, [r6, #16]
6000a5a8:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
6000a5ac:	428a      	cmp	r2, r1
6000a5ae:	eb70 0e05 	sbcs.w	lr, r0, r5
6000a5b2:	da28      	bge.n	6000a606 <z_add_timeout+0x13a>
				t->dticks -= to->dticks;
6000a5b4:	1a89      	subs	r1, r1, r2
	sys_dnode_t *const prev = successor->prev;
6000a5b6:	6872      	ldr	r2, [r6, #4]
6000a5b8:	eb65 0500 	sbc.w	r5, r5, r0
6000a5bc:	e9c6 1504 	strd	r1, r5, [r6, #16]
	node->next = successor;
6000a5c0:	e9c4 6200 	strd	r6, r2, [r4]
	prev->next = node;
6000a5c4:	6014      	str	r4, [r2, #0]
	successor->prev = node;
6000a5c6:	6074      	str	r4, [r6, #4]
	return list->head == list;
6000a5c8:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
6000a5ca:	429a      	cmp	r2, r3
6000a5cc:	d00b      	beq.n	6000a5e6 <z_add_timeout+0x11a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
6000a5ce:	4294      	cmp	r4, r2
6000a5d0:	d109      	bne.n	6000a5e6 <z_add_timeout+0x11a>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
6000a5d2:	f7ff ff37 	bl	6000a444 <next_timeout>

			if (next_time == 0 ||
6000a5d6:	b118      	cbz	r0, 6000a5e0 <z_add_timeout+0x114>
			    _current_cpu->slice_ticks != next_time) {
6000a5d8:	4b1c      	ldr	r3, [pc, #112]	; (6000a64c <z_add_timeout+0x180>)
			if (next_time == 0 ||
6000a5da:	691b      	ldr	r3, [r3, #16]
6000a5dc:	4283      	cmp	r3, r0
6000a5de:	d002      	beq.n	6000a5e6 <z_add_timeout+0x11a>
				sys_clock_set_timeout(next_time, false);
6000a5e0:	2100      	movs	r1, #0
6000a5e2:	f7fc f8fd 	bl	600067e0 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a5e6:	4813      	ldr	r0, [pc, #76]	; (6000a634 <z_add_timeout+0x168>)
6000a5e8:	f7fe fd6c 	bl	600090c4 <z_spin_unlock_valid>
6000a5ec:	b9a0      	cbnz	r0, 6000a618 <z_add_timeout+0x14c>
6000a5ee:	23c2      	movs	r3, #194	; 0xc2
6000a5f0:	4a11      	ldr	r2, [pc, #68]	; (6000a638 <z_add_timeout+0x16c>)
6000a5f2:	4917      	ldr	r1, [pc, #92]	; (6000a650 <z_add_timeout+0x184>)
6000a5f4:	480d      	ldr	r0, [pc, #52]	; (6000a62c <z_add_timeout+0x160>)
6000a5f6:	f000 fa63 	bl	6000aac0 <assert_print>
6000a5fa:	490e      	ldr	r1, [pc, #56]	; (6000a634 <z_add_timeout+0x168>)
6000a5fc:	4815      	ldr	r0, [pc, #84]	; (6000a654 <z_add_timeout+0x188>)
6000a5fe:	f000 fa5f 	bl	6000aac0 <assert_print>
6000a602:	21c2      	movs	r1, #194	; 0xc2
6000a604:	e795      	b.n	6000a532 <z_add_timeout+0x66>
			to->dticks -= t->dticks;
6000a606:	1a52      	subs	r2, r2, r1
6000a608:	eb60 0005 	sbc.w	r0, r0, r5
	return (node == list->tail) ? NULL : node->next;
6000a60c:	4566      	cmp	r6, ip
6000a60e:	e9c4 2004 	strd	r2, r0, [r4, #16]
6000a612:	d0b6      	beq.n	6000a582 <z_add_timeout+0xb6>
6000a614:	6836      	ldr	r6, [r6, #0]
6000a616:	e7b3      	b.n	6000a580 <z_add_timeout+0xb4>
	__asm__ volatile(
6000a618:	f387 8811 	msr	BASEPRI, r7
6000a61c:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
6000a620:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
6000a624:	6000e4a2 	.word	0x6000e4a2
6000a628:	6000e47e 	.word	0x6000e47e
6000a62c:	6000c68a 	.word	0x6000c68a
6000a630:	6000e2a0 	.word	0x6000e2a0
6000a634:	80001704 	.word	0x80001704
6000a638:	6000d5ed 	.word	0x6000d5ed
6000a63c:	6000d61a 	.word	0x6000d61a
6000a640:	6000d62f 	.word	0x6000d62f
6000a644:	80000b30 	.word	0x80000b30
6000a648:	80000930 	.word	0x80000930
6000a64c:	800016c8 	.word	0x800016c8
6000a650:	6000d647 	.word	0x6000d647
6000a654:	6000d65e 	.word	0x6000d65e

6000a658 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
6000a658:	b538      	push	{r3, r4, r5, lr}
6000a65a:	4604      	mov	r4, r0
	__asm__ volatile(
6000a65c:	f04f 0310 	mov.w	r3, #16
6000a660:	f3ef 8511 	mrs	r5, BASEPRI
6000a664:	f383 8812 	msr	BASEPRI_MAX, r3
6000a668:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000a66c:	4819      	ldr	r0, [pc, #100]	; (6000a6d4 <z_abort_timeout+0x7c>)
6000a66e:	f7fe fd1b 	bl	600090a8 <z_spin_lock_valid>
6000a672:	b968      	cbnz	r0, 6000a690 <z_abort_timeout+0x38>
6000a674:	2394      	movs	r3, #148	; 0x94
6000a676:	4a18      	ldr	r2, [pc, #96]	; (6000a6d8 <z_abort_timeout+0x80>)
6000a678:	4918      	ldr	r1, [pc, #96]	; (6000a6dc <z_abort_timeout+0x84>)
6000a67a:	4819      	ldr	r0, [pc, #100]	; (6000a6e0 <z_abort_timeout+0x88>)
6000a67c:	f000 fa20 	bl	6000aac0 <assert_print>
6000a680:	4914      	ldr	r1, [pc, #80]	; (6000a6d4 <z_abort_timeout+0x7c>)
6000a682:	4818      	ldr	r0, [pc, #96]	; (6000a6e4 <z_abort_timeout+0x8c>)
6000a684:	f000 fa1c 	bl	6000aac0 <assert_print>
6000a688:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a68a:	4813      	ldr	r0, [pc, #76]	; (6000a6d8 <z_abort_timeout+0x80>)
6000a68c:	f000 fa11 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
6000a690:	4810      	ldr	r0, [pc, #64]	; (6000a6d4 <z_abort_timeout+0x7c>)
6000a692:	f7fe fd25 	bl	600090e0 <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
6000a696:	6823      	ldr	r3, [r4, #0]
6000a698:	b19b      	cbz	r3, 6000a6c2 <z_abort_timeout+0x6a>
			remove_timeout(to);
6000a69a:	4620      	mov	r0, r4
			ret = 0;
6000a69c:	2400      	movs	r4, #0
			remove_timeout(to);
6000a69e:	f7ff fef9 	bl	6000a494 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a6a2:	480c      	ldr	r0, [pc, #48]	; (6000a6d4 <z_abort_timeout+0x7c>)
6000a6a4:	f7fe fd0e 	bl	600090c4 <z_spin_unlock_valid>
6000a6a8:	b970      	cbnz	r0, 6000a6c8 <z_abort_timeout+0x70>
6000a6aa:	23c2      	movs	r3, #194	; 0xc2
6000a6ac:	4a0a      	ldr	r2, [pc, #40]	; (6000a6d8 <z_abort_timeout+0x80>)
6000a6ae:	490e      	ldr	r1, [pc, #56]	; (6000a6e8 <z_abort_timeout+0x90>)
6000a6b0:	480b      	ldr	r0, [pc, #44]	; (6000a6e0 <z_abort_timeout+0x88>)
6000a6b2:	f000 fa05 	bl	6000aac0 <assert_print>
6000a6b6:	4907      	ldr	r1, [pc, #28]	; (6000a6d4 <z_abort_timeout+0x7c>)
6000a6b8:	480c      	ldr	r0, [pc, #48]	; (6000a6ec <z_abort_timeout+0x94>)
6000a6ba:	f000 fa01 	bl	6000aac0 <assert_print>
6000a6be:	21c2      	movs	r1, #194	; 0xc2
6000a6c0:	e7e3      	b.n	6000a68a <z_abort_timeout+0x32>
	int ret = -EINVAL;
6000a6c2:	f06f 0415 	mvn.w	r4, #21
6000a6c6:	e7ec      	b.n	6000a6a2 <z_abort_timeout+0x4a>
	__asm__ volatile(
6000a6c8:	f385 8811 	msr	BASEPRI, r5
6000a6cc:	f3bf 8f6f 	isb	sy
		}
	}

	return ret;
}
6000a6d0:	4620      	mov	r0, r4
6000a6d2:	bd38      	pop	{r3, r4, r5, pc}
6000a6d4:	80001704 	.word	0x80001704
6000a6d8:	6000d5ed 	.word	0x6000d5ed
6000a6dc:	6000d61a 	.word	0x6000d61a
6000a6e0:	6000c68a 	.word	0x6000c68a
6000a6e4:	6000d62f 	.word	0x6000d62f
6000a6e8:	6000d647 	.word	0x6000d647
6000a6ec:	6000d65e 	.word	0x6000d65e

6000a6f0 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
6000a6f0:	b570      	push	{r4, r5, r6, lr}
6000a6f2:	4604      	mov	r4, r0
6000a6f4:	460d      	mov	r5, r1
	__asm__ volatile(
6000a6f6:	f04f 0310 	mov.w	r3, #16
6000a6fa:	f3ef 8611 	mrs	r6, BASEPRI
6000a6fe:	f383 8812 	msr	BASEPRI_MAX, r3
6000a702:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000a706:	481b      	ldr	r0, [pc, #108]	; (6000a774 <z_set_timeout_expiry+0x84>)
6000a708:	f7fe fcce 	bl	600090a8 <z_spin_lock_valid>
6000a70c:	b968      	cbnz	r0, 6000a72a <z_set_timeout_expiry+0x3a>
6000a70e:	2394      	movs	r3, #148	; 0x94
6000a710:	4a19      	ldr	r2, [pc, #100]	; (6000a778 <z_set_timeout_expiry+0x88>)
6000a712:	491a      	ldr	r1, [pc, #104]	; (6000a77c <z_set_timeout_expiry+0x8c>)
6000a714:	481a      	ldr	r0, [pc, #104]	; (6000a780 <z_set_timeout_expiry+0x90>)
6000a716:	f000 f9d3 	bl	6000aac0 <assert_print>
6000a71a:	4916      	ldr	r1, [pc, #88]	; (6000a774 <z_set_timeout_expiry+0x84>)
6000a71c:	4819      	ldr	r0, [pc, #100]	; (6000a784 <z_set_timeout_expiry+0x94>)
6000a71e:	f000 f9cf 	bl	6000aac0 <assert_print>
6000a722:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a724:	4814      	ldr	r0, [pc, #80]	; (6000a778 <z_set_timeout_expiry+0x88>)
6000a726:	f000 f9c4 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
6000a72a:	4812      	ldr	r0, [pc, #72]	; (6000a774 <z_set_timeout_expiry+0x84>)
6000a72c:	f7fe fcd8 	bl	600090e0 <z_spin_lock_set_owner>
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
6000a730:	f7ff fe88 	bl	6000a444 <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
			      || (ticks <= next_to);
6000a734:	2801      	cmp	r0, #1
6000a736:	dd07      	ble.n	6000a748 <z_set_timeout_expiry+0x58>
6000a738:	42a0      	cmp	r0, r4
6000a73a:	db05      	blt.n	6000a748 <z_set_timeout_expiry+0x58>
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
6000a73c:	42a0      	cmp	r0, r4
6000a73e:	4629      	mov	r1, r5
6000a740:	bfa8      	it	ge
6000a742:	4620      	movge	r0, r4
6000a744:	f7fc f84c 	bl	600067e0 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a748:	480a      	ldr	r0, [pc, #40]	; (6000a774 <z_set_timeout_expiry+0x84>)
6000a74a:	f7fe fcbb 	bl	600090c4 <z_spin_unlock_valid>
6000a74e:	b958      	cbnz	r0, 6000a768 <z_set_timeout_expiry+0x78>
6000a750:	23c2      	movs	r3, #194	; 0xc2
6000a752:	4a09      	ldr	r2, [pc, #36]	; (6000a778 <z_set_timeout_expiry+0x88>)
6000a754:	490c      	ldr	r1, [pc, #48]	; (6000a788 <z_set_timeout_expiry+0x98>)
6000a756:	480a      	ldr	r0, [pc, #40]	; (6000a780 <z_set_timeout_expiry+0x90>)
6000a758:	f000 f9b2 	bl	6000aac0 <assert_print>
6000a75c:	4905      	ldr	r1, [pc, #20]	; (6000a774 <z_set_timeout_expiry+0x84>)
6000a75e:	480b      	ldr	r0, [pc, #44]	; (6000a78c <z_set_timeout_expiry+0x9c>)
6000a760:	f000 f9ae 	bl	6000aac0 <assert_print>
6000a764:	21c2      	movs	r1, #194	; 0xc2
6000a766:	e7dd      	b.n	6000a724 <z_set_timeout_expiry+0x34>
	__asm__ volatile(
6000a768:	f386 8811 	msr	BASEPRI, r6
6000a76c:	f3bf 8f6f 	isb	sy
		}
	}
}
6000a770:	bd70      	pop	{r4, r5, r6, pc}
6000a772:	bf00      	nop
6000a774:	80001704 	.word	0x80001704
6000a778:	6000d5ed 	.word	0x6000d5ed
6000a77c:	6000d61a 	.word	0x6000d61a
6000a780:	6000c68a 	.word	0x6000c68a
6000a784:	6000d62f 	.word	0x6000d62f
6000a788:	6000d647 	.word	0x6000d647
6000a78c:	6000d65e 	.word	0x6000d65e

6000a790 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
6000a790:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
6000a794:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
6000a796:	f7ff f8a3 	bl	600098e0 <z_time_slice>
	__asm__ volatile(
6000a79a:	f04f 0310 	mov.w	r3, #16
6000a79e:	f3ef 8811 	mrs	r8, BASEPRI
6000a7a2:	f383 8812 	msr	BASEPRI_MAX, r3
6000a7a6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000a7aa:	4846      	ldr	r0, [pc, #280]	; (6000a8c4 <sys_clock_announce+0x134>)
6000a7ac:	f7fe fc7c 	bl	600090a8 <z_spin_lock_valid>
6000a7b0:	b968      	cbnz	r0, 6000a7ce <sys_clock_announce+0x3e>
6000a7b2:	2394      	movs	r3, #148	; 0x94
6000a7b4:	4a44      	ldr	r2, [pc, #272]	; (6000a8c8 <sys_clock_announce+0x138>)
6000a7b6:	4945      	ldr	r1, [pc, #276]	; (6000a8cc <sys_clock_announce+0x13c>)
6000a7b8:	4845      	ldr	r0, [pc, #276]	; (6000a8d0 <sys_clock_announce+0x140>)
6000a7ba:	f000 f981 	bl	6000aac0 <assert_print>
6000a7be:	4941      	ldr	r1, [pc, #260]	; (6000a8c4 <sys_clock_announce+0x134>)
6000a7c0:	4844      	ldr	r0, [pc, #272]	; (6000a8d4 <sys_clock_announce+0x144>)
6000a7c2:	f000 f97d 	bl	6000aac0 <assert_print>
6000a7c6:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a7c8:	483f      	ldr	r0, [pc, #252]	; (6000a8c8 <sys_clock_announce+0x138>)
6000a7ca:	f000 f972 	bl	6000aab2 <assert_post_action>
	return list->head == list;
6000a7ce:	f8df 9108 	ldr.w	r9, [pc, #264]	; 6000a8d8 <sys_clock_announce+0x148>
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
		t->dticks = 0;
6000a7d2:	2600      	movs	r6, #0
	announce_remaining = ticks;
6000a7d4:	f8df b104 	ldr.w	fp, [pc, #260]	; 6000a8dc <sys_clock_announce+0x14c>
		t->dticks = 0;
6000a7d8:	2700      	movs	r7, #0
	z_spin_lock_set_owner(l);
6000a7da:	483a      	ldr	r0, [pc, #232]	; (6000a8c4 <sys_clock_announce+0x134>)
6000a7dc:	f7fe fc80 	bl	600090e0 <z_spin_lock_set_owner>
	announce_remaining = ticks;
6000a7e0:	f8cb 4000 	str.w	r4, [fp]
6000a7e4:	f8d9 4000 	ldr.w	r4, [r9]
		curr_tick += dt;
6000a7e8:	f8df a0f4 	ldr.w	sl, [pc, #244]	; 6000a8e0 <sys_clock_announce+0x150>
	return sys_dlist_is_empty(list) ? NULL : list->head;
6000a7ec:	454c      	cmp	r4, r9
6000a7ee:	bf08      	it	eq
6000a7f0:	2400      	moveq	r4, #0
	     (t != NULL) && (t->dticks <= announce_remaining);
6000a7f2:	f8db 3000 	ldr.w	r3, [fp]
		curr_tick += dt;
6000a7f6:	e9da 2100 	ldrd	r2, r1, [sl]
	     (t != NULL) && (t->dticks <= announce_remaining);
6000a7fa:	2c00      	cmp	r4, #0
6000a7fc:	d049      	beq.n	6000a892 <sys_clock_announce+0x102>
6000a7fe:	ea4f 7ce3 	mov.w	ip, r3, asr #31
6000a802:	e9d4 5004 	ldrd	r5, r0, [r4, #16]
6000a806:	42ab      	cmp	r3, r5
6000a808:	eb7c 0e00 	sbcs.w	lr, ip, r0
6000a80c:	da05      	bge.n	6000a81a <sys_clock_announce+0x8a>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
6000a80e:	1aed      	subs	r5, r5, r3
6000a810:	eb60 000c 	sbc.w	r0, r0, ip
6000a814:	e9c4 5004 	strd	r5, r0, [r4, #16]
6000a818:	e03b      	b.n	6000a892 <sys_clock_announce+0x102>
		curr_tick += dt;
6000a81a:	18aa      	adds	r2, r5, r2
		remove_timeout(t);
6000a81c:	4620      	mov	r0, r4
		curr_tick += dt;
6000a81e:	eb41 71e5 	adc.w	r1, r1, r5, asr #31
		t->dticks = 0;
6000a822:	e9c4 6704 	strd	r6, r7, [r4, #16]
		curr_tick += dt;
6000a826:	e9ca 2100 	strd	r2, r1, [sl]
		remove_timeout(t);
6000a82a:	f7ff fe33 	bl	6000a494 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a82e:	4825      	ldr	r0, [pc, #148]	; (6000a8c4 <sys_clock_announce+0x134>)
6000a830:	f7fe fc48 	bl	600090c4 <z_spin_unlock_valid>
6000a834:	b958      	cbnz	r0, 6000a84e <sys_clock_announce+0xbe>
6000a836:	23c2      	movs	r3, #194	; 0xc2
6000a838:	4a23      	ldr	r2, [pc, #140]	; (6000a8c8 <sys_clock_announce+0x138>)
6000a83a:	492a      	ldr	r1, [pc, #168]	; (6000a8e4 <sys_clock_announce+0x154>)
6000a83c:	4824      	ldr	r0, [pc, #144]	; (6000a8d0 <sys_clock_announce+0x140>)
6000a83e:	f000 f93f 	bl	6000aac0 <assert_print>
6000a842:	4920      	ldr	r1, [pc, #128]	; (6000a8c4 <sys_clock_announce+0x134>)
6000a844:	4828      	ldr	r0, [pc, #160]	; (6000a8e8 <sys_clock_announce+0x158>)
6000a846:	f000 f93b 	bl	6000aac0 <assert_print>
6000a84a:	21c2      	movs	r1, #194	; 0xc2
6000a84c:	e7bc      	b.n	6000a7c8 <sys_clock_announce+0x38>
	__asm__ volatile(
6000a84e:	f388 8811 	msr	BASEPRI, r8
6000a852:	f3bf 8f6f 	isb	sy
		t->fn(t);
6000a856:	68a3      	ldr	r3, [r4, #8]
6000a858:	4620      	mov	r0, r4
6000a85a:	4798      	blx	r3
	__asm__ volatile(
6000a85c:	f04f 0310 	mov.w	r3, #16
6000a860:	f3ef 8811 	mrs	r8, BASEPRI
6000a864:	f383 8812 	msr	BASEPRI_MAX, r3
6000a868:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000a86c:	4815      	ldr	r0, [pc, #84]	; (6000a8c4 <sys_clock_announce+0x134>)
6000a86e:	f7fe fc1b 	bl	600090a8 <z_spin_lock_valid>
6000a872:	2800      	cmp	r0, #0
6000a874:	d09d      	beq.n	6000a7b2 <sys_clock_announce+0x22>
	z_spin_lock_set_owner(l);
6000a876:	4813      	ldr	r0, [pc, #76]	; (6000a8c4 <sys_clock_announce+0x134>)
6000a878:	f7fe fc32 	bl	600090e0 <z_spin_lock_set_owner>
		announce_remaining -= dt;
6000a87c:	f8db 3000 	ldr.w	r3, [fp]
	return list->head == list;
6000a880:	f8d9 4000 	ldr.w	r4, [r9]
6000a884:	1b5b      	subs	r3, r3, r5
	return sys_dlist_is_empty(list) ? NULL : list->head;
6000a886:	454c      	cmp	r4, r9
6000a888:	f8cb 3000 	str.w	r3, [fp]
6000a88c:	d1b1      	bne.n	6000a7f2 <sys_clock_announce+0x62>
		curr_tick += dt;
6000a88e:	e9da 2100 	ldrd	r2, r1, [sl]
	}

	curr_tick += announce_remaining;
6000a892:	189a      	adds	r2, r3, r2
	announce_remaining = 0;
6000a894:	f04f 0400 	mov.w	r4, #0
	curr_tick += announce_remaining;
6000a898:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
	announce_remaining = 0;
6000a89c:	f8cb 4000 	str.w	r4, [fp]
	curr_tick += announce_remaining;
6000a8a0:	e9ca 2100 	strd	r2, r1, [sl]

	sys_clock_set_timeout(next_timeout(), false);
6000a8a4:	f7ff fdce 	bl	6000a444 <next_timeout>
6000a8a8:	4621      	mov	r1, r4
6000a8aa:	f7fb ff99 	bl	600067e0 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a8ae:	4805      	ldr	r0, [pc, #20]	; (6000a8c4 <sys_clock_announce+0x134>)
6000a8b0:	f7fe fc08 	bl	600090c4 <z_spin_unlock_valid>
6000a8b4:	2800      	cmp	r0, #0
6000a8b6:	d0be      	beq.n	6000a836 <sys_clock_announce+0xa6>
	__asm__ volatile(
6000a8b8:	f388 8811 	msr	BASEPRI, r8
6000a8bc:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
6000a8c0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
6000a8c4:	80001704 	.word	0x80001704
6000a8c8:	6000d5ed 	.word	0x6000d5ed
6000a8cc:	6000d61a 	.word	0x6000d61a
6000a8d0:	6000c68a 	.word	0x6000c68a
6000a8d4:	6000d62f 	.word	0x6000d62f
6000a8d8:	80000930 	.word	0x80000930
6000a8dc:	80001700 	.word	0x80001700
6000a8e0:	80000b30 	.word	0x80000b30
6000a8e4:	6000d647 	.word	0x6000d647
6000a8e8:	6000d65e 	.word	0x6000d65e

6000a8ec <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
6000a8ec:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
6000a8ee:	f04f 0310 	mov.w	r3, #16
6000a8f2:	f3ef 8611 	mrs	r6, BASEPRI
6000a8f6:	f383 8812 	msr	BASEPRI_MAX, r3
6000a8fa:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
6000a8fe:	481a      	ldr	r0, [pc, #104]	; (6000a968 <sys_clock_tick_get+0x7c>)
6000a900:	f7fe fbd2 	bl	600090a8 <z_spin_lock_valid>
6000a904:	b968      	cbnz	r0, 6000a922 <sys_clock_tick_get+0x36>
6000a906:	2394      	movs	r3, #148	; 0x94
6000a908:	4a18      	ldr	r2, [pc, #96]	; (6000a96c <sys_clock_tick_get+0x80>)
6000a90a:	4919      	ldr	r1, [pc, #100]	; (6000a970 <sys_clock_tick_get+0x84>)
6000a90c:	4819      	ldr	r0, [pc, #100]	; (6000a974 <sys_clock_tick_get+0x88>)
6000a90e:	f000 f8d7 	bl	6000aac0 <assert_print>
6000a912:	4915      	ldr	r1, [pc, #84]	; (6000a968 <sys_clock_tick_get+0x7c>)
6000a914:	4818      	ldr	r0, [pc, #96]	; (6000a978 <sys_clock_tick_get+0x8c>)
6000a916:	f000 f8d3 	bl	6000aac0 <assert_print>
6000a91a:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a91c:	4813      	ldr	r0, [pc, #76]	; (6000a96c <sys_clock_tick_get+0x80>)
6000a91e:	f000 f8c8 	bl	6000aab2 <assert_post_action>
	z_spin_lock_set_owner(l);
6000a922:	4811      	ldr	r0, [pc, #68]	; (6000a968 <sys_clock_tick_get+0x7c>)
6000a924:	f7fe fbdc 	bl	600090e0 <z_spin_lock_set_owner>
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
6000a928:	f7ff fd82 	bl	6000a430 <elapsed>
6000a92c:	4a13      	ldr	r2, [pc, #76]	; (6000a97c <sys_clock_tick_get+0x90>)
6000a92e:	e9d2 4500 	ldrd	r4, r5, [r2]
6000a932:	1904      	adds	r4, r0, r4
6000a934:	eb45 75e0 	adc.w	r5, r5, r0, asr #31
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
6000a938:	480b      	ldr	r0, [pc, #44]	; (6000a968 <sys_clock_tick_get+0x7c>)
6000a93a:	f7fe fbc3 	bl	600090c4 <z_spin_unlock_valid>
6000a93e:	b958      	cbnz	r0, 6000a958 <sys_clock_tick_get+0x6c>
6000a940:	23c2      	movs	r3, #194	; 0xc2
6000a942:	4a0a      	ldr	r2, [pc, #40]	; (6000a96c <sys_clock_tick_get+0x80>)
6000a944:	490e      	ldr	r1, [pc, #56]	; (6000a980 <sys_clock_tick_get+0x94>)
6000a946:	480b      	ldr	r0, [pc, #44]	; (6000a974 <sys_clock_tick_get+0x88>)
6000a948:	f000 f8ba 	bl	6000aac0 <assert_print>
6000a94c:	4906      	ldr	r1, [pc, #24]	; (6000a968 <sys_clock_tick_get+0x7c>)
6000a94e:	480d      	ldr	r0, [pc, #52]	; (6000a984 <sys_clock_tick_get+0x98>)
6000a950:	f000 f8b6 	bl	6000aac0 <assert_print>
6000a954:	21c2      	movs	r1, #194	; 0xc2
6000a956:	e7e1      	b.n	6000a91c <sys_clock_tick_get+0x30>
	__asm__ volatile(
6000a958:	f386 8811 	msr	BASEPRI, r6
6000a95c:	f3bf 8f6f 	isb	sy
	}
	return t;
}
6000a960:	4620      	mov	r0, r4
6000a962:	4629      	mov	r1, r5
6000a964:	bd70      	pop	{r4, r5, r6, pc}
6000a966:	bf00      	nop
6000a968:	80001704 	.word	0x80001704
6000a96c:	6000d5ed 	.word	0x6000d5ed
6000a970:	6000d61a 	.word	0x6000d61a
6000a974:	6000c68a 	.word	0x6000c68a
6000a978:	6000d62f 	.word	0x6000d62f
6000a97c:	80000b30 	.word	0x80000b30
6000a980:	6000d647 	.word	0x6000d647
6000a984:	6000d65e 	.word	0x6000d65e

6000a988 <z_impl_k_busy_wait>:
}
#include <syscalls/k_uptime_ticks_mrsh.c>
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
6000a988:	b538      	push	{r3, r4, r5, lr}
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
6000a98a:	4604      	mov	r4, r0
6000a98c:	b178      	cbz	r0, 6000a9ae <z_impl_k_busy_wait+0x26>
6000a98e:	f7fc f81d 	bl	600069cc <sys_clock_cycle_get_32>
6000a992:	4605      	mov	r5, r0
#if !defined(CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT)
	uint32_t start_cycles = k_cycle_get_32();

	/* use 64-bit math to prevent overflow when multiplying */
	uint32_t cycles_to_wait = (uint32_t)(
		(uint64_t)usec_to_wait *
6000a994:	4806      	ldr	r0, [pc, #24]	; (6000a9b0 <z_impl_k_busy_wait+0x28>)
		(uint64_t)sys_clock_hw_cycles_per_sec() /
6000a996:	2300      	movs	r3, #0
6000a998:	4a06      	ldr	r2, [pc, #24]	; (6000a9b4 <z_impl_k_busy_wait+0x2c>)
6000a99a:	fba4 0100 	umull	r0, r1, r4, r0
6000a99e:	f7f9 f86b 	bl	60003a78 <__aeabi_uldivmod>
6000a9a2:	4604      	mov	r4, r0
6000a9a4:	f7fc f812 	bl	600069cc <sys_clock_cycle_get_32>

	for (;;) {
		uint32_t current_cycles = k_cycle_get_32();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
6000a9a8:	1b43      	subs	r3, r0, r5
6000a9aa:	42a3      	cmp	r3, r4
6000a9ac:	d3fa      	bcc.n	6000a9a4 <z_impl_k_busy_wait+0x1c>
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
6000a9ae:	bd38      	pop	{r3, r4, r5, pc}
6000a9b0:	1dcd6500 	.word	0x1dcd6500
6000a9b4:	000f4240 	.word	0x000f4240

6000a9b8 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
6000a9b8:	4801      	ldr	r0, [pc, #4]	; (6000a9c0 <boot_banner+0x8>)
6000a9ba:	f000 b806 	b.w	6000a9ca <printk>
6000a9be:	bf00      	nop
6000a9c0:	6000e4c2 	.word	0x6000e4c2

6000a9c4 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
6000a9c4:	4770      	bx	lr

6000a9c6 <arch_printk_char_out>:
}
6000a9c6:	2000      	movs	r0, #0
6000a9c8:	4770      	bx	lr

6000a9ca <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
6000a9ca:	b40f      	push	{r0, r1, r2, r3}
6000a9cc:	b507      	push	{r0, r1, r2, lr}
6000a9ce:	a904      	add	r1, sp, #16
6000a9d0:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
6000a9d4:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
6000a9d6:	f7f9 fa59 	bl	60003e8c <vprintk>

	va_end(ap);
}
6000a9da:	b003      	add	sp, #12
6000a9dc:	f85d eb04 	ldr.w	lr, [sp], #4
6000a9e0:	b004      	add	sp, #16
6000a9e2:	4770      	bx	lr

6000a9e4 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
6000a9e4:	4604      	mov	r4, r0
6000a9e6:	4608      	mov	r0, r1
6000a9e8:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
6000a9ea:	461a      	mov	r2, r3
{
6000a9ec:	b508      	push	{r3, lr}
	entry(p1, p2, p3);
6000a9ee:	47a0      	blx	r4
	return z_impl_z_current_get();
6000a9f0:	f7ff fb7c 	bl	6000a0ec <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
6000a9f4:	f7fa faa6 	bl	60004f44 <z_impl_k_thread_abort>

6000a9f8 <encode_uint>:
{
6000a9f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
6000a9fc:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
6000a9fe:	78d3      	ldrb	r3, [r2, #3]
{
6000aa00:	4680      	mov	r8, r0
6000aa02:	460f      	mov	r7, r1
	switch (specifier) {
6000aa04:	2b6f      	cmp	r3, #111	; 0x6f
{
6000aa06:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
6000aa08:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
6000aa0c:	d029      	beq.n	6000aa62 <encode_uint+0x6a>
6000aa0e:	d824      	bhi.n	6000aa5a <encode_uint+0x62>
		return 10;
6000aa10:	2b58      	cmp	r3, #88	; 0x58
6000aa12:	bf0c      	ite	eq
6000aa14:	2610      	moveq	r6, #16
6000aa16:	260a      	movne	r6, #10
	char *bp = bps + (bpe - bps);
6000aa18:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
6000aa1c:	4632      	mov	r2, r6
6000aa1e:	2300      	movs	r3, #0
6000aa20:	4640      	mov	r0, r8
6000aa22:	4639      	mov	r1, r7
6000aa24:	f7f9 f828 	bl	60003a78 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
6000aa28:	2a09      	cmp	r2, #9
6000aa2a:	b2d4      	uxtb	r4, r2
6000aa2c:	d81e      	bhi.n	6000aa6c <encode_uint+0x74>
6000aa2e:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
6000aa30:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
6000aa32:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
6000aa34:	f177 0700 	sbcs.w	r7, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
6000aa38:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
6000aa3c:	d301      	bcc.n	6000aa42 <encode_uint+0x4a>
6000aa3e:	45d1      	cmp	r9, sl
6000aa40:	d811      	bhi.n	6000aa66 <encode_uint+0x6e>
	if (conv->flag_hash) {
6000aa42:	782b      	ldrb	r3, [r5, #0]
6000aa44:	069b      	lsls	r3, r3, #26
6000aa46:	d505      	bpl.n	6000aa54 <encode_uint+0x5c>
		if (radix == 8) {
6000aa48:	2e08      	cmp	r6, #8
6000aa4a:	d115      	bne.n	6000aa78 <encode_uint+0x80>
			conv->altform_0 = true;
6000aa4c:	78ab      	ldrb	r3, [r5, #2]
6000aa4e:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
6000aa52:	70ab      	strb	r3, [r5, #2]
}
6000aa54:	4648      	mov	r0, r9
6000aa56:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
6000aa5a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 10;
6000aa5e:	2b70      	cmp	r3, #112	; 0x70
6000aa60:	e7d7      	b.n	6000aa12 <encode_uint+0x1a>
	switch (specifier) {
6000aa62:	2608      	movs	r6, #8
6000aa64:	e7d8      	b.n	6000aa18 <encode_uint+0x20>
		value /= radix;
6000aa66:	4680      	mov	r8, r0
6000aa68:	460f      	mov	r7, r1
6000aa6a:	e7d7      	b.n	6000aa1c <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
6000aa6c:	f1bb 0f19 	cmp.w	fp, #25
6000aa70:	bf94      	ite	ls
6000aa72:	3437      	addls	r4, #55	; 0x37
6000aa74:	3457      	addhi	r4, #87	; 0x57
6000aa76:	e7db      	b.n	6000aa30 <encode_uint+0x38>
		} else if (radix == 16) {
6000aa78:	2e10      	cmp	r6, #16
6000aa7a:	d1eb      	bne.n	6000aa54 <encode_uint+0x5c>
			conv->altform_0c = true;
6000aa7c:	78ab      	ldrb	r3, [r5, #2]
6000aa7e:	f043 0310 	orr.w	r3, r3, #16
6000aa82:	e7e6      	b.n	6000aa52 <encode_uint+0x5a>

6000aa84 <outs>:
{
6000aa84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
6000aa88:	4607      	mov	r7, r0
6000aa8a:	4688      	mov	r8, r1
6000aa8c:	4615      	mov	r5, r2
6000aa8e:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
6000aa90:	4614      	mov	r4, r2
6000aa92:	42b4      	cmp	r4, r6
6000aa94:	d305      	bcc.n	6000aaa2 <outs+0x1e>
6000aa96:	b10e      	cbz	r6, 6000aa9c <outs+0x18>
	return (int)count;
6000aa98:	1b60      	subs	r0, r4, r5
6000aa9a:	e008      	b.n	6000aaae <outs+0x2a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
6000aa9c:	7823      	ldrb	r3, [r4, #0]
6000aa9e:	2b00      	cmp	r3, #0
6000aaa0:	d0fa      	beq.n	6000aa98 <outs+0x14>
		int rc = out((int)*sp++, ctx);
6000aaa2:	4641      	mov	r1, r8
6000aaa4:	f814 0b01 	ldrb.w	r0, [r4], #1
6000aaa8:	47b8      	blx	r7
		if (rc < 0) {
6000aaaa:	2800      	cmp	r0, #0
6000aaac:	daf1      	bge.n	6000aa92 <outs+0xe>
}
6000aaae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

6000aab2 <assert_post_action>:
	if (k_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
6000aab2:	4040      	eors	r0, r0
6000aab4:	f380 8811 	msr	BASEPRI, r0
6000aab8:	f04f 0004 	mov.w	r0, #4
6000aabc:	df02      	svc	2
}
6000aabe:	4770      	bx	lr

6000aac0 <assert_print>:

void assert_print(const char *fmt, ...)
{
6000aac0:	b40f      	push	{r0, r1, r2, r3}
6000aac2:	b507      	push	{r0, r1, r2, lr}
6000aac4:	a904      	add	r1, sp, #16
6000aac6:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
6000aaca:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
6000aacc:	f7f9 f9de 	bl	60003e8c <vprintk>

	va_end(ap);
}
6000aad0:	b003      	add	sp, #12
6000aad2:	f85d eb04 	ldr.w	lr, [sp], #4
6000aad6:	b004      	add	sp, #16
6000aad8:	4770      	bx	lr

6000aada <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
6000aada:	4770      	bx	lr

6000aadc <z_arm_platform_init>:
		(&__ocram_data_end - &__ocram_data_start));
	/* Zero BSS region */
	memset(&__ocram_bss_start, 0, (&__ocram_bss_end - &__ocram_bss_start));
#endif
	/* Call CMSIS SystemInit */
	SystemInit();
6000aadc:	f7fc ba24 	b.w	60006f28 <SystemInit>

6000aae0 <z_log_minimal_printk>:
#include <zephyr/sys/printk.h>

#define HEXDUMP_BYTES_IN_LINE 8U

void z_log_minimal_printk(const char *fmt, ...)
{
6000aae0:	b40f      	push	{r0, r1, r2, r3}
6000aae2:	b507      	push	{r0, r1, r2, lr}
6000aae4:	a904      	add	r1, sp, #16
6000aae6:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
6000aaea:	9101      	str	r1, [sp, #4]
	vprintk(fmt, ap);
6000aaec:	f7f9 f9ce 	bl	60003e8c <vprintk>
	va_end(ap);
}
6000aaf0:	b003      	add	sp, #12
6000aaf2:	f85d eb04 	ldr.w	lr, [sp], #4
6000aaf6:	b004      	add	sp, #16
6000aaf8:	4770      	bx	lr

6000aafa <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
6000aafa:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
6000aafc:	6800      	ldr	r0, [r0, #0]
6000aafe:	f7f9 be3b 	b.w	60004778 <z_arm_fatal_error>

6000ab02 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
6000ab02:	2100      	movs	r1, #0
6000ab04:	2001      	movs	r0, #1
6000ab06:	f7f9 be37 	b.w	60004778 <z_arm_fatal_error>

6000ab0a <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
6000ab0a:	b508      	push	{r3, lr}
	handler();
6000ab0c:	f7f9 fea2 	bl	60004854 <z_SysNmiOnReset>
	z_arm_int_exit();
}
6000ab10:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
6000ab14:	f7f9 bf78 	b.w	60004a08 <z_arm_exc_exit>

6000ab18 <strncpy>:

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
6000ab18:	3901      	subs	r1, #1
6000ab1a:	4603      	mov	r3, r0
{
6000ab1c:	b510      	push	{r4, lr}
	while ((n > 0) && *s != '\0') {
6000ab1e:	b922      	cbnz	r2, 6000ab2a <strncpy+0x12>
6000ab20:	441a      	add	r2, r3
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
6000ab22:	2100      	movs	r1, #0
	while (n > 0) {
6000ab24:	4293      	cmp	r3, r2
6000ab26:	d108      	bne.n	6000ab3a <strncpy+0x22>
		d++;
		n--;
	}

	return dest;
}
6000ab28:	bd10      	pop	{r4, pc}
	while ((n > 0) && *s != '\0') {
6000ab2a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
6000ab2e:	2c00      	cmp	r4, #0
6000ab30:	d0f6      	beq.n	6000ab20 <strncpy+0x8>
		n--;
6000ab32:	3a01      	subs	r2, #1
		*d = *s;
6000ab34:	f803 4b01 	strb.w	r4, [r3], #1
		n--;
6000ab38:	e7f1      	b.n	6000ab1e <strncpy+0x6>
		*d = '\0';
6000ab3a:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
6000ab3e:	e7f1      	b.n	6000ab24 <strncpy+0xc>

6000ab40 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
6000ab40:	4603      	mov	r3, r0
	size_t n = 0;
6000ab42:	2000      	movs	r0, #0

	while (*s != '\0') {
6000ab44:	5c1a      	ldrb	r2, [r3, r0]
6000ab46:	b902      	cbnz	r2, 6000ab4a <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
6000ab48:	4770      	bx	lr
		n++;
6000ab4a:	3001      	adds	r0, #1
6000ab4c:	e7fa      	b.n	6000ab44 <strlen+0x4>

6000ab4e <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
6000ab4e:	4603      	mov	r3, r0
	size_t n = 0;
6000ab50:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
6000ab52:	5c1a      	ldrb	r2, [r3, r0]
6000ab54:	b10a      	cbz	r2, 6000ab5a <strnlen+0xc>
6000ab56:	4288      	cmp	r0, r1
6000ab58:	d100      	bne.n	6000ab5c <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
6000ab5a:	4770      	bx	lr
		n++;
6000ab5c:	3001      	adds	r0, #1
6000ab5e:	e7f8      	b.n	6000ab52 <strnlen+0x4>

6000ab60 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
6000ab60:	1e43      	subs	r3, r0, #1
6000ab62:	3901      	subs	r1, #1
6000ab64:	f813 2f01 	ldrb.w	r2, [r3, #1]!
6000ab68:	f811 0f01 	ldrb.w	r0, [r1, #1]!
6000ab6c:	4282      	cmp	r2, r0
6000ab6e:	d101      	bne.n	6000ab74 <strcmp+0x14>
6000ab70:	2a00      	cmp	r2, #0
6000ab72:	d1f7      	bne.n	6000ab64 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
6000ab74:	1a10      	subs	r0, r2, r0
6000ab76:	4770      	bx	lr

6000ab78 <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
6000ab78:	1e43      	subs	r3, r0, #1
6000ab7a:	440a      	add	r2, r1
{
6000ab7c:	b510      	push	{r4, lr}
	while (n > 0) {
6000ab7e:	4291      	cmp	r1, r2
6000ab80:	d100      	bne.n	6000ab84 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
6000ab82:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
6000ab84:	f811 4b01 	ldrb.w	r4, [r1], #1
6000ab88:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
6000ab8c:	e7f7      	b.n	6000ab7e <memcpy+0x6>

6000ab8e <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
6000ab8e:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
6000ab90:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
6000ab92:	4603      	mov	r3, r0
	while (n > 0) {
6000ab94:	4293      	cmp	r3, r2
6000ab96:	d100      	bne.n	6000ab9a <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
6000ab98:	4770      	bx	lr
		*(d_byte++) = c_byte;
6000ab9a:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
6000ab9e:	e7f9      	b.n	6000ab94 <memset+0x6>

6000aba0 <_stdout_hook_default>:
}
6000aba0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
6000aba4:	4770      	bx	lr

6000aba6 <test_main>:
{
6000aba6:	b508      	push	{r3, lr}
	ztest_run_all(NULL);
6000aba8:	2000      	movs	r0, #0
6000abaa:	f7fa fdaf 	bl	6000570c <ztest_run_all>
}
6000abae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	ztest_verify_all_test_suites_ran();
6000abb2:	f7fa bd55 	b.w	60005660 <ztest_verify_all_test_suites_ran>

6000abb6 <z_ztest_should_suite_run>:
 */
bool z_ztest_should_suite_run(const void *state, struct ztest_suite_node *suite)
{
	bool run_suite = true;

	if (suite->predicate != NULL) {
6000abb6:	694b      	ldr	r3, [r1, #20]
6000abb8:	b103      	cbz	r3, 6000abbc <z_ztest_should_suite_run+0x6>
		run_suite = suite->predicate(state);
6000abba:	4718      	bx	r3
	}

	return run_suite;
}
6000abbc:	2001      	movs	r0, #1
6000abbe:	4770      	bx	lr

6000abc0 <z_ztest_should_test_run>:
 * @return false
 */
bool z_ztest_should_test_run(const char *suite, const char *test)
{
	return true;
}
6000abc0:	2001      	movs	r0, #1
6000abc2:	4770      	bx	lr

6000abc4 <z_ztest_run_all>:
		union { uintptr_t x; const void * val; } parm0 = { .val = state };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_ZTEST_RUN_TEST_SUITES);
	}
#endif
	compiler_barrier();
	return z_impl_ztest_run_test_suites(state);
6000abc4:	f7fa bcf4 	b.w	600055b0 <z_impl_ztest_run_test_suites>

6000abc8 <mcux_ccm_on>:
}
6000abc8:	2000      	movs	r0, #0
6000abca:	4770      	bx	lr

6000abcc <mcux_ccm_init>:

static int mcux_ccm_init(const struct device *dev)
{
	return 0;
}
6000abcc:	2000      	movs	r0, #0
6000abce:	4770      	bx	lr

6000abd0 <mcux_ccm_off>:
static int mcux_ccm_off(const struct device *dev,
6000abd0:	2000      	movs	r0, #0
6000abd2:	4770      	bx	lr

6000abd4 <nxp_edma_callback>:
{
6000abd4:	4613      	mov	r3, r2
6000abd6:	b430      	push	{r4, r5}
6000abd8:	460c      	mov	r4, r1
	uint32_t channel = handle->channel;
6000abda:	7c02      	ldrb	r2, [r0, #16]
	if (transferDone) {
6000abdc:	b183      	cbz	r3, 6000ac00 <nxp_edma_callback+0x2c>
		data->busy = (handle->tcdPool != NULL) && (handle->tcdUsed > 0);
6000abde:	68c3      	ldr	r3, [r0, #12]
6000abe0:	b12b      	cbz	r3, 6000abee <nxp_edma_callback+0x1a>
6000abe2:	7cc3      	ldrb	r3, [r0, #19]
6000abe4:	b25b      	sxtb	r3, r3
6000abe6:	2b00      	cmp	r3, #0
6000abe8:	bfd4      	ite	le
6000abea:	2300      	movle	r3, #0
6000abec:	2301      	movgt	r3, #1
6000abee:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
		ret = 0;
6000abf2:	2300      	movs	r3, #0
	data->dma_callback(data->dev, data->user_data, channel, ret);
6000abf4:	6b20      	ldr	r0, [r4, #48]	; 0x30
6000abf6:	e9d4 150d 	ldrd	r1, r5, [r4, #52]	; 0x34
6000abfa:	46ac      	mov	ip, r5
}
6000abfc:	bc30      	pop	{r4, r5}
	data->dma_callback(data->dev, data->user_data, channel, ret);
6000abfe:	4760      	bx	ip
	int ret = 1;
6000ac00:	2301      	movs	r3, #1
6000ac02:	e7f7      	b.n	6000abf4 <nxp_edma_callback+0x20>

6000ac04 <dma_mcux_edma_channel_filter>:
	if (filter && *filter == DMA_CHANNEL_PERIODIC) {
6000ac04:	b13a      	cbz	r2, 6000ac16 <dma_mcux_edma_channel_filter+0x12>
6000ac06:	7813      	ldrb	r3, [r2, #0]
6000ac08:	2b01      	cmp	r3, #1
6000ac0a:	d104      	bne.n	6000ac16 <dma_mcux_edma_channel_filter+0x12>
		if (channel_id > 3) {
6000ac0c:	2903      	cmp	r1, #3
6000ac0e:	bfcc      	ite	gt
6000ac10:	2000      	movgt	r0, #0
6000ac12:	2001      	movle	r0, #1
6000ac14:	4770      	bx	lr
	return true;
6000ac16:	2001      	movs	r0, #1
}
6000ac18:	4770      	bx	lr

6000ac1a <dma_mcux_edma_get_status>:
{
6000ac1a:	b570      	push	{r4, r5, r6, lr}
6000ac1c:	4614      	mov	r4, r2
	if (DEV_CHANNEL_DATA(dev, channel)->busy) {
6000ac1e:	6903      	ldr	r3, [r0, #16]
6000ac20:	2254      	movs	r2, #84	; 0x54
{
6000ac22:	4605      	mov	r5, r0
6000ac24:	460e      	mov	r6, r1
	if (DEV_CHANNEL_DATA(dev, channel)->busy) {
6000ac26:	fb02 3301 	mla	r3, r2, r1, r3
6000ac2a:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
6000ac2e:	b183      	cbz	r3, 6000ac52 <dma_mcux_edma_get_status+0x38>
		status->busy = true;
6000ac30:	2301      	movs	r3, #1
6000ac32:	7023      	strb	r3, [r4, #0]
			EDMA_GetRemainingMajorLoopCount(DEV_BASE(dev), channel);
6000ac34:	6843      	ldr	r3, [r0, #4]
6000ac36:	6818      	ldr	r0, [r3, #0]
6000ac38:	f7fc fcae 	bl	60007598 <EDMA_GetRemainingMajorLoopCount>
6000ac3c:	4603      	mov	r3, r0
		status->pending_length =
6000ac3e:	6063      	str	r3, [r4, #4]
	status->dir = DEV_CHANNEL_DATA(dev, channel)->transfer_settings.direction;
6000ac40:	2254      	movs	r2, #84	; 0x54
6000ac42:	692b      	ldr	r3, [r5, #16]
}
6000ac44:	2000      	movs	r0, #0
	status->dir = DEV_CHANNEL_DATA(dev, channel)->transfer_settings.direction;
6000ac46:	fb02 3306 	mla	r3, r2, r6, r3
6000ac4a:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
6000ac4e:	7063      	strb	r3, [r4, #1]
}
6000ac50:	bd70      	pop	{r4, r5, r6, pc}
		status->busy = false;
6000ac52:	7023      	strb	r3, [r4, #0]
		status->pending_length = 0;
6000ac54:	e7f3      	b.n	6000ac3e <dma_mcux_edma_get_status+0x24>

6000ac56 <dma_mcux_edma_resume>:
{
6000ac56:	b508      	push	{r3, lr}
	if (!data->busy) {
6000ac58:	2354      	movs	r3, #84	; 0x54
	struct call_back *data = DEV_CHANNEL_DATA(dev, channel);
6000ac5a:	6900      	ldr	r0, [r0, #16]
	if (!data->busy) {
6000ac5c:	4359      	muls	r1, r3
6000ac5e:	1843      	adds	r3, r0, r1
6000ac60:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
6000ac64:	b12b      	cbz	r3, 6000ac72 <dma_mcux_edma_resume+0x1c>
	EDMA_StartTransfer(DEV_EDMA_HANDLE(dev, channel));
6000ac66:	3124      	adds	r1, #36	; 0x24
6000ac68:	4408      	add	r0, r1
6000ac6a:	f7fc ff89 	bl	60007b80 <EDMA_StartTransfer>
	return 0;
6000ac6e:	2000      	movs	r0, #0
}
6000ac70:	bd08      	pop	{r3, pc}
		return -EINVAL;
6000ac72:	f06f 0015 	mvn.w	r0, #21
6000ac76:	e7fb      	b.n	6000ac70 <dma_mcux_edma_resume+0x1a>

6000ac78 <dma_mcux_edma_start>:
	data->busy = true;
6000ac78:	2254      	movs	r2, #84	; 0x54
{
6000ac7a:	b508      	push	{r3, lr}
	data->busy = true;
6000ac7c:	4351      	muls	r1, r2
	struct call_back *data = DEV_CHANNEL_DATA(dev, channel);
6000ac7e:	6903      	ldr	r3, [r0, #16]
	data->busy = true;
6000ac80:	2201      	movs	r2, #1
6000ac82:	440b      	add	r3, r1
	EDMA_StartTransfer(DEV_EDMA_HANDLE(dev, channel));
6000ac84:	3124      	adds	r1, #36	; 0x24
	data->busy = true;
6000ac86:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
	EDMA_StartTransfer(DEV_EDMA_HANDLE(dev, channel));
6000ac8a:	6900      	ldr	r0, [r0, #16]
6000ac8c:	4408      	add	r0, r1
6000ac8e:	f7fc ff77 	bl	60007b80 <EDMA_StartTransfer>
}
6000ac92:	2000      	movs	r0, #0
6000ac94:	bd08      	pop	{r3, pc}

6000ac96 <dma_mcux_edma_suspend>:
{
6000ac96:	b508      	push	{r3, lr}
	if (!data->busy) {
6000ac98:	2354      	movs	r3, #84	; 0x54
	struct call_back *data = DEV_CHANNEL_DATA(dev, channel);
6000ac9a:	6900      	ldr	r0, [r0, #16]
	if (!data->busy) {
6000ac9c:	4359      	muls	r1, r3
6000ac9e:	1843      	adds	r3, r0, r1
6000aca0:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
6000aca4:	b12b      	cbz	r3, 6000acb2 <dma_mcux_edma_suspend+0x1c>
	EDMA_StopTransfer(DEV_EDMA_HANDLE(dev, channel));
6000aca6:	3124      	adds	r1, #36	; 0x24
6000aca8:	4408      	add	r0, r1
6000acaa:	f7fc ffa5 	bl	60007bf8 <EDMA_StopTransfer>
	return 0;
6000acae:	2000      	movs	r0, #0
}
6000acb0:	bd08      	pop	{r3, pc}
		return -EINVAL;
6000acb2:	f06f 0015 	mvn.w	r0, #21
6000acb6:	e7fb      	b.n	6000acb0 <dma_mcux_edma_suspend+0x1a>

6000acb8 <dma_mcux_edma_stop>:
{
6000acb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000acba:	4604      	mov	r4, r0
	struct dma_mcux_edma_data *data = DEV_DATA(dev);
6000acbc:	6905      	ldr	r5, [r0, #16]
	data->data_cb[channel].transfer_settings.valid = false;
6000acbe:	2054      	movs	r0, #84	; 0x54
6000acc0:	2700      	movs	r7, #0
{
6000acc2:	460e      	mov	r6, r1
	data->data_cb[channel].transfer_settings.valid = false;
6000acc4:	4348      	muls	r0, r1
6000acc6:	4405      	add	r5, r0
	if (!data->data_cb[channel].busy) {
6000acc8:	f895 305c 	ldrb.w	r3, [r5, #92]	; 0x5c
	data->data_cb[channel].transfer_settings.valid = false;
6000accc:	f885 705a 	strb.w	r7, [r5, #90]	; 0x5a
	if (!data->data_cb[channel].busy) {
6000acd0:	b18b      	cbz	r3, 6000acf6 <dma_mcux_edma_stop+0x3e>
	EDMA_AbortTransfer(DEV_EDMA_HANDLE(dev, channel));
6000acd2:	6923      	ldr	r3, [r4, #16]
6000acd4:	3024      	adds	r0, #36	; 0x24
6000acd6:	4418      	add	r0, r3
6000acd8:	f000 fbaa 	bl	6000b430 <EDMA_AbortTransfer>
	EDMA_ClearChannelStatusFlags(DEV_BASE(dev), channel,
6000acdc:	6863      	ldr	r3, [r4, #4]
6000acde:	2207      	movs	r2, #7
6000ace0:	4631      	mov	r1, r6
6000ace2:	6818      	ldr	r0, [r3, #0]
6000ace4:	f7fc fcac 	bl	60007640 <EDMA_ClearChannelStatusFlags>
	EDMA_ResetChannel(DEV_BASE(dev), channel);
6000ace8:	6863      	ldr	r3, [r4, #4]
6000acea:	4631      	mov	r1, r6
6000acec:	6818      	ldr	r0, [r3, #0]
6000acee:	f7fc fae3 	bl	600072b8 <EDMA_ResetChannel>
	data->data_cb[channel].busy = false;
6000acf2:	f885 705c 	strb.w	r7, [r5, #92]	; 0x5c
}
6000acf6:	2000      	movs	r0, #0
6000acf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

6000acfa <dma_imx_config_func_0>:
			      PRE_KERNEL_1, CONFIG_DMA_INIT_PRIORITY,   \
			      &dma_mcux_edma_api);		       \
								       \
	DMA_MCUX_EDMA_CONFIG_FUNC(n);

DT_INST_FOREACH_STATUS_OKAY(DMA_INIT)
6000acfa:	2200      	movs	r2, #0
6000acfc:	b508      	push	{r3, lr}
6000acfe:	4611      	mov	r1, r2
6000ad00:	4610      	mov	r0, r2
6000ad02:	f7f9 fd75 	bl	600047f0 <z_arm_irq_priority_set>
6000ad06:	2000      	movs	r0, #0
6000ad08:	f7f9 fd64 	bl	600047d4 <arch_irq_enable>
6000ad0c:	2200      	movs	r2, #0
6000ad0e:	2001      	movs	r0, #1
6000ad10:	4611      	mov	r1, r2
6000ad12:	f7f9 fd6d 	bl	600047f0 <z_arm_irq_priority_set>
6000ad16:	2001      	movs	r0, #1
6000ad18:	f7f9 fd5c 	bl	600047d4 <arch_irq_enable>
6000ad1c:	2200      	movs	r2, #0
6000ad1e:	2002      	movs	r0, #2
6000ad20:	4611      	mov	r1, r2
6000ad22:	f7f9 fd65 	bl	600047f0 <z_arm_irq_priority_set>
6000ad26:	2002      	movs	r0, #2
6000ad28:	f7f9 fd54 	bl	600047d4 <arch_irq_enable>
6000ad2c:	2200      	movs	r2, #0
6000ad2e:	2003      	movs	r0, #3
6000ad30:	4611      	mov	r1, r2
6000ad32:	f7f9 fd5d 	bl	600047f0 <z_arm_irq_priority_set>
6000ad36:	2003      	movs	r0, #3
6000ad38:	f7f9 fd4c 	bl	600047d4 <arch_irq_enable>
6000ad3c:	2200      	movs	r2, #0
6000ad3e:	2004      	movs	r0, #4
6000ad40:	4611      	mov	r1, r2
6000ad42:	f7f9 fd55 	bl	600047f0 <z_arm_irq_priority_set>
6000ad46:	2004      	movs	r0, #4
6000ad48:	f7f9 fd44 	bl	600047d4 <arch_irq_enable>
6000ad4c:	2200      	movs	r2, #0
6000ad4e:	2005      	movs	r0, #5
6000ad50:	4611      	mov	r1, r2
6000ad52:	f7f9 fd4d 	bl	600047f0 <z_arm_irq_priority_set>
6000ad56:	2005      	movs	r0, #5
6000ad58:	f7f9 fd3c 	bl	600047d4 <arch_irq_enable>
6000ad5c:	2200      	movs	r2, #0
6000ad5e:	2006      	movs	r0, #6
6000ad60:	4611      	mov	r1, r2
6000ad62:	f7f9 fd45 	bl	600047f0 <z_arm_irq_priority_set>
6000ad66:	2006      	movs	r0, #6
6000ad68:	f7f9 fd34 	bl	600047d4 <arch_irq_enable>
6000ad6c:	2200      	movs	r2, #0
6000ad6e:	2007      	movs	r0, #7
6000ad70:	4611      	mov	r1, r2
6000ad72:	f7f9 fd3d 	bl	600047f0 <z_arm_irq_priority_set>
6000ad76:	2007      	movs	r0, #7
6000ad78:	f7f9 fd2c 	bl	600047d4 <arch_irq_enable>
6000ad7c:	2200      	movs	r2, #0
6000ad7e:	2008      	movs	r0, #8
6000ad80:	4611      	mov	r1, r2
6000ad82:	f7f9 fd35 	bl	600047f0 <z_arm_irq_priority_set>
6000ad86:	2008      	movs	r0, #8
6000ad88:	f7f9 fd24 	bl	600047d4 <arch_irq_enable>
6000ad8c:	2200      	movs	r2, #0
6000ad8e:	2009      	movs	r0, #9
6000ad90:	4611      	mov	r1, r2
6000ad92:	f7f9 fd2d 	bl	600047f0 <z_arm_irq_priority_set>
6000ad96:	2009      	movs	r0, #9
6000ad98:	f7f9 fd1c 	bl	600047d4 <arch_irq_enable>
6000ad9c:	2200      	movs	r2, #0
6000ad9e:	200a      	movs	r0, #10
6000ada0:	4611      	mov	r1, r2
6000ada2:	f7f9 fd25 	bl	600047f0 <z_arm_irq_priority_set>
6000ada6:	200a      	movs	r0, #10
6000ada8:	f7f9 fd14 	bl	600047d4 <arch_irq_enable>
6000adac:	2200      	movs	r2, #0
6000adae:	200b      	movs	r0, #11
6000adb0:	4611      	mov	r1, r2
6000adb2:	f7f9 fd1d 	bl	600047f0 <z_arm_irq_priority_set>
6000adb6:	200b      	movs	r0, #11
6000adb8:	f7f9 fd0c 	bl	600047d4 <arch_irq_enable>
6000adbc:	2200      	movs	r2, #0
6000adbe:	200c      	movs	r0, #12
6000adc0:	4611      	mov	r1, r2
6000adc2:	f7f9 fd15 	bl	600047f0 <z_arm_irq_priority_set>
6000adc6:	200c      	movs	r0, #12
6000adc8:	f7f9 fd04 	bl	600047d4 <arch_irq_enable>
6000adcc:	2200      	movs	r2, #0
6000adce:	200d      	movs	r0, #13
6000add0:	4611      	mov	r1, r2
6000add2:	f7f9 fd0d 	bl	600047f0 <z_arm_irq_priority_set>
6000add6:	200d      	movs	r0, #13
6000add8:	f7f9 fcfc 	bl	600047d4 <arch_irq_enable>
6000addc:	2200      	movs	r2, #0
6000adde:	200e      	movs	r0, #14
6000ade0:	4611      	mov	r1, r2
6000ade2:	f7f9 fd05 	bl	600047f0 <z_arm_irq_priority_set>
6000ade6:	200e      	movs	r0, #14
6000ade8:	f7f9 fcf4 	bl	600047d4 <arch_irq_enable>
6000adec:	2200      	movs	r2, #0
6000adee:	200f      	movs	r0, #15
6000adf0:	4611      	mov	r1, r2
6000adf2:	f7f9 fcfd 	bl	600047f0 <z_arm_irq_priority_set>
6000adf6:	200f      	movs	r0, #15
6000adf8:	f7f9 fcec 	bl	600047d4 <arch_irq_enable>
6000adfc:	2200      	movs	r2, #0
6000adfe:	2010      	movs	r0, #16
6000ae00:	4611      	mov	r1, r2
6000ae02:	f7f9 fcf5 	bl	600047f0 <z_arm_irq_priority_set>
6000ae06:	2010      	movs	r0, #16
6000ae08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
6000ae0c:	f7f9 bce2 	b.w	600047d4 <arch_irq_enable>

6000ae10 <dma_mcux_edma_irq_handler>:
{
6000ae10:	b570      	push	{r4, r5, r6, lr}
6000ae12:	4605      	mov	r5, r0
	for (i = 0; i < DT_INST_PROP(0, dma_channels); i++) {
6000ae14:	2400      	movs	r4, #0
			EDMA_HandleIRQ(DEV_EDMA_HANDLE(dev, i));
6000ae16:	2654      	movs	r6, #84	; 0x54
		uint32_t flag = EDMA_GetChannelStatusFlags(DEV_BASE(dev), i);
6000ae18:	686b      	ldr	r3, [r5, #4]
6000ae1a:	4621      	mov	r1, r4
6000ae1c:	6818      	ldr	r0, [r3, #0]
6000ae1e:	f7fc fbe5 	bl	600075ec <EDMA_GetChannelStatusFlags>
		if ((flag & (uint32_t)kEDMA_InterruptFlag) != 0U) {
6000ae22:	0743      	lsls	r3, r0, #29
6000ae24:	d506      	bpl.n	6000ae34 <dma_mcux_edma_irq_handler+0x24>
			EDMA_HandleIRQ(DEV_EDMA_HANDLE(dev, i));
6000ae26:	fb06 f304 	mul.w	r3, r6, r4
6000ae2a:	6928      	ldr	r0, [r5, #16]
6000ae2c:	3324      	adds	r3, #36	; 0x24
6000ae2e:	4418      	add	r0, r3
6000ae30:	f7fc ff00 	bl	60007c34 <EDMA_HandleIRQ>
	for (i = 0; i < DT_INST_PROP(0, dma_channels); i++) {
6000ae34:	3401      	adds	r4, #1
6000ae36:	2c20      	cmp	r4, #32
6000ae38:	d1ee      	bne.n	6000ae18 <dma_mcux_edma_irq_handler+0x8>
}
6000ae3a:	bd70      	pop	{r4, r5, r6, pc}

6000ae3c <mcux_igpio_port_get_raw>:
	GPIO_Type *base = config->base;
6000ae3c:	6843      	ldr	r3, [r0, #4]
}
6000ae3e:	2000      	movs	r0, #0
	GPIO_Type *base = config->base;
6000ae40:	685b      	ldr	r3, [r3, #4]
	*value = base->DR;
6000ae42:	681b      	ldr	r3, [r3, #0]
6000ae44:	600b      	str	r3, [r1, #0]
}
6000ae46:	4770      	bx	lr

6000ae48 <mcux_igpio_port_set_masked_raw>:
	GPIO_Type *base = config->base;
6000ae48:	6843      	ldr	r3, [r0, #4]
6000ae4a:	685b      	ldr	r3, [r3, #4]
	base->DR = (base->DR & ~mask) | (mask & value);
6000ae4c:	6818      	ldr	r0, [r3, #0]
6000ae4e:	4042      	eors	r2, r0
6000ae50:	400a      	ands	r2, r1
6000ae52:	4042      	eors	r2, r0
}
6000ae54:	2000      	movs	r0, #0
	base->DR = (base->DR & ~mask) | (mask & value);
6000ae56:	601a      	str	r2, [r3, #0]
}
6000ae58:	4770      	bx	lr

6000ae5a <mcux_igpio_port_set_bits_raw>:
	GPIO_Type *base = config->base;
6000ae5a:	6843      	ldr	r3, [r0, #4]
}
6000ae5c:	2000      	movs	r0, #0
	GPIO_Type *base = config->base;
6000ae5e:	685b      	ldr	r3, [r3, #4]
 * @param mask GPIO pin number macro
 */
static inline void GPIO_PortSet(GPIO_Type *base, uint32_t mask)
{
#if (defined(FSL_FEATURE_IGPIO_HAS_DR_SET) && (FSL_FEATURE_IGPIO_HAS_DR_SET == 1))
    base->DR_SET = mask;
6000ae60:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
}
6000ae64:	4770      	bx	lr

6000ae66 <mcux_igpio_port_clear_bits_raw>:
	GPIO_Type *base = config->base;
6000ae66:	6843      	ldr	r3, [r0, #4]
}
6000ae68:	2000      	movs	r0, #0
	GPIO_Type *base = config->base;
6000ae6a:	685b      	ldr	r3, [r3, #4]
 * @param mask GPIO pin number macro
 */
static inline void GPIO_PortClear(GPIO_Type *base, uint32_t mask)
{
#if (defined(FSL_FEATURE_IGPIO_HAS_DR_CLEAR) && (FSL_FEATURE_IGPIO_HAS_DR_CLEAR == 1))
    base->DR_CLEAR = mask;
6000ae6c:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
}
6000ae70:	4770      	bx	lr

6000ae72 <mcux_igpio_port_toggle_bits>:
	GPIO_Type *base = config->base;
6000ae72:	6843      	ldr	r3, [r0, #4]
}
6000ae74:	2000      	movs	r0, #0
	GPIO_Type *base = config->base;
6000ae76:	685b      	ldr	r3, [r3, #4]
 * @param mask GPIO pin number macro
 */
static inline void GPIO_PortToggle(GPIO_Type *base, uint32_t mask)
{
#if (defined(FSL_FEATURE_IGPIO_HAS_DR_TOGGLE) && (FSL_FEATURE_IGPIO_HAS_DR_TOGGLE == 1))
    base->DR_TOGGLE = mask;
6000ae78:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
}
6000ae7c:	4770      	bx	lr

6000ae7e <mcux_igpio_pin_interrupt_configure>:
{
6000ae7e:	b570      	push	{r4, r5, r6, lr}
	if (mode == GPIO_INT_MODE_DISABLED) {
6000ae80:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
	GPIO_Type *base = config->base;
6000ae84:	6840      	ldr	r0, [r0, #4]
6000ae86:	6840      	ldr	r0, [r0, #4]
	if (mode == GPIO_INT_MODE_DISABLED) {
6000ae88:	d113      	bne.n	6000aeb2 <mcux_igpio_pin_interrupt_configure+0x34>
	__asm__ volatile(
6000ae8a:	f04f 0310 	mov.w	r3, #16
6000ae8e:	f3ef 8411 	mrs	r4, BASEPRI
6000ae92:	f383 8812 	msr	BASEPRI_MAX, r3
6000ae96:	f3bf 8f6f 	isb	sy
		WRITE_BIT(base->IMR, pin, 0);
6000ae9a:	2201      	movs	r2, #1
6000ae9c:	6943      	ldr	r3, [r0, #20]
6000ae9e:	408a      	lsls	r2, r1
6000aea0:	ea23 0302 	bic.w	r3, r3, r2
	WRITE_BIT(base->IMR, pin, 1);
6000aea4:	6143      	str	r3, [r0, #20]
	__asm__ volatile(
6000aea6:	f384 8811 	msr	BASEPRI, r4
6000aeaa:	f3bf 8f6f 	isb	sy
		return 0;
6000aeae:	2000      	movs	r0, #0
}
6000aeb0:	bd70      	pop	{r4, r5, r6, pc}
	if ((mode == GPIO_INT_MODE_EDGE) && (trig == GPIO_INT_TRIG_LOW)) {
6000aeb2:	f1b2 7fa0 	cmp.w	r2, #20971520	; 0x1400000
6000aeb6:	d12b      	bne.n	6000af10 <mcux_igpio_pin_interrupt_configure+0x92>
6000aeb8:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
6000aebc:	d030      	beq.n	6000af20 <mcux_igpio_pin_interrupt_configure+0xa2>
	} else if ((mode == GPIO_INT_MODE_EDGE) &&
6000aebe:	f103 457c 	add.w	r5, r3, #4227858432	; 0xfc000000
6000aec2:	426a      	negs	r2, r5
6000aec4:	416a      	adcs	r2, r5
6000aec6:	0052      	lsls	r2, r2, #1
	if (pin < 16) {
6000aec8:	290f      	cmp	r1, #15
6000aeca:	d82d      	bhi.n	6000af28 <mcux_igpio_pin_interrupt_configure+0xaa>
		shift = 2 * pin;
6000aecc:	004d      	lsls	r5, r1, #1
		base->ICR1 = (base->ICR1 & ~(3 << shift)) | (icr << shift);
6000aece:	2603      	movs	r6, #3
6000aed0:	68c4      	ldr	r4, [r0, #12]
6000aed2:	40ae      	lsls	r6, r5
6000aed4:	fa02 f505 	lsl.w	r5, r2, r5
6000aed8:	ea24 0406 	bic.w	r4, r4, r6
6000aedc:	432c      	orrs	r4, r5
6000aede:	60c4      	str	r4, [r0, #12]
	__asm__ volatile(
6000aee0:	f04f 0210 	mov.w	r2, #16
6000aee4:	f3ef 8411 	mrs	r4, BASEPRI
6000aee8:	f382 8812 	msr	BASEPRI_MAX, r2
6000aeec:	f3bf 8f6f 	isb	sy
	WRITE_BIT(base->EDGE_SEL, pin, trig == GPIO_INT_TRIG_BOTH);
6000aef0:	2201      	movs	r2, #1
6000aef2:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
6000aef6:	69c3      	ldr	r3, [r0, #28]
6000aef8:	fa02 f201 	lsl.w	r2, r2, r1
6000aefc:	bf0c      	ite	eq
6000aefe:	4313      	orreq	r3, r2
6000af00:	4393      	bicne	r3, r2
6000af02:	61c3      	str	r3, [r0, #28]
	WRITE_BIT(base->ISR, pin, 1);
6000af04:	6983      	ldr	r3, [r0, #24]
6000af06:	4313      	orrs	r3, r2
6000af08:	6183      	str	r3, [r0, #24]
	WRITE_BIT(base->IMR, pin, 1);
6000af0a:	6943      	ldr	r3, [r0, #20]
6000af0c:	4313      	orrs	r3, r2
6000af0e:	e7c9      	b.n	6000aea4 <mcux_igpio_pin_interrupt_configure+0x26>
	} else if ((mode == GPIO_INT_MODE_LEVEL) &&
6000af10:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
6000af14:	d106      	bne.n	6000af24 <mcux_igpio_pin_interrupt_configure+0xa6>
6000af16:	f103 447c 	add.w	r4, r3, #4227858432	; 0xfc000000
6000af1a:	4262      	negs	r2, r4
6000af1c:	4162      	adcs	r2, r4
6000af1e:	e7d3      	b.n	6000aec8 <mcux_igpio_pin_interrupt_configure+0x4a>
		icr = 3;
6000af20:	2203      	movs	r2, #3
6000af22:	e7d1      	b.n	6000aec8 <mcux_igpio_pin_interrupt_configure+0x4a>
		icr = 0;
6000af24:	2200      	movs	r2, #0
6000af26:	e7cf      	b.n	6000aec8 <mcux_igpio_pin_interrupt_configure+0x4a>
	} else if (pin < 32) {
6000af28:	291f      	cmp	r1, #31
6000af2a:	d80b      	bhi.n	6000af44 <mcux_igpio_pin_interrupt_configure+0xc6>
		shift = 2 * (pin - 16);
6000af2c:	f1a1 0510 	sub.w	r5, r1, #16
		base->ICR2 = (base->ICR2 & ~(3 << shift)) | (icr << shift);
6000af30:	2603      	movs	r6, #3
6000af32:	6904      	ldr	r4, [r0, #16]
		shift = 2 * (pin - 16);
6000af34:	006d      	lsls	r5, r5, #1
		base->ICR2 = (base->ICR2 & ~(3 << shift)) | (icr << shift);
6000af36:	40ae      	lsls	r6, r5
6000af38:	40aa      	lsls	r2, r5
6000af3a:	ea24 0406 	bic.w	r4, r4, r6
6000af3e:	4322      	orrs	r2, r4
6000af40:	6102      	str	r2, [r0, #16]
6000af42:	e7cd      	b.n	6000aee0 <mcux_igpio_pin_interrupt_configure+0x62>
		return -EINVAL;
6000af44:	f06f 0015 	mvn.w	r0, #21
6000af48:	e7b2      	b.n	6000aeb0 <mcux_igpio_pin_interrupt_configure+0x32>

6000af4a <mcux_igpio_configure>:
{
6000af4a:	b5f0      	push	{r4, r5, r6, r7, lr}
	const struct mcux_igpio_config *config = dev->config;
6000af4c:	6843      	ldr	r3, [r0, #4]
{
6000af4e:	4615      	mov	r5, r2
6000af50:	b087      	sub	sp, #28
6000af52:	460e      	mov	r6, r1
	GPIO_Type *base = config->base;
6000af54:	685f      	ldr	r7, [r3, #4]
	int cfg_idx = pin, i;
6000af56:	4608      	mov	r0, r1
	for (i = 0; i < config->gap_count; i++) {
6000af58:	f893 c011 	ldrb.w	ip, [r3, #17]
6000af5c:	2200      	movs	r2, #0
6000af5e:	4594      	cmp	ip, r2
6000af60:	dc43      	bgt.n	6000afea <mcux_igpio_configure+0xa0>
	if (cfg_idx >= config->mux_count) {
6000af62:	7c1a      	ldrb	r2, [r3, #16]
6000af64:	4282      	cmp	r2, r0
6000af66:	dd4b      	ble.n	6000b000 <mcux_igpio_configure+0xb6>
		(volatile uint32_t *)config->pin_muxes[cfg_idx].config_register;
6000af68:	6899      	ldr	r1, [r3, #8]
6000af6a:	2314      	movs	r3, #20
6000af6c:	fb03 1100 	mla	r1, r3, r0, r1
	if ((flags & GPIO_SINGLE_ENDED) != 0) {
6000af70:	07a8      	lsls	r0, r5, #30
	volatile uint32_t *gpio_cfg_reg =
6000af72:	684b      	ldr	r3, [r1, #4]
	uint32_t reg = *gpio_cfg_reg;
6000af74:	681b      	ldr	r3, [r3, #0]
		reg |= IOMUXC_SW_PAD_CTL_PAD_ODE_MASK;
6000af76:	bf4c      	ite	mi
6000af78:	f443 6300 	orrmi.w	r3, r3, #2048	; 0x800
		reg &= ~IOMUXC_SW_PAD_CTL_PAD_ODE_MASK;
6000af7c:	f423 6300 	bicpl.w	r3, r3, #2048	; 0x800
	if (((flags & GPIO_PULL_UP) != 0) || ((flags & GPIO_PULL_DOWN) != 0)) {
6000af80:	f015 0f30 	tst.w	r5, #48	; 0x30
6000af84:	d043      	beq.n	6000b00e <mcux_igpio_configure+0xc4>
		if (((flags & GPIO_PULL_UP) != 0)) {
6000af86:	06ea      	lsls	r2, r5, #27
			reg |= IOMUXC_SW_PAD_CTL_PAD_PUS(2);
6000af88:	bf56      	itet	pl
6000af8a:	f423 4340 	bicpl.w	r3, r3, #49152	; 0xc000
6000af8e:	f443 4420 	orrmi.w	r4, r3, #40960	; 0xa000
			reg &= ~IOMUXC_SW_PAD_CTL_PAD_PUS_MASK;
6000af92:	f443 5400 	orrpl.w	r4, r3, #8192	; 0x2000
	memcpy(&pin_cfg.pinmux, &config->pin_muxes[cfg_idx], sizeof(pin_cfg));
6000af96:	2218      	movs	r2, #24
6000af98:	4668      	mov	r0, sp
6000af9a:	f7ff fded 	bl	6000ab78 <memcpy>
	pinctrl_configure_pins(&pin_cfg, 1, PINCTRL_REG_NONE);
6000af9e:	2200      	movs	r2, #0
6000afa0:	2101      	movs	r1, #1
6000afa2:	4668      	mov	r0, sp
	pin_cfg.pin_ctrl_flags = reg;
6000afa4:	9405      	str	r4, [sp, #20]
	pinctrl_configure_pins(&pin_cfg, 1, PINCTRL_REG_NONE);
6000afa6:	f000 f894 	bl	6000b0d2 <pinctrl_configure_pins>
	if (((flags & GPIO_INPUT) != 0) && ((flags & GPIO_OUTPUT) != 0)) {
6000afaa:	f405 3340 	and.w	r3, r5, #196608	; 0x30000
6000afae:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
6000afb2:	d025      	beq.n	6000b000 <mcux_igpio_configure+0xb6>
	if (flags & GPIO_OUTPUT_INIT_HIGH) {
6000afb4:	032c      	lsls	r4, r5, #12
6000afb6:	d504      	bpl.n	6000afc2 <mcux_igpio_configure+0x78>
    GPIO_PinWrite(base, pin, output);
6000afb8:	2201      	movs	r2, #1
6000afba:	4631      	mov	r1, r6
6000afbc:	4638      	mov	r0, r7
6000afbe:	f7fd fdc3 	bl	60008b48 <GPIO_PinWrite>
	if (flags & GPIO_OUTPUT_INIT_LOW) {
6000afc2:	0368      	lsls	r0, r5, #13
6000afc4:	d504      	bpl.n	6000afd0 <mcux_igpio_configure+0x86>
6000afc6:	2200      	movs	r2, #0
6000afc8:	4631      	mov	r1, r6
6000afca:	4638      	mov	r0, r7
6000afcc:	f7fd fdbc 	bl	60008b48 <GPIO_PinWrite>
	WRITE_BIT(base->GDIR, pin, flags & GPIO_OUTPUT);
6000afd0:	2301      	movs	r3, #1
6000afd2:	687a      	ldr	r2, [r7, #4]
6000afd4:	03a9      	lsls	r1, r5, #14
	return 0;
6000afd6:	f04f 0000 	mov.w	r0, #0
	WRITE_BIT(base->GDIR, pin, flags & GPIO_OUTPUT);
6000afda:	fa03 f306 	lsl.w	r3, r3, r6
6000afde:	bf4c      	ite	mi
6000afe0:	4313      	orrmi	r3, r2
6000afe2:	ea22 0303 	bicpl.w	r3, r2, r3
6000afe6:	607b      	str	r3, [r7, #4]
	return 0;
6000afe8:	e00c      	b.n	6000b004 <mcux_igpio_configure+0xba>
		if (pin >= config->pin_gaps[i].start) {
6000afea:	68d9      	ldr	r1, [r3, #12]
6000afec:	eb01 0442 	add.w	r4, r1, r2, lsl #1
6000aff0:	f811 1012 	ldrb.w	r1, [r1, r2, lsl #1]
6000aff4:	42b1      	cmp	r1, r6
6000aff6:	d808      	bhi.n	6000b00a <mcux_igpio_configure+0xc0>
				config->pin_gaps[i].len)) {
6000aff8:	7864      	ldrb	r4, [r4, #1]
			if (pin < (config->pin_gaps[i].start +
6000affa:	4421      	add	r1, r4
6000affc:	42b1      	cmp	r1, r6
6000affe:	dd03      	ble.n	6000b008 <mcux_igpio_configure+0xbe>
				return -ENOTSUP;
6000b000:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
6000b004:	b007      	add	sp, #28
6000b006:	bdf0      	pop	{r4, r5, r6, r7, pc}
			cfg_idx -= config->pin_gaps[i].len;
6000b008:	1b00      	subs	r0, r0, r4
	for (i = 0; i < config->gap_count; i++) {
6000b00a:	3201      	adds	r2, #1
6000b00c:	e7a7      	b.n	6000af5e <mcux_igpio_configure+0x14>
		reg &= ~IOMUXC_SW_PAD_CTL_PAD_PUE_MASK;
6000b00e:	f423 5400 	bic.w	r4, r3, #8192	; 0x2000
6000b012:	e7c0      	b.n	6000af96 <mcux_igpio_configure+0x4c>

6000b014 <mcux_igpio_0_init>:
			   (MCUX_IGPIO_IRQ_INIT(n, 1);))		\
									\
		return 0;						\
	}

DT_INST_FOREACH_STATUS_OKAY(MCUX_IGPIO_INIT)
6000b014:	2200      	movs	r2, #0
6000b016:	2050      	movs	r0, #80	; 0x50
6000b018:	b508      	push	{r3, lr}
6000b01a:	4611      	mov	r1, r2
6000b01c:	f7f9 fbe8 	bl	600047f0 <z_arm_irq_priority_set>
6000b020:	2050      	movs	r0, #80	; 0x50
6000b022:	f7f9 fbd7 	bl	600047d4 <arch_irq_enable>
6000b026:	2200      	movs	r2, #0
6000b028:	2051      	movs	r0, #81	; 0x51
6000b02a:	4611      	mov	r1, r2
6000b02c:	f7f9 fbe0 	bl	600047f0 <z_arm_irq_priority_set>
6000b030:	2051      	movs	r0, #81	; 0x51
6000b032:	f7f9 fbcf 	bl	600047d4 <arch_irq_enable>
6000b036:	2000      	movs	r0, #0
6000b038:	bd08      	pop	{r3, pc}

6000b03a <mcux_igpio_1_init>:
6000b03a:	2200      	movs	r2, #0
6000b03c:	2052      	movs	r0, #82	; 0x52
6000b03e:	b508      	push	{r3, lr}
6000b040:	4611      	mov	r1, r2
6000b042:	f7f9 fbd5 	bl	600047f0 <z_arm_irq_priority_set>
6000b046:	2052      	movs	r0, #82	; 0x52
6000b048:	f7f9 fbc4 	bl	600047d4 <arch_irq_enable>
6000b04c:	2200      	movs	r2, #0
6000b04e:	2053      	movs	r0, #83	; 0x53
6000b050:	4611      	mov	r1, r2
6000b052:	f7f9 fbcd 	bl	600047f0 <z_arm_irq_priority_set>
6000b056:	2053      	movs	r0, #83	; 0x53
6000b058:	f7f9 fbbc 	bl	600047d4 <arch_irq_enable>
6000b05c:	2000      	movs	r0, #0
6000b05e:	bd08      	pop	{r3, pc}

6000b060 <mcux_igpio_2_init>:
6000b060:	2200      	movs	r2, #0
6000b062:	2054      	movs	r0, #84	; 0x54
6000b064:	b508      	push	{r3, lr}
6000b066:	4611      	mov	r1, r2
6000b068:	f7f9 fbc2 	bl	600047f0 <z_arm_irq_priority_set>
6000b06c:	2054      	movs	r0, #84	; 0x54
6000b06e:	f7f9 fbb1 	bl	600047d4 <arch_irq_enable>
6000b072:	2200      	movs	r2, #0
6000b074:	2055      	movs	r0, #85	; 0x55
6000b076:	4611      	mov	r1, r2
6000b078:	f7f9 fbba 	bl	600047f0 <z_arm_irq_priority_set>
6000b07c:	2055      	movs	r0, #85	; 0x55
6000b07e:	f7f9 fba9 	bl	600047d4 <arch_irq_enable>
6000b082:	2000      	movs	r0, #0
6000b084:	bd08      	pop	{r3, pc}

6000b086 <mcux_igpio_3_init>:
6000b086:	2200      	movs	r2, #0
6000b088:	2058      	movs	r0, #88	; 0x58
6000b08a:	b508      	push	{r3, lr}
6000b08c:	4611      	mov	r1, r2
6000b08e:	f7f9 fbaf 	bl	600047f0 <z_arm_irq_priority_set>
6000b092:	2058      	movs	r0, #88	; 0x58
6000b094:	f7f9 fb9e 	bl	600047d4 <arch_irq_enable>
6000b098:	2200      	movs	r2, #0
6000b09a:	2059      	movs	r0, #89	; 0x59
6000b09c:	4611      	mov	r1, r2
6000b09e:	f7f9 fba7 	bl	600047f0 <z_arm_irq_priority_set>
6000b0a2:	2059      	movs	r0, #89	; 0x59
6000b0a4:	f7f9 fb96 	bl	600047d4 <arch_irq_enable>
6000b0a8:	2000      	movs	r0, #0
6000b0aa:	bd08      	pop	{r3, pc}

6000b0ac <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
6000b0ac:	b530      	push	{r4, r5, lr}
	*state = &config->states[0];
6000b0ae:	6803      	ldr	r3, [r0, #0]
6000b0b0:	6013      	str	r3, [r2, #0]
	while (*state < &config->states[config->state_cnt]) {
6000b0b2:	7905      	ldrb	r5, [r0, #4]
6000b0b4:	6804      	ldr	r4, [r0, #0]
6000b0b6:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
6000b0ba:	42a3      	cmp	r3, r4
6000b0bc:	d302      	bcc.n	6000b0c4 <pinctrl_lookup_state+0x18>
		}

		(*state)++;
	}

	return -ENOENT;
6000b0be:	f06f 0001 	mvn.w	r0, #1
}
6000b0c2:	bd30      	pop	{r4, r5, pc}
		if (id == (*state)->id) {
6000b0c4:	795c      	ldrb	r4, [r3, #5]
6000b0c6:	428c      	cmp	r4, r1
6000b0c8:	d001      	beq.n	6000b0ce <pinctrl_lookup_state+0x22>
		(*state)++;
6000b0ca:	3308      	adds	r3, #8
6000b0cc:	e7f0      	b.n	6000b0b0 <pinctrl_lookup_state+0x4>
			return 0;
6000b0ce:	2000      	movs	r0, #0
6000b0d0:	e7f7      	b.n	6000b0c2 <pinctrl_lookup_state+0x16>

6000b0d2 <pinctrl_configure_pins>:
{
6000b0d2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (uint8_t i = 0U; i < pin_cnt; i++) {
6000b0d6:	2700      	movs	r7, #0
				*gpr_register &= ~(0x1 << pins[i].pinmux.gpr_shift);
6000b0d8:	f04f 0801 	mov.w	r8, #1
	for (uint8_t i = 0U; i < pin_cnt; i++) {
6000b0dc:	b2fb      	uxtb	r3, r7
6000b0de:	4299      	cmp	r1, r3
6000b0e0:	d802      	bhi.n	6000b0e8 <pinctrl_configure_pins+0x16>
}
6000b0e2:	2000      	movs	r0, #0
6000b0e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint32_t mux_mode = pins[i].pinmux.mux_mode;
6000b0e8:	7c42      	ldrb	r2, [r0, #17]
			(volatile uint32_t *)((uintptr_t)pins[i].pinmux.gpr_register);
6000b0ea:	68c5      	ldr	r5, [r0, #12]
		uint32_t mux_mode = pins[i].pinmux.mux_mode;
6000b0ec:	f002 040f 	and.w	r4, r2, #15
		uint32_t mux_register = pins[i].pinmux.mux_register;
6000b0f0:	f8d0 9000 	ldr.w	r9, [r0]
		uint32_t input_register = pins[i].pinmux.input_register;
6000b0f4:	f8d0 e008 	ldr.w	lr, [r0, #8]
		uint32_t input_daisy = pins[i].pinmux.input_daisy;
6000b0f8:	0912      	lsrs	r2, r2, #4
		uint32_t config_register = pins[i].pinmux.config_register;
6000b0fa:	f8d0 c004 	ldr.w	ip, [r0, #4]
		uint32_t pin_ctrl_flags = pins[i].pin_ctrl_flags;
6000b0fe:	6946      	ldr	r6, [r0, #20]
		if (gpr_register) {
6000b100:	b185      	cbz	r5, 6000b124 <pinctrl_configure_pins+0x52>
			if (pins[i].pinmux.gpr_val) {
6000b102:	7c83      	ldrb	r3, [r0, #18]
					(pins[i].pinmux.gpr_val << pins[i].pinmux.gpr_shift);
6000b104:	f890 b010 	ldrb.w	fp, [r0, #16]
			if (pins[i].pinmux.gpr_val) {
6000b108:	f013 0f01 	tst.w	r3, #1
					(pins[i].pinmux.gpr_val << pins[i].pinmux.gpr_shift);
6000b10c:	f00b 0b1f 	and.w	fp, fp, #31
			if (pins[i].pinmux.gpr_val) {
6000b110:	d020      	beq.n	6000b154 <pinctrl_configure_pins+0x82>
					(pins[i].pinmux.gpr_val << pins[i].pinmux.gpr_shift);
6000b112:	f003 0301 	and.w	r3, r3, #1
				*gpr_register |=
6000b116:	f8d5 a000 	ldr.w	sl, [r5]
					(pins[i].pinmux.gpr_val << pins[i].pinmux.gpr_shift);
6000b11a:	fa03 f30b 	lsl.w	r3, r3, fp
				*gpr_register |=
6000b11e:	ea43 030a 	orr.w	r3, r3, sl
				*gpr_register &= ~(0x1 << pins[i].pinmux.gpr_shift);
6000b122:	602b      	str	r3, [r5, #0]
			IOMUXC_SW_MUX_CTL_PAD_SION(MCUX_IMX_INPUT_ENABLE(pin_ctrl_flags));
6000b124:	0ff3      	lsrs	r3, r6, #31
			IOMUXC_SW_MUX_CTL_PAD_MUX_MODE(mux_mode) |
6000b126:	f004 0407 	and.w	r4, r4, #7
6000b12a:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
		*((volatile uint32_t *)((uintptr_t)mux_register)) =
6000b12e:	f8c9 4000 	str.w	r4, [r9]
		if (input_register) {
6000b132:	f1be 0f00 	cmp.w	lr, #0
6000b136:	d003      	beq.n	6000b140 <pinctrl_configure_pins+0x6e>
				IOMUXC_SELECT_INPUT_DAISY(input_daisy);
6000b138:	f002 0207 	and.w	r2, r2, #7
			*((volatile uint32_t *)((uintptr_t)input_register)) =
6000b13c:	f8ce 2000 	str.w	r2, [lr]
		if (config_register) {
6000b140:	f1bc 0f00 	cmp.w	ip, #0
6000b144:	d003      	beq.n	6000b14e <pinctrl_configure_pins+0x7c>
				pin_ctrl_flags & (~(0x1 << MCUX_IMX_INPUT_ENABLE_SHIFT));
6000b146:	f026 4600 	bic.w	r6, r6, #2147483648	; 0x80000000
			*((volatile uint32_t *)((uintptr_t)config_register)) =
6000b14a:	f8cc 6000 	str.w	r6, [ip]
	for (uint8_t i = 0U; i < pin_cnt; i++) {
6000b14e:	3701      	adds	r7, #1
6000b150:	3018      	adds	r0, #24
6000b152:	e7c3      	b.n	6000b0dc <pinctrl_configure_pins+0xa>
				*gpr_register &= ~(0x1 << pins[i].pinmux.gpr_shift);
6000b154:	682b      	ldr	r3, [r5, #0]
6000b156:	fa08 fb0b 	lsl.w	fp, r8, fp
6000b15a:	ea23 030b 	bic.w	r3, r3, fp
6000b15e:	e7e0      	b.n	6000b122 <pinctrl_configure_pins+0x50>

6000b160 <mcux_lpuart_config_get>:
}

#ifdef CONFIG_UART_USE_RUNTIME_CONFIGURE
static int mcux_lpuart_config_get(const struct device *dev, struct uart_config *cfg)
{
	struct mcux_lpuart_data *data = dev->data;
6000b160:	6902      	ldr	r2, [r0, #16]
{
6000b162:	460b      	mov	r3, r1
	*cfg = data->uart_config;
6000b164:	e892 0003 	ldmia.w	r2, {r0, r1}
6000b168:	e883 0003 	stmia.w	r3, {r0, r1}
	return 0;
}
6000b16c:	2000      	movs	r0, #0
6000b16e:	4770      	bx	lr

6000b170 <mcux_lpuart_configure_init>:
{
6000b170:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct mcux_lpuart_config *config = dev->config;
6000b174:	6844      	ldr	r4, [r0, #4]
{
6000b176:	b086      	sub	sp, #24
	struct mcux_lpuart_data *data = dev->data;
6000b178:	f8d0 8010 	ldr.w	r8, [r0, #16]
{
6000b17c:	460d      	mov	r5, r1
	if (!device_is_ready(config->clock_dev)) {
6000b17e:	6860      	ldr	r0, [r4, #4]
6000b180:	f000 f980 	bl	6000b484 <z_device_is_ready>
6000b184:	4607      	mov	r7, r0
6000b186:	2800      	cmp	r0, #0
6000b188:	d06e      	beq.n	6000b268 <mcux_lpuart_configure_init+0xf8>
	if (clock_control_get_rate(config->clock_dev, config->clock_subsys,
6000b18a:	6860      	ldr	r0, [r4, #4]
6000b18c:	68e1      	ldr	r1, [r4, #12]
	if (api->get_rate == NULL) {
6000b18e:	6883      	ldr	r3, [r0, #8]
6000b190:	68db      	ldr	r3, [r3, #12]
6000b192:	b92b      	cbnz	r3, 6000b1a0 <mcux_lpuart_configure_init+0x30>
		return -EINVAL;
6000b194:	f06f 0615 	mvn.w	r6, #21
}
6000b198:	4630      	mov	r0, r6
6000b19a:	b006      	add	sp, #24
6000b19c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return api->get_rate(dev, sys, rate);
6000b1a0:	466a      	mov	r2, sp
6000b1a2:	4798      	blx	r3
	if (clock_control_get_rate(config->clock_dev, config->clock_subsys,
6000b1a4:	4606      	mov	r6, r0
6000b1a6:	2800      	cmp	r0, #0
6000b1a8:	d1f4      	bne.n	6000b194 <mcux_lpuart_configure_init+0x24>
	LPUART_GetDefaultConfig(&uart_config);
6000b1aa:	a801      	add	r0, sp, #4
6000b1ac:	f7fd fc80 	bl	60008ab0 <LPUART_GetDefaultConfig>
	switch (cfg->parity) {
6000b1b0:	792b      	ldrb	r3, [r5, #4]
6000b1b2:	2b01      	cmp	r3, #1
6000b1b4:	d005      	beq.n	6000b1c2 <mcux_lpuart_configure_init+0x52>
6000b1b6:	2b02      	cmp	r3, #2
6000b1b8:	d004      	beq.n	6000b1c4 <mcux_lpuart_configure_init+0x54>
6000b1ba:	b11b      	cbz	r3, 6000b1c4 <mcux_lpuart_configure_init+0x54>
		return -ENOTSUP;
6000b1bc:	f06f 0685 	mvn.w	r6, #133	; 0x85
6000b1c0:	e7ea      	b.n	6000b198 <mcux_lpuart_configure_init+0x28>
	switch (cfg->parity) {
6000b1c2:	2303      	movs	r3, #3
		uart_config.parityMode = kLPUART_ParityDisabled;
6000b1c4:	f88d 3008 	strb.w	r3, [sp, #8]
	switch (cfg->data_bits) {
6000b1c8:	79ab      	ldrb	r3, [r5, #6]
6000b1ca:	2b02      	cmp	r3, #2
6000b1cc:	d048      	beq.n	6000b260 <mcux_lpuart_configure_init+0xf0>
6000b1ce:	2b03      	cmp	r3, #3
6000b1d0:	d1f4      	bne.n	6000b1bc <mcux_lpuart_configure_init+0x4c>
6000b1d2:	2300      	movs	r3, #0
		uart_config.dataBitsCount  = kLPUART_SevenDataBits;
6000b1d4:	f88d 3009 	strb.w	r3, [sp, #9]
	switch (cfg->stop_bits) {
6000b1d8:	796b      	ldrb	r3, [r5, #5]
6000b1da:	2b01      	cmp	r3, #1
6000b1dc:	d042      	beq.n	6000b264 <mcux_lpuart_configure_init+0xf4>
6000b1de:	2b03      	cmp	r3, #3
6000b1e0:	d1ec      	bne.n	6000b1bc <mcux_lpuart_configure_init+0x4c>
6000b1e2:	2301      	movs	r3, #1
		uart_config.stopBitCount = kLPUART_OneStopBit;
6000b1e4:	f88d 300b 	strb.w	r3, [sp, #11]
	switch (cfg->flow_ctrl) {
6000b1e8:	79eb      	ldrb	r3, [r5, #7]
6000b1ea:	2b01      	cmp	r3, #1
6000b1ec:	d004      	beq.n	6000b1f8 <mcux_lpuart_configure_init+0x88>
6000b1ee:	2b03      	cmp	r3, #3
6000b1f0:	d001      	beq.n	6000b1f6 <mcux_lpuart_configure_init+0x86>
6000b1f2:	2b00      	cmp	r3, #0
6000b1f4:	d1e2      	bne.n	6000b1bc <mcux_lpuart_configure_init+0x4c>
6000b1f6:	2700      	movs	r7, #0
	uart_config.baudRate_Bps = cfg->baudrate;
6000b1f8:	682b      	ldr	r3, [r5, #0]
	LPUART_Init(config->base, &uart_config, clock_freq);
6000b1fa:	a901      	add	r1, sp, #4
		uart_config.enableTxCTS = false;
6000b1fc:	f88d 700f 	strb.w	r7, [sp, #15]
	uart_config.baudRate_Bps = cfg->baudrate;
6000b200:	9301      	str	r3, [sp, #4]
	uart_config.enableTx = false;
6000b202:	f44f 7380 	mov.w	r3, #256	; 0x100
		uart_config.enableRxRTS = false;
6000b206:	f88d 700e 	strb.w	r7, [sp, #14]
	uart_config.enableTx = false;
6000b20a:	f8ad 3014 	strh.w	r3, [sp, #20]
	LPUART_Init(config->base, &uart_config, clock_freq);
6000b20e:	9a00      	ldr	r2, [sp, #0]
6000b210:	6820      	ldr	r0, [r4, #0]
6000b212:	f7fd fb2d 	bl	60008870 <LPUART_Init>
	if (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RS485) {
6000b216:	79eb      	ldrb	r3, [r5, #7]
6000b218:	2b03      	cmp	r3, #3
6000b21a:	d10b      	bne.n	6000b234 <mcux_lpuart_configure_init+0xc4>
		config->base->MODIR |= LPUART_MODIR_TXRTSE(true);
6000b21c:	6822      	ldr	r2, [r4, #0]
6000b21e:	6a53      	ldr	r3, [r2, #36]	; 0x24
6000b220:	f043 0302 	orr.w	r3, r3, #2
6000b224:	6253      	str	r3, [r2, #36]	; 0x24
		if (!config->rs485_de_active_low) {
6000b226:	7d63      	ldrb	r3, [r4, #21]
6000b228:	b923      	cbnz	r3, 6000b234 <mcux_lpuart_configure_init+0xc4>
			config->base->MODIR |= LPUART_MODIR_TXRTSPOL(1);
6000b22a:	6822      	ldr	r2, [r4, #0]
6000b22c:	6a53      	ldr	r3, [r2, #36]	; 0x24
6000b22e:	f043 0304 	orr.w	r3, r3, #4
6000b232:	6253      	str	r3, [r2, #36]	; 0x24
	config->base->CTRL |= LPUART_CTRL_TE(true);
6000b234:	6822      	ldr	r2, [r4, #0]
6000b236:	6993      	ldr	r3, [r2, #24]
6000b238:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
6000b23c:	6193      	str	r3, [r2, #24]
	if (config->loopback_en) {
6000b23e:	7da3      	ldrb	r3, [r4, #22]
6000b240:	b14b      	cbz	r3, 6000b256 <mcux_lpuart_configure_init+0xe6>
		config->base->CTRL |= LPUART_CTRL_LOOPS_MASK;
6000b242:	6822      	ldr	r2, [r4, #0]
6000b244:	6993      	ldr	r3, [r2, #24]
6000b246:	f043 0380 	orr.w	r3, r3, #128	; 0x80
6000b24a:	6193      	str	r3, [r2, #24]
		config->base->CTRL &= ~LPUART_CTRL_RSRC_MASK;
6000b24c:	6822      	ldr	r2, [r4, #0]
6000b24e:	6993      	ldr	r3, [r2, #24]
6000b250:	f023 0320 	bic.w	r3, r3, #32
6000b254:	6193      	str	r3, [r2, #24]
	data->uart_config = *cfg;
6000b256:	e895 0003 	ldmia.w	r5, {r0, r1}
6000b25a:	e888 0003 	stmia.w	r8, {r0, r1}
	return 0;
6000b25e:	e79b      	b.n	6000b198 <mcux_lpuart_configure_init+0x28>
	switch (cfg->data_bits) {
6000b260:	2301      	movs	r3, #1
6000b262:	e7b7      	b.n	6000b1d4 <mcux_lpuart_configure_init+0x64>
	switch (cfg->stop_bits) {
6000b264:	2300      	movs	r3, #0
6000b266:	e7bd      	b.n	6000b1e4 <mcux_lpuart_configure_init+0x74>
		return -ENODEV;
6000b268:	f06f 0612 	mvn.w	r6, #18
6000b26c:	e794      	b.n	6000b198 <mcux_lpuart_configure_init+0x28>

6000b26e <mcux_lpuart_poll_out>:
{
6000b26e:	b538      	push	{r3, r4, r5, lr}
6000b270:	460c      	mov	r4, r1
	const struct mcux_lpuart_config *config = dev->config;
6000b272:	6845      	ldr	r5, [r0, #4]
	while (!(LPUART_GetStatusFlags(config->base)
6000b274:	6828      	ldr	r0, [r5, #0]
6000b276:	f7fd fc3d 	bl	60008af4 <LPUART_GetStatusFlags>
6000b27a:	0203      	lsls	r3, r0, #8
6000b27c:	d5fa      	bpl.n	6000b274 <mcux_lpuart_poll_out+0x6>
6000b27e:	f04f 0210 	mov.w	r2, #16
6000b282:	f3ef 8311 	mrs	r3, BASEPRI
6000b286:	f382 8812 	msr	BASEPRI_MAX, r2
6000b28a:	f3bf 8f6f 	isb	sy
	LPUART_WriteByte(config->base, c);
6000b28e:	682a      	ldr	r2, [r5, #0]
 * @param base LPUART peripheral base address.
 * @param data Data write to the TX register.
 */
static inline void LPUART_WriteByte(LPUART_Type *base, uint8_t data)
{
    base->DATA = data;
6000b290:	61d4      	str	r4, [r2, #28]
	__asm__ volatile(
6000b292:	f383 8811 	msr	BASEPRI, r3
6000b296:	f3bf 8f6f 	isb	sy
}
6000b29a:	bd38      	pop	{r3, r4, r5, pc}

6000b29c <mcux_lpuart_poll_in>:
{
6000b29c:	b538      	push	{r3, r4, r5, lr}
	const struct mcux_lpuart_config *config = dev->config;
6000b29e:	6845      	ldr	r5, [r0, #4]
{
6000b2a0:	460c      	mov	r4, r1
	uint32_t flags = LPUART_GetStatusFlags(config->base);
6000b2a2:	6828      	ldr	r0, [r5, #0]
6000b2a4:	f7fd fc26 	bl	60008af4 <LPUART_GetStatusFlags>
	if (flags & kLPUART_RxDataRegFullFlag) {
6000b2a8:	0280      	lsls	r0, r0, #10
6000b2aa:	d514      	bpl.n	6000b2d6 <mcux_lpuart_poll_in+0x3a>
		*c = LPUART_ReadByte(config->base);
6000b2ac:	682a      	ldr	r2, [r5, #0]
 * @return Data read from data register.
 */
static inline uint8_t LPUART_ReadByte(LPUART_Type *base)
{
#if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    uint32_t ctrl = base->CTRL;
6000b2ae:	6993      	ldr	r3, [r2, #24]
    uint8_t result;
    bool isSevenDataBits = (((ctrl & LPUART_CTRL_M7_MASK) != 0U) ||
6000b2b0:	0519      	lsls	r1, r3, #20
6000b2b2:	d40c      	bmi.n	6000b2ce <mcux_lpuart_poll_in+0x32>
                            (((ctrl & LPUART_CTRL_M7_MASK) == 0U) && ((ctrl & LPUART_CTRL_M_MASK) == 0U) &&
6000b2b4:	f423 63fd 	bic.w	r3, r3, #2024	; 0x7e8
6000b2b8:	f023 0305 	bic.w	r3, r3, #5
6000b2bc:	051b      	lsls	r3, r3, #20
6000b2be:	0d1b      	lsrs	r3, r3, #20
    bool isSevenDataBits = (((ctrl & LPUART_CTRL_M7_MASK) != 0U) ||
6000b2c0:	2b02      	cmp	r3, #2
6000b2c2:	d004      	beq.n	6000b2ce <mcux_lpuart_poll_in+0x32>
    {
        result = (uint8_t)(base->DATA & 0x7FU);
    }
    else
    {
        result = (uint8_t)base->DATA;
6000b2c4:	69d3      	ldr	r3, [r2, #28]
6000b2c6:	b2db      	uxtb	r3, r3
		ret = 0;
6000b2c8:	2000      	movs	r0, #0
		*c = LPUART_ReadByte(config->base);
6000b2ca:	7023      	strb	r3, [r4, #0]
}
6000b2cc:	bd38      	pop	{r3, r4, r5, pc}
        result = (uint8_t)(base->DATA & 0x7FU);
6000b2ce:	69d3      	ldr	r3, [r2, #28]
6000b2d0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
6000b2d4:	e7f8      	b.n	6000b2c8 <mcux_lpuart_poll_in+0x2c>
	int ret = -1;
6000b2d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	return ret;
6000b2da:	e7f7      	b.n	6000b2cc <mcux_lpuart_poll_in+0x30>

6000b2dc <mcux_lpuart_err_check>:
{
6000b2dc:	b538      	push	{r3, r4, r5, lr}
	const struct mcux_lpuart_config *config = dev->config;
6000b2de:	6845      	ldr	r5, [r0, #4]
	uint32_t flags = LPUART_GetStatusFlags(config->base);
6000b2e0:	6828      	ldr	r0, [r5, #0]
6000b2e2:	f7fd fc07 	bl	60008af4 <LPUART_GetStatusFlags>
	if (flags & kLPUART_RxOverrunFlag) {
6000b2e6:	f3c0 44c0 	ubfx	r4, r0, #19, #1
	if (flags & kLPUART_ParityErrorFlag) {
6000b2ea:	03c1      	lsls	r1, r0, #15
	LPUART_ClearStatusFlags(config->base, kLPUART_RxOverrunFlag |
6000b2ec:	f44f 2170 	mov.w	r1, #983040	; 0xf0000
		err |= UART_ERROR_PARITY;
6000b2f0:	bf48      	it	mi
6000b2f2:	f044 0402 	orrmi.w	r4, r4, #2
	if (flags & kLPUART_FramingErrorFlag) {
6000b2f6:	0382      	lsls	r2, r0, #14
		err |= UART_ERROR_FRAMING;
6000b2f8:	bf48      	it	mi
6000b2fa:	f044 0404 	orrmi.w	r4, r4, #4
	if (flags & kLPUART_NoiseErrorFlag) {
6000b2fe:	0343      	lsls	r3, r0, #13
	LPUART_ClearStatusFlags(config->base, kLPUART_RxOverrunFlag |
6000b300:	6828      	ldr	r0, [r5, #0]
		err |= UART_ERROR_PARITY;
6000b302:	bf48      	it	mi
6000b304:	f044 0402 	orrmi.w	r4, r4, #2
	LPUART_ClearStatusFlags(config->base, kLPUART_RxOverrunFlag |
6000b308:	f7fd fc00 	bl	60008b0c <LPUART_ClearStatusFlags>
}
6000b30c:	4620      	mov	r0, r4
6000b30e:	bd38      	pop	{r3, r4, r5, pc}

6000b310 <mcux_lpuart_init>:
	return 0;
}
#endif /* CONFIG_UART_USE_RUNTIME_CONFIGURE */

static int mcux_lpuart_init(const struct device *dev)
{
6000b310:	b513      	push	{r0, r1, r4, lr}
	const struct mcux_lpuart_config *config = dev->config;
6000b312:	6844      	ldr	r4, [r0, #4]
	struct mcux_lpuart_data *data = dev->data;
6000b314:	6901      	ldr	r1, [r0, #16]
	struct uart_config *uart_api_config = &data->uart_config;
#ifdef CONFIG_PINCTRL
	int err;
#endif

	uart_api_config->baudrate = config->baud_rate;
6000b316:	6923      	ldr	r3, [r4, #16]
6000b318:	600b      	str	r3, [r1, #0]
	uart_api_config->parity = UART_CFG_PARITY_NONE;
6000b31a:	f44f 7380 	mov.w	r3, #256	; 0x100
6000b31e:	808b      	strh	r3, [r1, #4]
	uart_api_config->stop_bits = UART_CFG_STOP_BITS_1;
	uart_api_config->data_bits = UART_CFG_DATA_BITS_8;
6000b320:	2303      	movs	r3, #3
6000b322:	718b      	strb	r3, [r1, #6]
	uart_api_config->flow_ctrl = config->flow_ctrl;
6000b324:	7d23      	ldrb	r3, [r4, #20]
6000b326:	71cb      	strb	r3, [r1, #7]

	/* set initial configuration */
	mcux_lpuart_configure_init(dev, uart_api_config);
6000b328:	f7ff ff22 	bl	6000b170 <mcux_lpuart_configure_init>
	ret = pinctrl_lookup_state(config, id, &state);
6000b32c:	aa01      	add	r2, sp, #4
6000b32e:	2100      	movs	r1, #0
6000b330:	68a0      	ldr	r0, [r4, #8]
6000b332:	f7ff febb 	bl	6000b0ac <pinctrl_lookup_state>
	if (ret < 0) {
6000b336:	2800      	cmp	r0, #0
6000b338:	db05      	blt.n	6000b346 <mcux_lpuart_init+0x36>
	return pinctrl_apply_state_direct(config, state);
6000b33a:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
6000b33c:	2200      	movs	r2, #0
6000b33e:	7919      	ldrb	r1, [r3, #4]
6000b340:	6818      	ldr	r0, [r3, #0]
6000b342:	f7ff fec6 	bl	6000b0d2 <pinctrl_configure_pins>
	data->tx_poll_stream_on = false;
	data->tx_int_stream_on = false;
#endif

	return 0;
}
6000b346:	ea00 70e0 	and.w	r0, r0, r0, asr #31
6000b34a:	b002      	add	sp, #8
6000b34c:	bd10      	pop	{r4, pc}

6000b34e <mcux_lpuart_configure>:
{
6000b34e:	b538      	push	{r3, r4, r5, lr}
	LPUART_Deinit(config->base);
6000b350:	6843      	ldr	r3, [r0, #4]
{
6000b352:	4604      	mov	r4, r0
6000b354:	460d      	mov	r5, r1
	LPUART_Deinit(config->base);
6000b356:	6818      	ldr	r0, [r3, #0]
6000b358:	f7fd fb8e 	bl	60008a78 <LPUART_Deinit>
	int ret = mcux_lpuart_configure_init(dev, cfg);
6000b35c:	4620      	mov	r0, r4
6000b35e:	4629      	mov	r1, r5
6000b360:	f7ff ff06 	bl	6000b170 <mcux_lpuart_configure_init>
	if (ret) {
6000b364:	4604      	mov	r4, r0
6000b366:	b918      	cbnz	r0, 6000b370 <mcux_lpuart_configure+0x22>
	return z_impl_k_sleep(timeout);
6000b368:	200a      	movs	r0, #10
6000b36a:	2100      	movs	r1, #0
6000b36c:	f7fe fe8c 	bl	6000a088 <z_impl_k_sleep>
}
6000b370:	4620      	mov	r0, r4
6000b372:	bd38      	pop	{r3, r4, r5, pc}

6000b374 <spi_mcux_config_func_0>:
			    spi_mcux_isr, DEVICE_DT_INST_GET(n), 0);	\
									\
		irq_enable(DT_INST_IRQN(n));				\
	}

DT_INST_FOREACH_STATUS_OKAY(SPI_MCUX_LPSPI_INIT)
6000b374:	2020      	movs	r0, #32
6000b376:	2200      	movs	r2, #0
6000b378:	2103      	movs	r1, #3
6000b37a:	b508      	push	{r3, lr}
6000b37c:	f7f9 fa38 	bl	600047f0 <z_arm_irq_priority_set>
6000b380:	2020      	movs	r0, #32
6000b382:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
6000b386:	f7f9 ba25 	b.w	600047d4 <arch_irq_enable>

6000b38a <spi_mcux_isr>:
	LPSPI_MasterTransferHandleIRQ(base, &data->handle);
6000b38a:	6901      	ldr	r1, [r0, #16]
	LPSPI_Type *base = config->base;
6000b38c:	6843      	ldr	r3, [r0, #4]
	LPSPI_MasterTransferHandleIRQ(base, &data->handle);
6000b38e:	3104      	adds	r1, #4
6000b390:	6818      	ldr	r0, [r3, #0]
6000b392:	f7fc be33 	b.w	60007ffc <LPSPI_MasterTransferHandleIRQ>

6000b396 <spi_context_get_next_buf.constprop.0>:
static inline void *spi_context_get_next_buf(const struct spi_buf **current,
6000b396:	b510      	push	{r4, lr}
	while (*count) {
6000b398:	680b      	ldr	r3, [r1, #0]
6000b39a:	b913      	cbnz	r3, 6000b3a2 <spi_context_get_next_buf.constprop.0+0xc>
	return NULL;
6000b39c:	4618      	mov	r0, r3
	*buf_len = 0;
6000b39e:	6013      	str	r3, [r2, #0]
	return NULL;
6000b3a0:	e005      	b.n	6000b3ae <spi_context_get_next_buf.constprop.0+0x18>
		if (((*current)->len / dfs) != 0) {
6000b3a2:	6803      	ldr	r3, [r0, #0]
6000b3a4:	685c      	ldr	r4, [r3, #4]
6000b3a6:	b11c      	cbz	r4, 6000b3b0 <spi_context_get_next_buf.constprop.0+0x1a>
			*buf_len = (*current)->len / dfs;
6000b3a8:	6014      	str	r4, [r2, #0]
			return (*current)->buf;
6000b3aa:	6803      	ldr	r3, [r0, #0]
6000b3ac:	6818      	ldr	r0, [r3, #0]
}
6000b3ae:	bd10      	pop	{r4, pc}
		++(*current);
6000b3b0:	3308      	adds	r3, #8
6000b3b2:	6003      	str	r3, [r0, #0]
		--(*count);
6000b3b4:	680b      	ldr	r3, [r1, #0]
6000b3b6:	3b01      	subs	r3, #1
6000b3b8:	600b      	str	r3, [r1, #0]
6000b3ba:	e7ed      	b.n	6000b398 <spi_context_get_next_buf.constprop.0+0x2>

6000b3bc <_spi_context_cs_control>:
{
6000b3bc:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
6000b3be:	6803      	ldr	r3, [r0, #0]
{
6000b3c0:	4604      	mov	r4, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
6000b3c2:	b1e3      	cbz	r3, 6000b3fe <_spi_context_cs_control+0x42>
6000b3c4:	6898      	ldr	r0, [r3, #8]
6000b3c6:	b1d0      	cbz	r0, 6000b3fe <_spi_context_cs_control+0x42>
6000b3c8:	6805      	ldr	r5, [r0, #0]
6000b3ca:	b1c5      	cbz	r5, 6000b3fe <_spi_context_cs_control+0x42>
		if (on) {
6000b3cc:	b149      	cbz	r1, 6000b3e2 <_spi_context_cs_control+0x26>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 1);
6000b3ce:	2101      	movs	r1, #1
6000b3d0:	f7fa fde0 	bl	60005f94 <gpio_pin_set_dt.isra.0>
			k_busy_wait(ctx->config->cs->delay);
6000b3d4:	6823      	ldr	r3, [r4, #0]
6000b3d6:	689b      	ldr	r3, [r3, #8]
6000b3d8:	6898      	ldr	r0, [r3, #8]
}
6000b3da:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
6000b3de:	f7ff bad3 	b.w	6000a988 <z_impl_k_busy_wait>
			if (!force_off &&
6000b3e2:	b912      	cbnz	r2, 6000b3ea <_spi_context_cs_control+0x2e>
6000b3e4:	889b      	ldrh	r3, [r3, #4]
6000b3e6:	04db      	lsls	r3, r3, #19
6000b3e8:	d409      	bmi.n	6000b3fe <_spi_context_cs_control+0x42>
			k_busy_wait(ctx->config->cs->delay);
6000b3ea:	6880      	ldr	r0, [r0, #8]
6000b3ec:	f7ff facc 	bl	6000a988 <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
6000b3f0:	6823      	ldr	r3, [r4, #0]
6000b3f2:	2100      	movs	r1, #0
6000b3f4:	6898      	ldr	r0, [r3, #8]
}
6000b3f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
6000b3fa:	f7fa bdcb 	b.w	60005f94 <gpio_pin_set_dt.isra.0>
}
6000b3fe:	bd38      	pop	{r3, r4, r5, pc}

6000b400 <spi_context_unlock_unconditionally>:
{
6000b400:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
6000b402:	2201      	movs	r2, #1
6000b404:	2100      	movs	r1, #0
{
6000b406:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
6000b408:	f7ff ffd8 	bl	6000b3bc <_spi_context_cs_control>
	if (!k_sem_count_get(&ctx->lock)) {
6000b40c:	69a3      	ldr	r3, [r4, #24]
6000b40e:	b933      	cbnz	r3, 6000b41e <spi_context_unlock_unconditionally+0x1e>
		ctx->owner = NULL;
6000b410:	6063      	str	r3, [r4, #4]
	z_impl_k_sem_give(sem);
6000b412:	f104 0010 	add.w	r0, r4, #16
}
6000b416:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
6000b41a:	f7fd be8d 	b.w	60009138 <z_impl_k_sem_give>
6000b41e:	bd10      	pop	{r4, pc}

6000b420 <spi_mcux_release>:
{
6000b420:	b508      	push	{r3, lr}
	spi_context_unlock_unconditionally(&data->ctx);
6000b422:	6900      	ldr	r0, [r0, #16]
6000b424:	303c      	adds	r0, #60	; 0x3c
6000b426:	f7ff ffeb 	bl	6000b400 <spi_context_unlock_unconditionally>
}
6000b42a:	2000      	movs	r0, #0
6000b42c:	bd08      	pop	{r3, pc}

6000b42e <SystemInitHook>:
   -- SystemInitHook()
   ---------------------------------------------------------------------------- */

__attribute__ ((weak)) void SystemInitHook (void) {
  /* Void implementation of the weak function. */
}
6000b42e:	4770      	bx	lr

6000b430 <EDMA_AbortTransfer>:
    handle->base->CERQ = DMA_CERQ_CERQ(handle->channel);
6000b430:	7c03      	ldrb	r3, [r0, #16]
    handle->base->TCD[handle->channel].CSR = 0;
6000b432:	f241 011c 	movw	r1, #4124	; 0x101c
    handle->base->CERQ = DMA_CERQ_CERQ(handle->channel);
6000b436:	6882      	ldr	r2, [r0, #8]
6000b438:	f003 031f 	and.w	r3, r3, #31
6000b43c:	7693      	strb	r3, [r2, #26]
    handle->base->TCD[handle->channel].CSR = 0;
6000b43e:	6883      	ldr	r3, [r0, #8]
6000b440:	7c02      	ldrb	r2, [r0, #16]
6000b442:	eb03 1242 	add.w	r2, r3, r2, lsl #5
6000b446:	2300      	movs	r3, #0
6000b448:	5253      	strh	r3, [r2, r1]
    handle->base->TCD[handle->channel].DLAST_SGA = 0;
6000b44a:	7c01      	ldrb	r1, [r0, #16]
6000b44c:	6882      	ldr	r2, [r0, #8]
6000b44e:	eb02 1241 	add.w	r2, r2, r1, lsl #5
6000b452:	f241 0118 	movw	r1, #4120	; 0x1018
6000b456:	5053      	str	r3, [r2, r1]
    handle->base->TCD[handle->channel].CITER_ELINKNO = 0;
6000b458:	7c01      	ldrb	r1, [r0, #16]
6000b45a:	6882      	ldr	r2, [r0, #8]
6000b45c:	eb02 1241 	add.w	r2, r2, r1, lsl #5
6000b460:	f241 0116 	movw	r1, #4118	; 0x1016
6000b464:	5253      	strh	r3, [r2, r1]
    handle->base->TCD[handle->channel].BITER_ELINKNO = 0;
6000b466:	7c01      	ldrb	r1, [r0, #16]
6000b468:	6882      	ldr	r2, [r0, #8]
6000b46a:	eb02 1241 	add.w	r2, r2, r1, lsl #5
6000b46e:	f241 011e 	movw	r1, #4126	; 0x101e
6000b472:	5253      	strh	r3, [r2, r1]
    if (handle->tcdPool != NULL)
6000b474:	68c2      	ldr	r2, [r0, #12]
6000b476:	b11a      	cbz	r2, 6000b480 <EDMA_AbortTransfer+0x50>
        handle->header  = 1;
6000b478:	2201      	movs	r2, #1
6000b47a:	7442      	strb	r2, [r0, #17]
        handle->tail    = 0;
6000b47c:	7483      	strb	r3, [r0, #18]
        handle->tcdUsed = 0;
6000b47e:	74c3      	strb	r3, [r0, #19]
}
6000b480:	4770      	bx	lr

6000b482 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
6000b482:	4770      	bx	lr

6000b484 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
6000b484:	b140      	cbz	r0, 6000b498 <z_device_is_ready+0x14>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
6000b486:	68c3      	ldr	r3, [r0, #12]
6000b488:	7858      	ldrb	r0, [r3, #1]
6000b48a:	f010 0001 	ands.w	r0, r0, #1
6000b48e:	bf1e      	ittt	ne
6000b490:	7818      	ldrbne	r0, [r3, #0]
6000b492:	fab0 f080 	clzne	r0, r0
6000b496:	0940      	lsrne	r0, r0, #5
}
6000b498:	4770      	bx	lr

6000b49a <arch_system_halt>:
	__asm__ volatile(
6000b49a:	f04f 0210 	mov.w	r2, #16
6000b49e:	f3ef 8311 	mrs	r3, BASEPRI
6000b4a2:	f382 8812 	msr	BASEPRI_MAX, r2
6000b4a6:	f3bf 8f6f 	isb	sy
	for (;;) {
6000b4aa:	e7fe      	b.n	6000b4aa <arch_system_halt+0x10>

6000b4ac <z_early_memset>:
	(void) memset(dst, c, n);
6000b4ac:	f7ff bb6f 	b.w	6000ab8e <memset>

6000b4b0 <z_early_memcpy>:
	(void) memcpy(dst, src, n);
6000b4b0:	f7ff bb62 	b.w	6000ab78 <memcpy>

6000b4b4 <k_thread_name_get>:
}
6000b4b4:	3060      	adds	r0, #96	; 0x60
6000b4b6:	4770      	bx	lr

6000b4b8 <z_impl_k_thread_start>:
	z_sched_start(thread);
6000b4b8:	f7fe b86e 	b.w	60009598 <z_sched_start>

6000b4bc <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
6000b4bc:	4603      	mov	r3, r0
6000b4be:	b920      	cbnz	r0, 6000b4ca <z_reschedule_irqlock+0xe>
6000b4c0:	f3ef 8205 	mrs	r2, IPSR
6000b4c4:	b90a      	cbnz	r2, 6000b4ca <z_reschedule_irqlock+0xe>
6000b4c6:	f7f9 b9ed 	b.w	600048a4 <arch_swap>
	__asm__ volatile(
6000b4ca:	f383 8811 	msr	BASEPRI, r3
6000b4ce:	f3bf 8f6f 	isb	sy
}
6000b4d2:	4770      	bx	lr

6000b4d4 <z_reschedule_unlocked>:
	__asm__ volatile(
6000b4d4:	f04f 0310 	mov.w	r3, #16
6000b4d8:	f3ef 8011 	mrs	r0, BASEPRI
6000b4dc:	f383 8812 	msr	BASEPRI_MAX, r3
6000b4e0:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
6000b4e4:	f7ff bfea 	b.w	6000b4bc <z_reschedule_irqlock>

6000b4e8 <sys_clock_tick_get_32>:
{
6000b4e8:	b508      	push	{r3, lr}
	return (uint32_t)sys_clock_tick_get();
6000b4ea:	f7ff f9ff 	bl	6000a8ec <sys_clock_tick_get>
}
6000b4ee:	bd08      	pop	{r3, pc}
